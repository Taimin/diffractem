
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <title>Welcome to diffractem’s documentation! &#8212; diffractem  documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="welcome-to-diffractem-s-documentation">
<h1>Welcome to diffractem’s documentation!<a class="headerlink" href="#welcome-to-diffractem-s-documentation" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
</div>
<span class="target" id="module-diffractem.dataset"></span><dl class="py class">
<dt id="diffractem.dataset.Dataset">
<em class="property">class </em><code class="sig-prename descclassname">diffractem.dataset.</code><code class="sig-name descname">Dataset</code><a class="headerlink" href="#diffractem.dataset.Dataset" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py method">
<dt id="diffractem.dataset.Dataset.Stacks">
<code class="sig-name descname">Stacks</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#diffractem.dataset.Dataset.Stacks" title="Permalink to this definition">¶</a></dt>
<dd><p>Context manager to handle the opening and closing of stacks.
returns the opened data stacks, which are automatically closed
once the context is left. Arguments are passed to open_stacks Example:</p>
<blockquote>
<div><dl class="simple">
<dt>with ds.Stacks(readonly=True, chunking=’dataset’) as stk:</dt><dd><p>center = stk.beam_center.compute()</p>
</dd>
</dl>
<p>print(‘Have’, center.shape[0], ‘centers.’)</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt id="diffractem.dataset.Dataset.add_stack">
<code class="sig-name descname">add_stack</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">label</span><span class="p">:</span> <span class="n">str</span></em>, <em class="sig-param"><span class="n">stack</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>dask.array.core.Array<span class="p">, </span>numpy.ndarray<span class="p">, </span>h5py._hl.dataset.Dataset<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">overwrite</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">diff_stack</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">persist</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="n">rechunk</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#diffractem.dataset.Dataset.add_stack" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a data stack to the data set
:param label: label of the new stack
:param stack: new stack, can be anything array-like
:param overwrite: allows overwriting an existing stack
:param diff_stack: marks this stack as the main diffraction data
:param persist: persists the dask array to memory, if it is generated</p>
<blockquote>
<div><p>from a numpy array</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>rechunk</strong> – if True, a dask array with chunks along the stack direction that don’t match the datasets
other stacks chunks will be rechunked. Otherwise, a warning is shown.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="diffractem.dataset.Dataset.aggregate">
<code class="sig-name descname">aggregate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">by</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>list<span class="p">, </span>tuple<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">'sample', 'region', 'run', 'crystal_id'</span></em>, <em class="sig-param"><span class="n">how</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>dict<span class="p">, </span>str<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">'mean'</span></em>, <em class="sig-param"><span class="n">file_suffix</span><span class="p">:</span> <span class="n">str</span> <span class="o">=</span> <span class="default_value">'_agg.h5'</span></em>, <em class="sig-param"><span class="n">file_prefix</span><span class="p">:</span> <span class="n">str</span> <span class="o">=</span> <span class="default_value">''</span></em>, <em class="sig-param"><span class="n">new_folder</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>str<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">query</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>str<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">force_commensurate</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="n">exclude_stacks</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>list<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span> &#x2192; <a class="reference internal" href="#diffractem.dataset.Dataset" title="diffractem.dataset.Dataset">diffractem.dataset.Dataset</a><a class="headerlink" href="#diffractem.dataset.Dataset.aggregate" title="Permalink to this definition">¶</a></dt>
<dd><p>Aggregate sub-sets of stacks using different aggregation functions. Typical application: sum sub-stacks of
dose fractionation movies, or shots with different tilt angles (quasi-precession)
:param by: shot table columns to group by for aggregation. Default: (‘run’, ‘region’, ‘crystal_id’, ‘sample’)
:param how: aggregation types. ‘sum’, ‘mean’, and ‘cumsum’ are supported. Can be a single operation for all</p>
<blockquote>
<div><p>stacks, or a dict, specifying different ones for each, in which case all non-explicitly specified stacks
will default to ‘mean’, e.g. how={‘raw_counts’: ‘sum’}.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_suffix</strong> – as in Dataset.change_filenames</p></li>
<li><p><strong>file_prefix</strong> – as in Dataset.change_filenames</p></li>
<li><p><strong>new_folder</strong> – as in Dataset.change_filenames</p></li>
<li><p><strong>query</strong> – apply a query (see select or get_selection)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a new data set with aggregation applied</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="diffractem.dataset.Dataset.change_filenames">
<code class="sig-name descname">change_filenames</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">file_suffix</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>str<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">'.h5'</span></em>, <em class="sig-param"><span class="n">file_prefix</span><span class="p">:</span> <span class="n">str</span> <span class="o">=</span> <span class="default_value">''</span></em>, <em class="sig-param"><span class="n">new_folder</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>str<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fn_map</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>pandas.core.frame.DataFrame<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">keep_raw</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#diffractem.dataset.Dataset.change_filenames" title="Permalink to this definition">¶</a></dt>
<dd><p>Change file names in all lists using some handy modifications. The old file names are copied to a “file_raw”
column, if not already present (can be overriden with keep_raw).
:param file_suffix: add suffix to file, INCLUDING file extension, e.g. ‘_modified.h5’
:param file_prefix: add prefix to actual filenames (not folder/full path!), e.g. ‘<a href="#id11"><span class="problematic" id="id12">aggregated_</span></a>
:param new_folder: if not None, changes folder name to this path
:param fn_map: if not None, gives an explicit table (pd.DataFrame) with columns ‘file’ and ‘file_new’</p>
<blockquote>
<div><p>that manually maps old to new filenames. All other parameters are ignored, if provided</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>keep_raw</strong> – if True (default), does not change the file_raw column in the shot list,
unless there is none yet (in which case the old file names are _always_ copied to keep_raw)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>DataFrame with a map from old to new file names (for reference)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="diffractem.dataset.Dataset.close_stacks">
<code class="sig-name descname">close_stacks</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#diffractem.dataset.Dataset.close_stacks" title="Permalink to this definition">¶</a></dt>
<dd><p>Close the stacks by closing the HDF5 data file handles.
:return:</p>
</dd></dl>

<dl class="py method">
<dt id="diffractem.dataset.Dataset.compute_and_save">
<code class="sig-name descname">compute_and_save</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">diff_stack_label</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>str<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">list_file</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>str<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">client</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>distributed.client.Client<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">exclude_stacks</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>str<span class="p">, </span>List<span class="p">[</span>str<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">overwrite</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">persist_diff</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="n">persist_all</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">compression</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>str<span class="p">, </span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">32004</span></em><span class="sig-paren">)</span><a class="headerlink" href="#diffractem.dataset.Dataset.compute_and_save" title="Permalink to this definition">¶</a></dt>
<dd><p>Compound method to fully compute a dataset and write it to disk. It is designed for completely writing HDF5
files from scratch, not to append to existing ones. Internally calls init_files, store_tables, store_stacks,
store_stack_fast, and write_list.</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>{Optional</strong><strong>[</strong><strong>str</strong><strong>]</strong><strong>} --</strong><strong> [</strong><strong>description</strong><strong>] </strong><strong>(</strong><strong>default</strong> (<em>list_file</em>) – {None})</p></li>
<li><p><strong>{Optional</strong><strong>[</strong><strong>str</strong><strong>]</strong><strong>} --</strong><strong> [</strong><strong>description</strong><strong>] </strong><strong>(</strong><strong>default</strong> – {None})</p></li>
<li><p><strong>{Optional</strong><strong>[</strong><strong>Client</strong><strong>]</strong><strong>} --</strong><strong> [</strong><strong>description</strong><strong>] </strong><strong>(</strong><strong>default</strong> (<em>client</em>) – {None})</p></li>
<li><p><strong>{Optional</strong><strong>[</strong><strong>List</strong><strong>[</strong><strong>str</strong><strong>]</strong><strong>]</strong><strong>} --</strong><strong> [</strong><strong>description</strong><strong>] </strong><strong>(</strong><strong>default</strong> (<em>exclude_stacks</em>) – {None})</p></li>
<li><p><strong>{bool} --</strong><strong> [</strong><strong>description</strong><strong>] </strong><strong>(</strong><strong>default</strong> (<em>persist_all</em>) – {False})</p></li>
<li><p><strong>{bool} --</strong><strong> [</strong><strong>description</strong><strong>] </strong><strong>(</strong><strong>default</strong> – {True})</p></li>
<li><p><strong>{bool} --</strong><strong> [</strong><strong>description</strong><strong>] </strong><strong>(</strong><strong>default</strong> – {False})</p></li>
<li><p><strong>{Union</strong><strong>[</strong><strong>str</strong><strong>, </strong><strong>int</strong><strong>]</strong><strong>} --</strong><strong> [</strong><strong>description</strong><strong>] </strong><strong>(</strong><strong>default</strong> (<em>compression</em>) – {32004})</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – [description]</p></li>
<li><p><strong>ValueError</strong> – [description]</p></li>
<li><p><strong>ValueError</strong> – [description]</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="diffractem.dataset.Dataset.delete_stack">
<code class="sig-name descname">delete_stack</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">label</span><span class="p">:</span> <span class="n">str</span></em>, <em class="sig-param"><span class="n">from_files</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#diffractem.dataset.Dataset.delete_stack" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete a data stack
:param label: stack label
:param from_files: if True, the stack is also deleted in the HDF5 files. Default False.
:return:</p>
</dd></dl>

<dl class="py method">
<dt id="diffractem.dataset.Dataset.from_files">
<em class="property">classmethod </em><code class="sig-name descname">from_files</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">files</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>list<span class="p">, </span>str<span class="p">, </span>tuple<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">open_stacks</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="n">chunking</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>int<span class="p">, </span>str<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">100</span></em>, <em class="sig-param"><span class="n">persist_meta</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="n">init_stacks</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">load_tables</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="n">diff_stack_label</span><span class="p">:</span> <span class="n">str</span> <span class="o">=</span> <span class="default_value">'raw_counts'</span></em>, <em class="sig-param"><span class="n">validate_files</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#diffractem.dataset.Dataset.from_files" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Creates a data set from:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>a .lst file name, which contains a simple list of H5 files (on separate lines). If the .lst file has CrystFEL-style</dt><dd><p>event indicators in it, it will be loaded, and the events present in the list will be selected, the others not.</p>
</dd>
</dl>
</li>
<li><p>a glob pattern (like: ‘data/<a href="#id1"><span class="problematic" id="id2">*</span></a>.h5’)</p></li>
<li><p>a python iterable of files.</p></li>
<li><p>a simple HDF5 file path</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>files</strong> – see above</p></li>
<li><p><strong>init_stacks</strong> – initialize stacks, that is, briefly open the data stacks, check their lengths, and close
them again. Does not hurt usually.</p></li>
<li><p><strong>load_tables</strong> – load the additional tables stored in the files (features, peaks, predictions)</p></li>
<li><p><strong>diff_stack_label</strong> – name of stack to be used for generating the shot table, if it’s not stored in the files</p></li>
<li><p><strong>**kwargs</strong> – <p>Dataset attributes to be set right away</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>dataset object</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="diffractem.dataset.Dataset.from_list">
<em class="property">classmethod </em><code class="sig-name descname">from_list</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">files</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>list<span class="p">, </span>str<span class="p">, </span>tuple<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">open_stacks</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="n">chunking</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>int<span class="p">, </span>str<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">100</span></em>, <em class="sig-param"><span class="n">persist_meta</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="n">init_stacks</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">load_tables</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="n">diff_stack_label</span><span class="p">:</span> <span class="n">str</span> <span class="o">=</span> <span class="default_value">'raw_counts'</span></em>, <em class="sig-param"><span class="n">validate_files</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#diffractem.dataset.Dataset.from_list" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Creates a data set from:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>a .lst file name, which contains a simple list of H5 files (on separate lines). If the .lst file has CrystFEL-style</dt><dd><p>event indicators in it, it will be loaded, and the events present in the list will be selected, the others not.</p>
</dd>
</dl>
</li>
<li><p>a glob pattern (like: ‘data/<a href="#id5"><span class="problematic" id="id6">*</span></a>.h5’)</p></li>
<li><p>a python iterable of files.</p></li>
<li><p>a simple HDF5 file path</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>files</strong> – see above</p></li>
<li><p><strong>init_stacks</strong> – initialize stacks, that is, briefly open the data stacks, check their lengths, and close
them again. Does not hurt usually.</p></li>
<li><p><strong>load_tables</strong> – load the additional tables stored in the files (features, peaks, predictions)</p></li>
<li><p><strong>diff_stack_label</strong> – name of stack to be used for generating the shot table, if it’s not stored in the files</p></li>
<li><p><strong>**kwargs</strong> – <p>Dataset attributes to be set right away</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>dataset object</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="diffractem.dataset.Dataset.generate_virtual_file">
<code class="sig-name descname">generate_virtual_file</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">filename</span><span class="p">:</span> <span class="n">str</span></em>, <em class="sig-param"><span class="n">diff_stack_label</span><span class="p">:</span> <span class="n">str</span></em>, <em class="sig-param"><span class="n">kind</span><span class="p">:</span> <span class="n">str</span> <span class="o">=</span> <span class="default_value">'fake'</span></em>, <em class="sig-param"><span class="n">virtual_size</span><span class="p">:</span> <span class="n">int</span> <span class="o">=</span> <span class="default_value">1024</span></em><span class="sig-paren">)</span><a class="headerlink" href="#diffractem.dataset.Dataset.generate_virtual_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a virtual HDF5 file containing the meta data of the dataset, but not the actual
diffraction. Instead of the diffraction stack, either a dummy stack containing a constant only,
or a virtual dataset with external links to the actual data files is created. While the former
is useful for indexing using CrystFEL, the latter can serve to generate a file for quick preview.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>{str} --</strong><strong> [</strong><strong>description</strong><strong>]</strong> (<em>filename</em>) – </p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>{str} --</strong><strong> [</strong><strong>description</strong><strong>] </strong><strong>(</strong><strong>default</strong> (<em>kind</em>) – {‘fake’})</p></li>
<li><p><strong>{int} --</strong><strong> [</strong><strong>description</strong><strong>] </strong><strong>(</strong><strong>default</strong> (<em>virtual_size</em>) – {1024})</p></li>
</ul>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – [description]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="diffractem.dataset.Dataset.get_selection">
<code class="sig-name descname">get_selection</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">query</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>str<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">file_suffix</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>str<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">'_sel.h5'</span></em>, <em class="sig-param"><span class="n">file_prefix</span><span class="p">:</span> <span class="n">str</span> <span class="o">=</span> <span class="default_value">''</span></em>, <em class="sig-param"><span class="n">new_folder</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>str<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">reset_id</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em><span class="sig-paren">)</span> &#x2192; <a class="reference internal" href="#diffractem.dataset.Dataset" title="diffractem.dataset.Dataset">diffractem.dataset.Dataset</a><a class="headerlink" href="#diffractem.dataset.Dataset.get_selection" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new dataset object by applying a selection. By default, returns all shots with selected == True.
Optionally, a different query string can be supplied (which leaves the selection unaffected).
The stored file names will be changed, to avoid collisions. This can be controlled with the file_suffix and
file_prefix parameters.
:param query: Optional query string, as in the select method
:param file_suffix: as in Dataset.change_filenames
:param file_prefix: as in Dataset.change_filenames
:param new_folder: as in Dataset.change_filenames
:return: new data set.</p>
</dd></dl>

<dl class="py method">
<dt id="diffractem.dataset.Dataset.init_files">
<code class="sig-name descname">init_files</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">overwrite</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">keep_features</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">exclude_list</span><span class="o">=</span><span class="default_value">()</span></em><span class="sig-paren">)</span><a class="headerlink" href="#diffractem.dataset.Dataset.init_files" title="Permalink to this definition">¶</a></dt>
<dd><p>Make new files corresponding to the shot list, by copying over instrument metadata and maps (but not
results, shot list, data arrays,…) from the raw files (as stored in file_raw).
:param overwrite: overwrite new files if not yet existing
:param keep_features: copy over the feature list from the files
:param exclude_list: custom list of HDF5 groups or datasets to exclude from copying
:return:</p>
</dd></dl>

<dl class="py method">
<dt id="diffractem.dataset.Dataset.init_stacks">
<code class="sig-name descname">init_stacks</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#diffractem.dataset.Dataset.init_stacks" title="Permalink to this definition">¶</a></dt>
<dd><p>Opens stacks briefly, to check their sizes etc., and closes them again right away. Helpful to just get their
names and sizes…
:return:</p>
</dd></dl>

<dl class="py method">
<dt id="diffractem.dataset.Dataset.load_tables">
<code class="sig-name descname">load_tables</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">shots</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">features</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">peaks</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">predict</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">files</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#diffractem.dataset.Dataset.load_tables" title="Permalink to this definition">¶</a></dt>
<dd><p>Load pandas metadata tables from the HDF5 files. Set the argument for the table you want to load to True.
:param shots: shot table
:param features: feature table
:param peaks: peak table
:param predict: prediction table
:param files: …allows to supply a custom file list, instead of the stored one. Dangerous.
:return:</p>
</dd></dl>

<dl class="py method">
<dt id="diffractem.dataset.Dataset.merge_pattern_info">
<code class="sig-name descname">merge_pattern_info</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ds_from</span><span class="p">:</span> <span class="n"><a class="reference internal" href="#diffractem.dataset.Dataset" title="diffractem.dataset.Dataset">diffractem.dataset.Dataset</a></span></em>, <em class="sig-param"><span class="n">merge_cols</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>List<span class="p">[</span>str<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">by</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>List<span class="p">[</span>str<span class="p">]</span><span class="p">, </span>Tuple<span class="p">[</span>str<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">'sample', 'region', 'run', 'crystal_id'</span></em>, <em class="sig-param"><span class="n">persist</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#diffractem.dataset.Dataset.merge_pattern_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge shot table columns and peak data from another data set into this one, based
on matching of the shot table columns specified in “by”.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>{Dataset} -- Diffractem Dataset to take information from</strong> (<em>ds_from</em>) – </p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>{List} -- Shot table columns to take over from other data set. If None</strong> (<em>merge_cols</em>) – all columns are taken over which are not present in the shot table currently</p></li>
<li><p><strong>{List} -- Shot table columns to match by.</strong> (<em>by</em>) – Defaults to [‘sample’, ‘region’, ‘run’, ‘crystal_id’]</p></li>
</ul>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – [description] d</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="diffractem.dataset.Dataset.merge_stream">
<code class="sig-name descname">merge_stream</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">streamfile</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>diffractem.stream_parser.StreamParser<span class="p">, </span>str<span class="p">]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#diffractem.dataset.Dataset.merge_stream" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads a CrystFEL stream file, and merges its contents into the dataset object.
:param streamfile: file name of streamfile, or StreamParser object
:return:</p>
</dd></dl>

<dl class="py method">
<dt id="diffractem.dataset.Dataset.open_stacks">
<code class="sig-name descname">open_stacks</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">labels</span><span class="p">:</span> <span class="n">Union[None, list]</span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">checklen</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">init</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">readonly</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">swmr</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">chunking</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>int<span class="p">, </span>str<span class="p">, </span>list<span class="p">, </span>tuple<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">'dataset'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#diffractem.dataset.Dataset.open_stacks" title="Permalink to this definition">¶</a></dt>
<dd><p>Opens data stacks from HDF5 (NeXus) files (found by the “data_pattern” attribute), and assigns dask array
objects to them. After opening, the arrays or parts of them can be accessed through the stacks attribute,
or directly using a dataset.stack syntax, and loaded using the .compute() method of the arrays.
Note that, while the stacks are open, no other python kernel will be able to access the data files, and other
codes may not see the modifications made. You will have to call dataset.close_stacks() before.
:param labels: list of stacks to open. Default: None -&gt; opens all stacks
:param checklen: check if stack heights (first dimension) is equal to shot list length
:param init: do not load stacks, just make empty dask arrays. Usually the init_stacks method is more useful.
:param readonly: open HDF5 files in read-only mode (Default: True)
:param swmr: open HDF5 files in SWMR mode (Default: False)
:param chunking: how should the dask arrays be chunked along the 0th (stack) direction. Options are,</p>
<blockquote>
<div><p>in decreasing order of recommendation:
* None, which tries all good options and fails if none works
* ‘dataset’ to use what is set in the current dataset zchunks property (default)
* ‘existing’ to use the chunking of an already-existing stack which is about to be overwritten.</p>
<blockquote>
<div><p>Should usually be the same as ‘dataset’</p>
</div></blockquote>
<ul class="simple">
<li><dl class="simple">
<dt>‘hdf5’ to use the chunksize recommended in the HDF5 file (‘recommended_zchunks’ attribute) of the</dt><dd><p>data stacks group</p>
</dd>
</dl>
</li>
<li><p>an integer number for a defined (approximate) chunk size, which ignores shots with frame number &lt; -1,</p></li>
<li><p>an iterable to explicitly set the chunk sizes</p></li>
<li><p>‘auto’ to use the dask automatic mode</p></li>
</ul>
</div></blockquote>
<p>Generally, a fixed number (integer or iterable) is recommended and gives the least trouble.
already been chunked before. For a fixed number, the chunks are done such that after filtering of frame == -1 shots,
a constant chunk size is achieved.
:return:</p>
</dd></dl>

<dl class="py method">
<dt id="diffractem.dataset.Dataset.persist_stacks">
<code class="sig-name descname">persist_stacks</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">labels</span><span class="p">:</span> <span class="n">Union[None, str, list]</span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">exclude</span><span class="p">:</span> <span class="n">Union[None, str, list]</span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">include_3d</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">scheduler</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>str<span class="p">, </span>distributed.client.Client<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">'threading'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#diffractem.dataset.Dataset.persist_stacks" title="Permalink to this definition">¶</a></dt>
<dd><p>Persist the stacks to memory (locally and/or on the cluster workers), that is, they are computed.
but actually not changed to numpy arrays, just immediately available dask arrays without an actual
task graph. It is recommended to have as many stacks persisted as possible.
The diffraction data stack is automatically excluded.</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>{Union</strong><strong>[</strong><strong>None</strong><strong>, </strong><strong>str</strong><strong>, </strong><strong>list</strong><strong>]</strong><strong>} --</strong><strong> [</strong><strong>description</strong><strong>] </strong><strong>(</strong><strong>default</strong> (<em>exclude</em>) – {None})</p></li>
<li><p><strong>{Union</strong><strong>[</strong><strong>None</strong><strong>, </strong><strong>str</strong><strong>, </strong><strong>list</strong><strong>]</strong><strong>} --</strong><strong> [</strong><strong>description</strong><strong>] </strong><strong>(</strong><strong>default</strong> – {None})</p></li>
<li><p><strong>{bool} --</strong><strong> [</strong><strong>description</strong><strong>] </strong><strong>(</strong><strong>default</strong> (<em>include_3d</em>) – {False})</p></li>
<li><p><strong>{} --</strong> (<em>scheduler</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="diffractem.dataset.Dataset.reset_id">
<code class="sig-name descname">reset_id</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">keep_raw</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#diffractem.dataset.Dataset.reset_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets shot_in_subset and Event columns to continuous numbering. Useful after dataset reduction. The old
Event strings are copied to a “Event_raw” column, if not already present (can be overriden with keep_raw).
:param keep_raw: if True (default), does not change the Event_raw column in the shot list,</p>
<blockquote>
<div><p>unless there is none yet (in which case the old Event IDs are _always_ copied to keep_raw)</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="diffractem.dataset.Dataset.select">
<code class="sig-name descname">select</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">query</span><span class="p">:</span> <span class="n">str</span> <span class="o">=</span> <span class="default_value">'True'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#diffractem.dataset.Dataset.select" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the ‘selected’ column of the shot list by a string query (eg. ‘num_peaks &gt; 30 and frame == 1’).
See pandas documentation for ‘query’ and ‘eval’. If you want to add another criterion to the existing
selection you can also do sth. like ‘selected and hit == 1’.
:param query: if left empty, defaults to ‘True’ -&gt; selects all shots.
:return:</p>
</dd></dl>

<dl class="py method">
<dt id="diffractem.dataset.Dataset.store_stack_fast">
<code class="sig-name descname">store_stack_fast</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">label</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>str<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">client</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>distributed.client.Client<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">sync</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="n">compression</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>int<span class="p">, </span>str<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">32004</span></em><span class="sig-paren">)</span><a class="headerlink" href="#diffractem.dataset.Dataset.store_stack_fast" title="Permalink to this definition">¶</a></dt>
<dd><p>Store (and compute) a single stack to HDF5 file(s), using a dask.distributed cluster.
This allows for proper parallel computation (even on many machines) and is wa(aaa)y faster
than the standard store_stacks, which only works with threads.
It also sets the signal attribute in the NeXus-compliant data group to the given label.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>{str} -- Label of the stack to be computed and stored. If None</strong><strong>, </strong><strong>use the _diff_stack</strong> (<em>label</em>) – setting.</p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>{Optional</strong><strong>[</strong><strong>Client</strong><strong>]</strong><strong>} -- dask.distributed client object. Mandatorily required</strong> (<em>client</em>) – if sync=True. (default: {None})</p></li>
<li><p><strong>{bool} -- if True</strong> (<em>sync</em>) – dataframe containing metadata of everything stored, for validation. If False,
returns a list of dask.delayed objects which encapsulate the computation/storage.</p></li>
<li><p><strong>{Union</strong><strong>[</strong><strong>int</strong><strong>, </strong><strong>str</strong><strong>]</strong><strong>} -- Compression of the dataset to be stored.</strong> (<em>compression</em>) – Defaults to 32004, which is LZ4. Viable alternatives are ‘gzip’, ‘lzf’, or ‘none’.</p></li>
</ul>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – [description]</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>pd.DataFrame (if sync=True), list of dask.delayed (if sync=False)</p>
</dd>
</dl>
<dl class="simple">
<dt>Remarks:</dt><dd><p>If the stack to be stored depends on computationally heavy (but memory-fitting) dask
arrays which you want to retain outside this computation (e.g. to store them using
store_stacks), consider persisting them (using da.persist) before calling sthis function.
Otherwise, they will be re-calculated from scratch.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="diffractem.dataset.Dataset.store_stacks">
<code class="sig-name descname">store_stacks</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">labels</span><span class="p">:</span> <span class="n">Union[None, str, list]</span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">exclude</span><span class="p">:</span> <span class="n">Union[None, str, list]</span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">overwrite</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">compression</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>str<span class="p">, </span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">32004</span></em>, <em class="sig-param"><span class="n">lazy</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">data_pattern</span><span class="p">:</span> <span class="n">Union[None, str]</span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">progress_bar</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">scheduler</span><span class="p">:</span> <span class="n">str</span> <span class="o">=</span> <span class="default_value">'threading'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#diffractem.dataset.Dataset.store_stacks" title="Permalink to this definition">¶</a></dt>
<dd><p>Stores stacks with given labels to the HDF5 data files. If None (default), stores all stacks. New stacks are
typically not yet computed, so at this point the actual data crunching is done. Note that this way of computing
and storing data is restricted to threading or single-threaded computation, i.e. it’s not recommended for
heavy lifting. In this case, better use store_stack_fast.
:param labels: stack(s) to be written
:param exclude: stack(s) to be excluded
:param overwrite: overwrite stacks already existing in the files?
:param compression: compression algorithm to be used. 32004 corresponds to bz4, which we mostly use.
:param lazy: if True, instead of writing the shots, returns two lists containing the arrays and dataset objects</p>
<blockquote>
<div><p>which can be used to later pass them to dask.array.store. Default False (store right away)</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_pattern</strong> – store stacks to this data path (% is replaced by subset) instead of standard path.
Note that stacks stored this way will not be retrievable through Dataset objects.</p></li>
<li><p><strong>progress_bar</strong> – show a progress bar during calculation/storing. Disable if you’re running store_stacks
in multiple processes simultaneously.</p></li>
<li><p><strong>scheduler</strong> – dask scheduler to be used. Can be ‘threading’ or ‘single-threaded’</p></li>
<li><p><strong>**kwargs</strong> – <p>will be forwarded to h5py.create_dataset</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="diffractem.dataset.Dataset.store_tables">
<code class="sig-name descname">store_tables</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">shots</span><span class="p">:</span> <span class="n">Union[None, bool]</span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">features</span><span class="p">:</span> <span class="n">Union[None, bool]</span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">peaks</span><span class="p">:</span> <span class="n">Union[None, bool]</span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">predict</span><span class="p">:</span> <span class="n">Union[None, bool]</span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">format</span><span class="p">:</span> <span class="n">str</span> <span class="o">=</span> <span class="default_value">'nexus'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#diffractem.dataset.Dataset.store_tables" title="Permalink to this definition">¶</a></dt>
<dd><p>Stores the metadata tables (shots, features, peaks, predictions) into HDF5 files. For each of the tables,
it can be automatically determined if they have changed and should be stored…
HOWEVER, this only works if no inplace changes have been made. So don’t rely on it too much.
:param shots: True -&gt; store shot list, False -&gt; don’t store shot list, None -&gt; only store if changed
:param features: similar
:param peaks: similar
:param predict: similar
:param format: format to write metadata tables. ‘nexus’ (recommended) or ‘tables’ (old-style)
:return:</p>
</dd></dl>

<dl class="py method">
<dt id="diffractem.dataset.Dataset.transform_stack_groups">
<code class="sig-name descname">transform_stack_groups</code><span class="sig-paren">(</span><em class="sig-param">stacks: Union[List[str], str], func: Callable[[numpy.ndarray], numpy.ndarray] = &lt;function Dataset.&lt;lambda&gt;&gt;, by: Union[List[str], Tuple[str]] = ('sample', 'region', 'run', 'crystal_id')</em><span class="sig-paren">)</span><a class="headerlink" href="#diffractem.dataset.Dataset.transform_stack_groups" title="Permalink to this definition">¶</a></dt>
<dd><p>For all data stacks listed in stacks, transforms sub-stacks within groups defined by “by”.
As a common example, applies some function to all frames of a diffraction movie. The dimensions of
each sub-stack must not change in the process. Note that this happens in place, i.e., the stacks
will be overwritten by a transformed version.
A typical application is to calculate a cumulative sum of patterns wittin each diffraction movie. This
is what the default parameter for func is doing. Can do all kinds of other fun things, i.e. calculating
directly the difference between frames, the difference of each w.r.t. the first,
normalizing them to sth, etc.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>{List</strong><strong> or </strong><strong>str} -- Name</strong> (<em>stacks</em>) – </p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>{Callable} -- Function applied to each sub-stack. Must act on a numpy</strong> (<em>func</em>) – array and return one of the same dimensions.
Defaults to: lambda x: np.cumsum(x, axis=0)</p></li>
<li><p><strong>{List} -- Shot table columns to identify groups.</strong> (<em>by</em>) – Defaults to [‘sample’, ‘region’, ‘run’, ‘crystal_id’]</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="diffractem.dataset.Dataset.write_list">
<code class="sig-name descname">write_list</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">listfile</span><span class="p">:</span> <span class="n">str</span></em><span class="sig-paren">)</span><a class="headerlink" href="#diffractem.dataset.Dataset.write_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes the files in the dataset into a list file, containing each file on a line.
:param listfile: list file name
:return:</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="#">diffractem</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="#">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, Robert Buecker.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.0.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/index.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>