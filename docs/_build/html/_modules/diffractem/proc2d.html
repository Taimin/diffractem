

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>diffractem.proc2d &mdash; diffractem  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> diffractem
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dataset.html">The Dataset object</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../file_format.html">Diffractem NeXus files</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../pre_processing.html">Preprocessing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../edview.html">EDview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../map_image.html">Crystal-map images</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crystfel.html">CrystFEL integration</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">diffractem</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>diffractem.proc2d</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for diffractem.proc2d</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">tifffile</span>
<span class="kn">from</span> <span class="nn">tifffile</span> <span class="kn">import</span> <span class="n">imread</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
<span class="kn">import</span> <span class="nn">dask</span>
<span class="kn">from</span> <span class="nn">dask.distributed</span> <span class="kn">import</span> <span class="n">Client</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">jit</span><span class="p">,</span> <span class="n">prange</span><span class="p">,</span> <span class="n">int64</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">gap_pixels</span><span class="p">,</span> <span class="n">nexus</span>
<span class="kn">from</span> <span class="nn">.pre_proc_opts</span> <span class="kn">import</span> <span class="n">PreProcOpts</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">optimize</span><span class="p">,</span> <span class="n">sparse</span><span class="p">,</span> <span class="n">special</span><span class="p">,</span> <span class="n">interpolate</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage.morphology</span> <span class="kn">import</span> <span class="n">binary_dilation</span>
<span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">disk</span>
<span class="kn">from</span> <span class="nn">astropy.convolution</span> <span class="kn">import</span> <span class="n">Gaussian2DKernel</span><span class="p">,</span> <span class="n">convolve</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage.filters</span> <span class="kn">import</span> <span class="n">median_filter</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Dict</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span><span class="p">,</span> <span class="n">catch_warnings</span><span class="p">,</span> <span class="n">simplefilter</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">h5py</span>


<div class="viewcode-block" id="stack_nested"><a class="viewcode-back" href="../../diffractem.proc2d.html#diffractem.proc2d.stack_nested">[docs]</a><span class="k">def</span> <span class="nf">stack_nested</span><span class="p">(</span><span class="n">data_list</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">dict</span><span class="p">],</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">):</span> 
    <span class="sd">&quot;&quot;&quot;Applies a numpy/dask concatenation/stacking function recursively to a recursive </span>
<span class="sd">    python collection (tuple/list/dict) containing numpy or dask arrays on the lowest level.</span>

<span class="sd">    Args:</span>
<span class="sd">        data_list (Union[tuple, list, dict]): Collection of numpy arrays (can be recursive)</span>
<span class="sd">        func (Callable, optional): Concatenation function to apply. Defaults to np.stack.</span>

<span class="sd">    Returns:</span>
<span class="sd">        same as data_list: tuple/list/dict with concatenated/stacked numpy arrays</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">data_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">data_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">data_list</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">stack_nested</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">data_list</span><span class="p">))</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">stack_nested</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">data_list</span><span class="p">))</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">stack_nested</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">o</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">data_list</span><span class="p">),</span> <span class="n">func</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">data_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">data_list</span><span class="p">)</span></div>


<div class="viewcode-block" id="loop_over_stack"><a class="viewcode-back" href="../../diffractem.proc2d.html#diffractem.proc2d.loop_over_stack">[docs]</a><span class="k">def</span> <span class="nf">loop_over_stack</span><span class="p">(</span><span class="n">fun</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Decorator to (sequentially) loop a 2D processing function over a stack. </span>
<span class="sd">    </span>
<span class="sd">    In brief, if you have a function that either modifies a (single) image or extracts some reduced</span>
<span class="sd">    data from it, this decorator wraps it such that it can operate on a whole stack of images.</span>
<span class="sd">    </span>
<span class="sd">    Works on all functions with signature fun(imgs: np.ndarray, *args, **kwargs),</span>
<span class="sd">    where imgs is a numpy 3D stack or a 2D single image. It has to return either</span>
<span class="sd">    a numpy array,n which case it returns a stacked array of the function output, </span>
<span class="sd">    or a collection containing numpy arrays, each of which is stacked individually.</span>
<span class="sd">    If any of the positional/named arguments is an iterable of the same length </span>
<span class="sd">    as the image stack, it is distributed over the function calls for each </span>
<span class="sd">    image.</span>
<span class="sd">    </span>
<span class="sd">    Note:</span>
<span class="sd">        `loop_over_stack` only works on functions eating numpy arrays, *not* dask arrays.</span>
<span class="sd">        If you want to apply a function to a dask-array image stack, you have to *additionally*</span>
<span class="sd">        wrap it in `dask.array.map_blocks`, `diffractem.dataset._map_sub_blocks`, </span>
<span class="sd">        `diffractem.compute.map_reduction_func` or similar.</span>
<span class="sd">         </span>
<span class="sd">    Args:</span>
<span class="sd">        fun (Callable): function to be decorated</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        Callable: function that loops over an image stack automatically</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#TODO: handle functions with multiple outputs, and return a list of ndarrays</span>
    <span class="c1">#TODO: allow switches for paralellization</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">fun</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">loop_fun</span><span class="p">(</span><span class="n">imgs</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># this is NOT intended for dask arrays!</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">imgs</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;loop_over_stack only works on numpy arrays (not dask etc.). &#39;</span>
                            <span class="sa">f</span><span class="s1">&#39;Passed type to </span><span class="si">{</span><span class="n">fun</span><span class="si">}</span><span class="s1"> is </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">imgs</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">imgs</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fun</span><span class="p">(</span><span class="n">imgs</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">imgs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># some gymnastics if arrays are on weird dimensions (often after map_blocks)</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">else</span> <span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">else</span> <span class="n">a</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="k">return</span> <span class="n">stack_nested</span><span class="p">([</span><span class="n">fun</span><span class="p">(</span><span class="n">imgs</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)])</span>

        <span class="c1">#print(&#39;Applying {} to {} images of shape {}&#39;.format(fun, imgs.shape[0], imgs.shape[1:]))</span>

        <span class="k">def</span> <span class="nf">_isiterable</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="p">(</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="n">iter_args</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_isiterable</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">imgs</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
                <span class="n">iter_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># iter_args.append(repeat(a, lenb(imgs)))</span>
                <span class="n">iter_args</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">a</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">imgs</span><span class="p">))</span>

        <span class="n">iter_kwargs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">_isiterable</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">imgs</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
                <span class="n">iter_kwargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># iter_kwargs.append(repeat(a, len(imgs)))</span>
                <span class="n">iter_kwargs</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">a</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">imgs</span><span class="p">))</span>

        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">imgs</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">iter_args</span> <span class="o">+</span> <span class="n">iter_kwargs</span><span class="p">)):</span>
            <span class="n">theArgs</span> <span class="o">=</span> <span class="n">arg</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)]</span>
            <span class="n">theKwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">arg</span><span class="p">[</span><span class="mi">1</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">):])}</span>
            <span class="c1"># print(&#39;Arguments: &#39;, theArgs)</span>
            <span class="c1"># print(&#39;KW Args:   &#39;, theKwargs)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fun</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">*</span><span class="n">theArgs</span><span class="p">,</span> <span class="o">**</span><span class="n">theKwargs</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">out</span><span class="p">:</span>
            <span class="c1"># required for dask map_blocks init runs</span>
            <span class="c1"># print(&#39;Looping of&#39;,fun,&#39;requested for zero-size input.&#39;)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">imgs</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">imgs</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># print(type(out), type(out[0]))</span>
            <span class="k">return</span> <span class="n">stack_nested</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
                
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Function&#39;</span><span class="p">,</span><span class="n">fun</span><span class="p">,</span><span class="s1">&#39;failed for output array construction.&#39;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">err</span>

    <span class="k">return</span> <span class="n">loop_fun</span></div>


<span class="nd">@loop_over_stack</span>
<span class="k">def</span> <span class="nf">_generate_pattern_info</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">opts</span><span class="p">:</span> <span class="n">PreProcOpts</span><span class="p">,</span> 
                           <span class="n">reference</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                           <span class="n">pxmask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                           <span class="n">centers</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                           <span class="n">lorentz_fit</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &#39;Macro&#39; function computing information from diffraction data and returning it</span>
<span class="sd">    as a dictionary. Primarily intended to be called from `get_pattern_info`.</span>
<span class="sd">    </span>
<span class="sd">    Note:</span>
<span class="sd">        This function is different from most in `proc2d` in that it returns a</span>
<span class="sd">        dictionary, *no* a `np.ndarray`. This has, among others, the implication, that</span>
<span class="sd">        it cannot be called through the dask array interface via `map_blocks`.</span>

<span class="sd">    Args:</span>
<span class="sd">        img (np.ndarray): diffraction image or stack thereof as numpy array.</span>
<span class="sd">        opts (PreProcOpts): pre-processing options.</span>
<span class="sd">        reference (Optional[np.ndarray], optional): reference image for flat-field.</span>
<span class="sd">            correction. If None, grabs the file name from the options file and loads it. </span>
<span class="sd">            This is discouraged as it requires reloading it over and over. Defaults to None.</span>
<span class="sd">        pxmask (Optional[np.ndarray], optional): similar, for pixel mask. Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: Diffraction pattern information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#TODO consider using a NamedTuple for return values instead of a dict</span>
    
    <span class="c1"># computations on diffraction patterns. To be called from get_pattern_info.</span>
    
    <span class="n">reference</span> <span class="o">=</span> <span class="n">imread</span><span class="p">(</span><span class="n">opts</span><span class="o">.</span><span class="n">reference</span><span class="p">)</span> <span class="k">if</span> <span class="n">reference</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">reference</span>
    <span class="n">pxmask</span> <span class="o">=</span> <span class="n">imread</span><span class="p">(</span><span class="n">opts</span><span class="o">.</span><span class="n">pxmask</span><span class="p">)</span> <span class="k">if</span> <span class="n">pxmask</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">pxmask</span>
        
    <span class="kn">from</span> <span class="nn">diffractem.proc_peaks</span> <span class="kn">import</span> <span class="n">_ctr_from_pks</span>
    
    <span class="c1"># apply flatfield and dead-pixel correction to get more accurate COM</span>
    <span class="c1"># CONSIDER DOING THIS OUTSIDE GET PATTERN INFO!</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">apply_flatfield</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">reference</span><span class="p">,</span> <span class="n">keep_type</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">correct_dead_pixels</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">pxmask</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s1">&#39;replace&#39;</span><span class="p">,</span> <span class="n">mask_gaps</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">replace_val</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">centers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># thresholded center-of-mass calculation over x-axis sub-range</span>
        <span class="n">img_ct</span> <span class="o">=</span> <span class="n">img</span><span class="p">[:,(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">opts</span><span class="o">.</span><span class="n">com_xrng</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">:(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">opts</span><span class="o">.</span><span class="n">com_xrng</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">com</span> <span class="o">=</span> <span class="n">center_of_mass</span><span class="p">(</span><span class="n">img_ct</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">opts</span><span class="o">.</span><span class="n">com_threshold</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">img_ct</span><span class="p">,</span><span class="mi">1</span><span class="o">-</span><span class="mf">5e-5</span><span class="p">))</span> <span class="o">+</span> <span class="p">[(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">opts</span><span class="o">.</span><span class="n">com_xrng</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">lorentz_fit</span><span class="p">:</span>
        <span class="c1"># Lorentz fit of direct beam</span>
            <span class="n">lorentz</span> <span class="o">=</span> <span class="n">lorentz_fast</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">com</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">radius</span><span class="o">=</span><span class="n">opts</span><span class="o">.</span><span class="n">lorentz_radius</span><span class="p">,</span>
                                                <span class="n">limit</span><span class="o">=</span><span class="n">opts</span><span class="o">.</span><span class="n">lorentz_maxshift</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">threads</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            
            <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span> <span class="o">=</span> <span class="n">lorentz</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">lorentz</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span> <span class="o">=</span> <span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">com</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">lorentz</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span>
             
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># print(centers.shape)</span>
        <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span> <span class="o">=</span> <span class="n">centers</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">centers</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># print(centers)</span>
        <span class="n">lorentz</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span>
        <span class="n">com</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span>
    
    <span class="c1"># Get peaks using peakfinder8. Note that pf8 parameters are taken straight from the options file,</span>
    <span class="c1"># with automatic underscore/hyphen replacement.</span>
    <span class="c1"># Note that peak positions are CXI convention, i.e. refer to pixel _center_</span>
    <span class="n">peak_data</span> <span class="o">=</span> <span class="n">get_peaks</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">pxmask</span><span class="o">=</span><span class="n">pxmask</span><span class="p">,</span> <span class="n">max_peaks</span><span class="o">=</span><span class="n">opts</span><span class="o">.</span><span class="n">max_peaks</span><span class="p">,</span>
                                <span class="o">**</span><span class="p">{</span><span class="n">k</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span><span class="s1">&#39;_&#39;</span><span class="p">):</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">opts</span><span class="o">.</span><span class="n">peak_search_params</span><span class="o">.</span><span class="n">items</span><span class="p">()},</span>
                                <span class="n">as_dict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">opts</span><span class="o">.</span><span class="n">friedel_refine</span> <span class="ow">and</span> <span class="p">(</span><span class="n">peak_data</span><span class="p">[</span><span class="s1">&#39;nPeaks&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">opts</span><span class="o">.</span><span class="n">min_peaks</span><span class="p">):</span>  
        
        <span class="c1"># prepare peak list. Note the .5, as _ctr_from_pks expects CrystFEL peak convention,</span>
        <span class="c1"># i.e. positions refer to pixel _corner_</span>
        <span class="n">pkl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">peak_data</span><span class="p">[</span><span class="s1">&#39;peakXPosRaw&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="n">peak_data</span><span class="p">[</span><span class="s1">&#39;peakYPosRaw&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="o">.</span><span class="mi">5</span><span class="p">,</span> 
                        <span class="n">peak_data</span><span class="p">[</span><span class="s1">&#39;peakTotalIntensity&#39;</span><span class="p">]),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)[:</span><span class="nb">int</span><span class="p">(</span><span class="n">peak_data</span><span class="p">[</span><span class="s1">&#39;nPeaks&#39;</span><span class="p">]),:]</span>
        <span class="k">if</span> <span class="n">opts</span><span class="o">.</span><span class="n">friedel_max_radius</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rsq</span> <span class="o">=</span> <span class="p">(</span><span class="n">pkl</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">pkl</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y0</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="n">pkl</span> <span class="o">=</span> <span class="n">pkl</span><span class="p">[</span><span class="n">rsq</span> <span class="o">&lt;</span> <span class="n">opts</span><span class="o">.</span><span class="n">friedel_max_radius</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>
        
        <span class="n">ctr_refined</span><span class="p">,</span> <span class="n">cost</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_ctr_from_pks</span><span class="p">(</span><span class="n">pkl</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">]),</span> <span class="n">int_weight</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
                    <span class="n">sigma</span><span class="o">=</span><span class="n">opts</span><span class="o">.</span><span class="n">peak_sigma</span><span class="p">)</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ctr_refined</span><span class="p">,</span> <span class="n">cost</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
    <span class="c1"># print(ctr_refined, x0, y0)</span>
    
    <span class="c1"># virtual ADF detectors</span>
    <span class="n">adf1</span> <span class="o">=</span> <span class="n">apply_virtual_detector</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">opts</span><span class="o">.</span><span class="n">r_adf1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">opts</span><span class="o">.</span><span class="n">r_adf1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ctr_refined</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ctr_refined</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">adf2</span> <span class="o">=</span> <span class="n">apply_virtual_detector</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">opts</span><span class="o">.</span><span class="n">r_adf2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">opts</span><span class="o">.</span><span class="n">r_adf2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ctr_refined</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ctr_refined</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">pattern_info</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;com_x&#39;</span><span class="p">:</span> <span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;com_y&#39;</span><span class="p">:</span> <span class="n">com</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                    <span class="s1">&#39;lor_pk&#39;</span><span class="p">:</span> <span class="n">lorentz</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                    <span class="s1">&#39;lor_x&#39;</span><span class="p">:</span> <span class="n">lorentz</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                    <span class="s1">&#39;lor_y&#39;</span><span class="p">:</span> <span class="n">lorentz</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                    <span class="s1">&#39;lor_hwhm&#39;</span><span class="p">:</span> <span class="n">lorentz</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
                    <span class="s1">&#39;center_x&#39;</span><span class="p">:</span> <span class="n">ctr_refined</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="s1">&#39;center_y&#39;</span><span class="p">:</span> <span class="n">ctr_refined</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                    <span class="s1">&#39;center_refine_score&#39;</span><span class="p">:</span> <span class="n">cost</span><span class="p">,</span>
                    <span class="s1">&#39;adf1&#39;</span><span class="p">:</span> <span class="n">adf1</span><span class="p">,</span>
                    <span class="s1">&#39;adf2&#39;</span><span class="p">:</span> <span class="n">adf2</span><span class="p">,</span>
                    <span class="s1">&#39;num_peaks&#39;</span><span class="p">:</span> <span class="n">peak_data</span><span class="p">[</span><span class="s1">&#39;nPeaks&#39;</span><span class="p">],</span>
                    <span class="s1">&#39;peak_data&#39;</span><span class="p">:</span> <span class="n">peak_data</span><span class="p">}</span>
        
    <span class="k">return</span> <span class="n">pattern_info</span>


<div class="viewcode-block" id="get_pattern_info"><a class="viewcode-back" href="../../diffractem.proc2d.html#diffractem.proc2d.get_pattern_info">[docs]</a><span class="k">def</span> <span class="nf">get_pattern_info</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">],</span> <span class="n">opts</span><span class="p">:</span> <span class="n">PreProcOpts</span><span class="p">,</span> <span class="n">client</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Client</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                     <span class="n">reference</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                     <span class="n">pxmask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                     <span class="n">centers</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">lorentz_fit</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                     <span class="n">lazy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">sync</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                     <span class="n">errors</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;raise&#39;</span><span class="p">,</span> <span class="n">via_array</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                     <span class="n">output_file</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                     <span class="n">shots</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;&#39;Macro&#39; function for getting information about diffraction patterns.</span>
<span class="sd">    </span>
<span class="sd">    `get_pattern_info` finds diffraction peaks and computes information such as pattern center on a given diffraction </span>
<span class="sd">    pattern or stack thereof. By default (`lazy=False` and `sync=True`) it will return a pandas DataFrame containing</span>
<span class="sd">    general information on each pattern, and a dict holding the found peaks in CXI format.</span>
<span class="sd">    </span>
<span class="sd">    The options for preprocessing are passed as a `PreProcOpts` object.</span>
<span class="sd">    </span>
<span class="sd">    Note:</span>
<span class="sd">        This function is essentially a smart wrapper around `prof2d._generate_pattern_info`. If you&#39;d like to change</span>
<span class="sd">        what is actually calculated and how, that is the function to modify!</span>
<span class="sd">    </span>
<span class="sd">    Note:</span>
<span class="sd">        As this function is computationally heavy, it is **very** advisable to use a *dask.distributed* cluster for </span>
<span class="sd">        computation, with a client object supplied to the function call.</span>

<span class="sd">    Args:</span>
<span class="sd">        img (Union[np.ndarray, da.Array]): stack of diffraction patterns, typically a dask array</span>
<span class="sd">        opts (PreProcOpts): pre-processing options.</span>
<span class="sd">        client (Optional[Client], optional): Client object for dask.distributed cluster. If None, runs</span>
<span class="sd">            computation by simply calling `compute` on the stack dask array (discouraged). Defaults to None.</span>
<span class="sd">        reference (Optional[np.ndarray], optional): Flat-field reference image. If None, load the one specified in</span>
<span class="sd">            preprocessing options. Defaults to None.</span>
<span class="sd">        pxmask (Optional[np.ndarray], optional): Pixel mask image. If None, load the one specified in</span>
<span class="sd">            preprocessing options. Defaults to None.</span>
<span class="sd">        centers (np.array or da.Array, optional): N x 2 matrix with known centers of all diffraction patterns. If set,</span>
<span class="sd">            the center-of-mass and Lorentz fit steps are skipped. Depending on the setting of `opts.friedel_refine`,</span>
<span class="sd">            Friedel-mate center refinement is still performed. Defaults to None.</span>
<span class="sd">        lazy (bool, optional): Return `dask.delayed` objects for pattern info generation tasks instead of the final</span>
<span class="sd">            results. Mostly useful for debugging or embedding into more complex workflows. Defaults to False.</span>
<span class="sd">        sync (bool, optional): Immediately compute pattern info. If False, returns futures to pattern info dictionaries</span>
<span class="sd">            instead of DataFrame and peak dict. Defaults to True.</span>
<span class="sd">        errors (str, optional): Behavior if errors arise during eager computation (i.e., `lazy=False`, `sync=True`). If</span>
<span class="sd">            &#39;raise&#39;, errors are raised, if &#39;skip&#39;, they are skipped, and the final data is missing the corresponding</span>
<span class="sd">            shots, which needs to be handled downstream to avoid making a mess. Defaults to &#39;raise&#39;.</span>
<span class="sd">        via_array (bool, optional): Modify calculation such that it avoids `dask.delayed` objects.</span>
<span class="sd">            This drastically improves the scheduling behavior for large datasets. It is also required if you</span>
<span class="sd">            supply the pattern centers to the function. However, precludes the use of lazy and sync. Defaults to False.</span>
<span class="sd">        output_file (str, optional): Filename to store calculation results into. The file will be a valid diffractem-type</span>
<span class="sd">            data file that can be loaded using Dataset objects.</span>
<span class="sd">        shots (pd.DataFrame, optional): Dataframe of shot data of same height as the image array. If not None,</span>
<span class="sd">            its columns will be joined to those of the shot data for storing the results into the output file.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple[pd.DataFrame, dict]: pandas DataFrame holding general pattern information, and dict holding CXI-format</span>
<span class="sd">            peaks. (note that return values are different when using `lazy=True` or `sync=False` - see above)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#TODO could this be refactored into dataset, automatically applying it to the diffraction data set?</span>
    <span class="c1">#TODO would including an option to return cts on top of res_del make sense?</span>
    
    <span class="n">reference</span> <span class="o">=</span> <span class="n">imread</span><span class="p">(</span><span class="n">opts</span><span class="o">.</span><span class="n">reference</span><span class="p">)</span> <span class="k">if</span> <span class="n">reference</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">reference</span>
    <span class="n">pxmask</span> <span class="o">=</span> <span class="n">imread</span><span class="p">(</span><span class="n">opts</span><span class="o">.</span><span class="n">pxmask</span><span class="p">)</span> <span class="k">if</span> <span class="n">pxmask</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">pxmask</span>
<span class="c1">#     print(type(pxmask))</span>
    
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">via_array</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">centers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;If pattern centers are given, you have to set via_array=True.&#39;</span><span class="p">)</span>
        <span class="n">cts</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">to_delayed</span><span class="p">()</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">res_del</span> <span class="o">=</span> <span class="p">[</span><span class="n">dask</span><span class="o">.</span><span class="n">delayed</span><span class="p">(</span><span class="n">_generate_pattern_info</span><span class="p">,</span> <span class="n">nout</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
                                <span class="n">pure</span><span class="o">=</span><span class="kc">True</span><span class="p">)(</span><span class="n">c</span><span class="p">,</span> <span class="n">opts</span><span class="o">=</span><span class="n">opts</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="n">reference</span><span class="p">,</span> <span class="n">pxmask</span><span class="o">=</span><span class="n">pxmask</span><span class="p">,</span> <span class="n">lorentz_fit</span><span class="o">=</span><span class="n">lorentz_fit</span><span class="p">,</span>
                                           <span class="n">dask_key_name</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;pattern_info-</span><span class="si">{</span><span class="n">ii</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cts</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">lazy</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">res_del</span>
        <span class="k">if</span> <span class="n">client</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ftrs</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">res_del</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Running get_pattern_info on cluster at </span><span class="si">{</span><span class="n">client</span><span class="o">.</span><span class="n">scheduler_info</span><span class="p">()[</span><span class="s2">&quot;address&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">. </span><span class="se">\n</span><span class="s1">&#39;</span>
                  <span class="sa">f</span><span class="s1">&#39;Watch progress at </span><span class="si">{</span><span class="n">client</span><span class="o">.</span><span class="n">dashboard_link</span><span class="si">}</span><span class="s1"> (or forward port if remote).&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">sync</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ftrs</span>
            <span class="n">alldat</span> <span class="o">=</span> <span class="n">stack_nested</span><span class="p">(</span><span class="n">client</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">ftrs</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">),</span> <span class="n">func</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;get_pattern_info is run on a dask array without distributed client - might be slow!&#39;</span><span class="p">)</span>
            <span class="n">alldat</span> <span class="o">=</span> <span class="n">dask</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
            
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">)</span> <span class="ow">and</span> <span class="n">via_array</span><span class="p">:</span>
        <span class="c1"># do extra step by casting output of _generate_pattern_info into a dask array and </span>
        <span class="c1"># keep using the dask array API instead of the delayed api as above. For yet not understood</span>
        <span class="c1"># reasons this leads to a much better behavior of the dask scheduler and yields identical results.</span>
        <span class="c1"># it&#39;s just horribly inelegant.</span>
        
        <span class="c1"># function to turn output of _generate_pattern_info into a dask array</span>
        <span class="n">_encode_info</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">info</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">info</span><span class="o">.</span><span class="n">items</span><span class="p">())</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="s1">&#39;peak_data&#39;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">v</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;peak_data&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())])],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># compute info for a single image to get structure of output</span>
        <span class="n">template</span> <span class="o">=</span> <span class="n">_generate_pattern_info</span><span class="p">(</span><span class="n">img</span><span class="p">[:</span><span class="mi">1</span><span class="p">,</span><span class="o">...</span><span class="p">]</span><span class="o">.</span><span class="n">compute</span><span class="p">(),</span> <span class="n">opts</span><span class="p">,</span> <span class="n">centers</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="n">centers</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">centers</span><span class="p">[:</span><span class="mi">1</span><span class="p">,:])</span>
        
        <span class="k">if</span> <span class="n">centers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">centers</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">centers</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="n">info_array</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">map_blocks</span><span class="p">(</span><span class="k">lambda</span> <span class="n">img</span><span class="p">,</span> <span class="n">centers</span><span class="p">:</span> <span class="n">_encode_info</span><span class="p">(</span>
            <span class="n">_generate_pattern_info</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">opts</span><span class="p">,</span> <span class="n">centers</span><span class="o">=</span><span class="n">centers</span><span class="p">,</span> <span class="n">lorentz_fit</span><span class="o">=</span><span class="n">lorentz_fit</span><span class="p">)),</span> <span class="n">centers</span><span class="p">,</span>
                                    <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">,</span> <span class="n">drop_axis</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">new_axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
                                    <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_encode_info</span><span class="p">(</span><span class="n">template</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                                    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;pattern_info&#39;</span><span class="p">)</span>
        <span class="c1"># return info_array # for debugging purposes</span>
        <span class="n">alldat</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">info_array</span><span class="p">,</span> <span class="n">sync</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># recreate shot data table</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">template</span><span class="p">)</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="s1">&#39;peak_data&#39;</span><span class="p">]</span>
        <span class="n">types</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">dtype</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">template</span><span class="o">.</span><span class="n">items</span><span class="p">())</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="s1">&#39;peak_data&#39;</span><span class="p">}</span>
        <span class="n">shotdata</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">alldat</span><span class="p">[:,:</span><span class="nb">len</span><span class="p">(</span><span class="n">cols</span><span class="p">)],</span> <span class="n">columns</span><span class="o">=</span><span class="n">cols</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">types</span><span class="p">)</span>
        
        <span class="c1"># recreate peak info</span>
        <span class="n">pk_cols</span> <span class="o">=</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> 
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">template</span><span class="p">[</span><span class="s1">&#39;peak_data&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())]</span>
        
        <span class="n">peakinfo</span><span class="p">,</span> <span class="n">ii_col</span> <span class="o">=</span> <span class="p">{},</span> <span class="nb">len</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">pk_cols</span><span class="p">:</span>
            <span class="n">peakinfo</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">alldat</span><span class="p">[:,</span> <span class="n">ii_col</span><span class="p">:</span><span class="n">ii_col</span><span class="o">+</span><span class="n">width</span><span class="p">]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
            <span class="n">ii_col</span> <span class="o">+=</span> <span class="n">width</span>

        <span class="k">return</span> <span class="n">shotdata</span><span class="p">,</span> <span class="n">peakinfo</span>
            
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">alldat</span> <span class="o">=</span> <span class="n">_generate_pattern_info</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">opts</span><span class="o">=</span><span class="n">opts</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="n">reference</span><span class="p">,</span> 
                                        <span class="n">pxmask</span><span class="o">=</span><span class="n">pxmask</span><span class="p">,</span> <span class="n">centers</span><span class="o">=</span><span class="n">centers</span><span class="p">,</span> <span class="n">lorentz_fit</span><span class="o">=</span><span class="n">lorentz_fit</span><span class="p">)</span>
        
    <span class="n">shotdata</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">alldat</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)})</span>
    <span class="n">peakinfo</span> <span class="o">=</span> <span class="n">alldat</span><span class="p">[</span><span class="s1">&#39;peak_data&#39;</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">output_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="s1">&#39;image_info.h5&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">peakinfo</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">fh</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;/entry/data/&#39;</span> <span class="o">+</span> <span class="n">k</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">v</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="s1">&#39;gzip&#39;</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">fh</span><span class="p">[</span><span class="s1">&#39;/entry/data&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;recommended_zchunks&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">shotdata_id</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">shots</span><span class="p">,</span> <span class="n">shotdata</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">nexus</span><span class="o">.</span><span class="n">store_table</span><span class="p">(</span><span class="n">shotdata_id</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="s1">&#39;image_info.h5&#39;</span><span class="p">,</span> <span class="n">subset</span><span class="o">=</span><span class="s1">&#39;entry&#39;</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="s1">&#39;/%/shots&#39;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">shotdata</span><span class="p">,</span> <span class="n">peakinfo</span>    </div>


<span class="nd">@loop_over_stack</span>
<span class="k">def</span> <span class="nf">_get_corr_img</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                      <span class="n">x0</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y0</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> 
                      <span class="n">nPeaks</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> 
                      <span class="n">peakXPosRaw</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> 
                      <span class="n">peakYPosRaw</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> 
                      <span class="n">opts</span><span class="p">:</span> <span class="n">PreProcOpts</span><span class="p">,</span>
                      <span class="n">reference</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                      <span class="n">pxmask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Inner function for full correction pipeline. To be called from `correct_image`. Other than</span>
<span class="sd">    that function, this one can only run on numpy arrays.</span>
<span class="sd">    </span>
<span class="sd">    Please see doumentation of `correct_image` for further documentation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">reference</span> <span class="o">=</span> <span class="n">imread</span><span class="p">(</span><span class="n">opts</span><span class="o">.</span><span class="n">reference</span><span class="p">)</span> <span class="k">if</span> <span class="n">reference</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">reference</span>
    <span class="n">pxmask</span> <span class="o">=</span> <span class="n">imread</span><span class="p">(</span><span class="n">opts</span><span class="o">.</span><span class="n">pxmask</span><span class="p">)</span> <span class="k">if</span> <span class="n">pxmask</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">pxmask</span>
    
    <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">opts</span><span class="o">.</span><span class="n">correct_saturation</span><span class="p">:</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">apply_saturation_correction</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">opts</span><span class="o">.</span><span class="n">shutter_time</span><span class="p">,</span> <span class="n">opts</span><span class="o">.</span><span class="n">dead_time</span><span class="p">,</span> <span class="n">opts</span><span class="o">.</span><span class="n">dead_time_gap_factor</span><span class="p">)</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">apply_flatfield</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="n">reference</span><span class="p">)</span>
    
    <span class="c1"># here, _always_ choose strategy=&#39;replace&#39;. Interpolation will only be done on the final step</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">correct_dead_pixels</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">pxmask</span><span class="o">=</span><span class="n">pxmask</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s1">&#39;replace&#39;</span><span class="p">,</span> <span class="n">mask_gaps</span><span class="o">=</span><span class="n">opts</span><span class="o">.</span><span class="n">mask_gaps</span><span class="p">)</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">remove_background</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">nPeaks</span><span class="p">,</span> <span class="n">peakXPosRaw</span><span class="p">,</span> <span class="n">peakYPosRaw</span><span class="p">,</span> <span class="n">pxmask</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    
    <span class="c1"># has to be re-done after background correction</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">correct_dead_pixels</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">pxmask</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s1">&#39;interpolate&#39;</span> <span class="k">if</span> <span class="n">opts</span><span class="o">.</span><span class="n">interpolate_dead</span> <span class="k">else</span> <span class="s1">&#39;replace&#39;</span><span class="p">,</span> <span class="n">mask_gaps</span><span class="o">=</span><span class="n">opts</span><span class="o">.</span><span class="n">mask_gaps</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">img</span>


<div class="viewcode-block" id="correct_image"><a class="viewcode-back" href="../../diffractem.proc2d.html#diffractem.proc2d.correct_image">[docs]</a><span class="k">def</span> <span class="nf">correct_image</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">],</span> <span class="n">opts</span><span class="p">:</span> <span class="n">PreProcOpts</span><span class="p">,</span> 
                  <span class="n">x0</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                  <span class="n">y0</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                  <span class="n">peakinfo</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                  <span class="n">reference</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                  <span class="n">pxmask</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Runs correction pipeline on stack of diffraction images (numpy or dask). </span>
<span class="sd">    </span>
<span class="sd">    The correction pipeline comprises flat-field, saturation and dead-pixel correction, as well as </span>
<span class="sd">    background subtraction, optionally including exclusion of diffraction peaks for computation of the</span>
<span class="sd">    background (recommended).</span>
<span class="sd">        </span>
<span class="sd">    Note:</span>
<span class="sd">        This function essentially wraps `proc2d._get_corr_image` with smart features to take care</span>
<span class="sd">        of dask input arrays. If you want to change the </span>
<span class="sd">        correction pipeline, that is the function to modify.</span>

<span class="sd">    Args:</span>
<span class="sd">        img (Union[np.ndarray, da.Array]): Diffraction pattern stack</span>
<span class="sd">        opts (PreProcOpts): Pre-processing options. Options used are: (...)</span>
<span class="sd">        x0 (Union[None, np.ndarray, da.Array, pd.Series], optional): Pattern X centers </span>
<span class="sd">            (None: use image center). Defaults to None.</span>
<span class="sd">        y0 (Union[None, np.ndarray, da.Array, pd.Series], optional): Pattern Y centers </span>
<span class="sd">            (None: use image center). Defaults to None.</span>
<span class="sd">        peakinfo (Union[None, Dict[str, Union[np.ndarray, da.Array]]], optional): Diffraction peak dict </span>
<span class="sd">            in CXI format  (None: no peak exclusion during background subtraction). Defaults to None.</span>
<span class="sd">        reference (Union[None, Union[np.ndarray, str]], optional): Flat-field reference </span>
<span class="sd">            (None: use reference file specified in options). Defaults to None.</span>
<span class="sd">        pxmask (Union[None, Union[np.ndarray, str]], optional): Pixel mask reference </span>
<span class="sd">            (default: use reference file specified in options). Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Union[np.ndarray, da.Array]: Corrected image stack of identical dimension as input stack.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="c1"># take care of numpy image with dask arguments (just in case)</span>
        <span class="n">innerargs</span> <span class="o">=</span> <span class="p">[</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">peakinfo</span><span class="p">[</span><span class="s1">&#39;nPeaks&#39;</span><span class="p">],</span> <span class="n">peakinfo</span><span class="p">[</span><span class="s1">&#39;peakXPosRaw&#39;</span><span class="p">],</span> <span class="n">peakinfo</span><span class="p">[</span><span class="s1">&#39;peakYPosRaw&#39;</span><span class="p">]]</span>
        <span class="n">innerargs</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">)</span> <span class="k">else</span> <span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">innerargs</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">_get_corr_img</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="o">*</span><span class="n">innerargs</span><span class="p">,</span> <span class="n">opts</span><span class="p">,</span> <span class="n">reference</span><span class="p">,</span> <span class="n">pxmask</span><span class="p">)</span>
    
    <span class="n">reference</span> <span class="o">=</span> <span class="n">imread</span><span class="p">(</span><span class="n">opts</span><span class="o">.</span><span class="n">reference</span><span class="p">)</span> <span class="k">if</span> <span class="n">reference</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">reference</span>
    <span class="n">pxmask</span> <span class="o">=</span> <span class="n">imread</span><span class="p">(</span><span class="n">opts</span><span class="o">.</span><span class="n">pxmask</span><span class="p">)</span> <span class="k">if</span> <span class="n">pxmask</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">pxmask</span>
    
    <span class="n">N</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">x0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">y0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">y0</span> <span class="o">=</span> <span class="kc">None</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">):</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">x0</span><span class="o">.</span><span class="n">values</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)</span> <span class="k">else</span> <span class="n">x0</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">y0</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">y0</span><span class="o">.</span><span class="n">values</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)</span> <span class="k">else</span> <span class="n">y0</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    
    <span class="k">if</span> <span class="n">peakinfo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">npk</span> <span class="o">=</span> <span class="n">pkx</span> <span class="o">=</span> <span class="n">pky</span> <span class="o">=</span> <span class="kc">None</span>
        
    <span class="k">else</span><span class="p">:</span>     
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">peakinfo</span><span class="p">[</span><span class="s1">&#39;nPeaks&#39;</span><span class="p">],</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">):</span>
            <span class="n">peakinfo</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;nPeaks&#39;</span><span class="p">:</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">peakinfo</span><span class="p">[</span><span class="s1">&#39;nPeaks&#39;</span><span class="p">],</span> <span class="n">chunks</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                    <span class="s1">&#39;peakXPosRaw&#39;</span><span class="p">:</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">peakinfo</span><span class="p">[</span><span class="s1">&#39;peakXPosRaw&#39;</span><span class="p">],</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">)),</span>
                    <span class="s1">&#39;peakYPosRaw&#39;</span><span class="p">:</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">peakinfo</span><span class="p">[</span><span class="s1">&#39;peakYPosRaw&#39;</span><span class="p">],</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">))}</span>

        <span class="n">npk</span> <span class="o">=</span> <span class="n">peakinfo</span><span class="p">[</span><span class="s1">&#39;nPeaks&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">pkx</span> <span class="o">=</span> <span class="n">peakinfo</span><span class="p">[</span><span class="s1">&#39;peakXPosRaw&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">pky</span> <span class="o">=</span> <span class="n">peakinfo</span><span class="p">[</span><span class="s1">&#39;peakYPosRaw&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="n">da</span><span class="o">.</span><span class="n">map_blocks</span><span class="p">(</span><span class="n">_get_corr_img</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">x0</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)),</span> <span class="n">y0</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)),</span> 
                         <span class="n">npk</span><span class="p">,</span> <span class="n">pkx</span><span class="p">,</span> <span class="n">pky</span><span class="p">,</span> 
                         <span class="n">reference</span><span class="o">=</span><span class="n">reference</span><span class="p">,</span> <span class="n">pxmask</span><span class="o">=</span><span class="n">pxmask</span><span class="p">,</span> <span class="n">opts</span><span class="o">=</span><span class="n">opts</span><span class="p">,</span>
                         <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">chunks</span><span class="p">)</span></div>


<div class="viewcode-block" id="analyze_and_correct"><a class="viewcode-back" href="../../diffractem.proc2d.html#diffractem.proc2d.analyze_and_correct">[docs]</a><span class="k">def</span> <span class="nf">analyze_and_correct</span><span class="p">(</span><span class="n">imgs</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">opts</span><span class="p">:</span> <span class="n">PreProcOpts</span><span class="p">,</span> 
                        <span class="n">correct_non_hits</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                        <span class="n">reference</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                        <span class="n">pxmask</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Analyzes a diffraction pattern (centering and peak finding), and immediately applies a correction.</span>
<span class="sd">    </span>
<span class="sd">    This function combines `get_pattern_info` and `correct_image`, but works differently in that</span>
<span class="sd">    it does not inherently handle any lazy/parallel computations: it only simply loops over a numpy </span>
<span class="sd">    array. It is hence especially useful to check if the preprocessing pipeline works on a small</span>
<span class="sd">    set, or to embed it into dask delayed objects for parallel execution *outside* the function, which </span>
<span class="sd">    may be faster than `get_pattern_info` + `correct_image` (see example below).</span>

<span class="sd">    Args:</span>
<span class="sd">        imgs (np.ndarray): Input image stack as numpy array</span>
<span class="sd">        opts (PreProcOpts): pre-processing options</span>
<span class="sd">        correct_non_hits (bool, optional): Apply correction also to images that do not have </span>
<span class="sd">            sufficient Bragg spots in them (as defined by opts.min_peaks). Defaults to False.</span>
<span class="sd">        reference (Union[None, Union[np.ndarray, str]], optional): Reference image as numpy</span>
<span class="sd">            array or TIF file name. If None, read file defined in options. Defaults to None.</span>
<span class="sd">        pxmask (Union[None, Union[np.ndarray, str]], optional): Pixel mask image as numpy</span>
<span class="sd">            array or TIF file name. If None, read file defined in options. Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple[np.ndarray, dict]: Corrected image stack and pattern info structure, as</span>
<span class="sd">            returned by `correct_image` and `get_pattern_info`, respectively.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">    Example:</span>
<span class="sd">        To run a parallel computation efficiently, use this function like</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; results = [dask.delayed(proc2d.analyze_and_correct)(img_chunk, opts) \</span>
<span class="sd">                    for img_chunk in img_stack.to_delayed().ravel()]</span>
<span class="sd">        &gt;&gt;&gt; dask.compute(results)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">reference</span> <span class="o">=</span> <span class="n">imread</span><span class="p">(</span><span class="n">opts</span><span class="o">.</span><span class="n">reference</span><span class="p">)</span> <span class="k">if</span> <span class="n">reference</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">reference</span>
    <span class="n">pxmask</span> <span class="o">=</span> <span class="n">imread</span><span class="p">(</span><span class="n">opts</span><span class="o">.</span><span class="n">pxmask</span><span class="p">)</span> <span class="k">if</span> <span class="n">pxmask</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">pxmask</span>
    
    <span class="n">info</span> <span class="o">=</span> <span class="n">_generate_pattern_info</span><span class="p">(</span><span class="n">imgs</span><span class="p">,</span> <span class="n">opts</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="n">reference</span><span class="p">,</span> <span class="n">pxmask</span><span class="o">=</span><span class="n">pxmask</span><span class="p">)</span>
    <span class="n">hits</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;num_peaks&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">opts</span><span class="o">.</span><span class="n">min_peaks</span>

    <span class="k">if</span> <span class="n">correct_non_hits</span> <span class="ow">or</span> <span class="nb">all</span><span class="p">(</span><span class="n">hits</span><span class="p">):</span>
        <span class="n">imgs</span> <span class="o">=</span> <span class="n">_get_corr_img</span><span class="p">(</span><span class="n">imgs</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;center_x&#39;</span><span class="p">],</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;center_y&#39;</span><span class="p">],</span> 
                                        <span class="n">info</span><span class="p">[</span><span class="s1">&#39;peak_data&#39;</span><span class="p">][</span><span class="s1">&#39;nPeaks&#39;</span><span class="p">],</span> 
                                        <span class="n">info</span><span class="p">[</span><span class="s1">&#39;peak_data&#39;</span><span class="p">][</span><span class="s1">&#39;peakXPosRaw&#39;</span><span class="p">],</span> 
                                        <span class="n">info</span><span class="p">[</span><span class="s1">&#39;peak_data&#39;</span><span class="p">][</span><span class="s1">&#39;peakYPosRaw&#39;</span><span class="p">],</span> 
                                        <span class="n">opts</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="n">reference</span><span class="p">,</span> <span class="n">pxmask</span><span class="o">=</span><span class="n">pxmask</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">imgs</span> <span class="o">=</span> <span class="n">imgs</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">imgs</span><span class="p">[</span><span class="n">hits</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">_get_corr_img</span><span class="p">(</span><span class="n">imgs</span><span class="p">[</span><span class="n">hits</span><span class="p">,</span><span class="o">...</span><span class="p">],</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;center_x&#39;</span><span class="p">][</span><span class="n">hits</span><span class="p">,</span><span class="o">...</span><span class="p">],</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;center_y&#39;</span><span class="p">][</span><span class="n">hits</span><span class="p">,</span><span class="o">...</span><span class="p">],</span> 
                                          <span class="n">info</span><span class="p">[</span><span class="s1">&#39;peak_data&#39;</span><span class="p">][</span><span class="s1">&#39;nPeaks&#39;</span><span class="p">][</span><span class="n">hits</span><span class="p">,</span><span class="o">...</span><span class="p">],</span> 
                                          <span class="n">info</span><span class="p">[</span><span class="s1">&#39;peak_data&#39;</span><span class="p">][</span><span class="s1">&#39;peakXPosRaw&#39;</span><span class="p">][</span><span class="n">hits</span><span class="p">,</span><span class="o">...</span><span class="p">],</span> 
                                          <span class="n">info</span><span class="p">[</span><span class="s1">&#39;peak_data&#39;</span><span class="p">][</span><span class="s1">&#39;peakYPosRaw&#39;</span><span class="p">][</span><span class="n">hits</span><span class="p">,</span><span class="o">...</span><span class="p">],</span> 
                                          <span class="n">opts</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="n">reference</span><span class="p">,</span> <span class="n">pxmask</span><span class="o">=</span><span class="n">pxmask</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">imgs</span><span class="p">,</span> <span class="n">info</span></div>


<span class="c1">#TODO: this might not really belong here -&gt; move to some tools module? Or make private?</span>
<div class="viewcode-block" id="mean_clip"><a class="viewcode-back" href="../../diffractem.proc2d.html#diffractem.proc2d.mean_clip">[docs]</a><span class="k">def</span> <span class="nf">mean_clip</span><span class="p">(</span><span class="n">c</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Iteratively keeps only the values from the array that satisfies</span>
<span class="sd">        0 &lt; c &lt; c_mean + sigma*std </span>
<span class="sd">        and return the mean of the array. Assumes the</span>
<span class="sd">        array contains positive entries, </span>
<span class="sd">        if it does not or the array is empty returns -1 </span>

<span class="sd">    Args:</span>
<span class="sd">        c (np.ndarray): input value array</span>
<span class="sd">        sigma (float, optional): number of standard deviations away from the mean </span>
<span class="sd">            that is used for mean calculation. Defaults to 2.0.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: Mean of clipped values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">c</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">c</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">while</span> <span class="n">delta</span><span class="p">:</span>
        <span class="n">c_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">size</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">c</span> <span class="o">&lt;</span> <span class="n">c_mean</span> <span class="o">+</span> <span class="n">sigma</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">c_mean</span><span class="p">)]</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">size</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">size</span>
    <span class="k">return</span> <span class="n">c_mean</span></div>


<span class="c1">#TODO: as before</span>
<div class="viewcode-block" id="func_lorentz"><a class="viewcode-back" href="../../diffractem.proc2d.html#diffractem.proc2d.func_lorentz">[docs]</a><span class="k">def</span> <span class="nf">func_lorentz</span><span class="p">(</span><span class="n">p</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> 
                 <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> 
                 <span class="n">y</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Function that returns a Student&#39;t distribution or generalised Cauchy</span>
<span class="sd">    distribution in Two Dimensions(x,y):</span>
<span class="sd">    </span>
<span class="sd">    amp * [(1 + ((x-x_0)/scale)**2) + (1 + ((y-y_0)/scale)**2)] ** (-shape/2)</span>

<span class="sd">    Args:</span>
<span class="sd">        p (Union[list, tuple, np.ndarray]): Parameter array: [amp, x_0, y_0, scale, shape]</span>
<span class="sd">        x (Union[float, np.ndarray]): x coordinate(s)</span>
<span class="sd">        y (Union[float, np.ndarray]): y coordinate(s)</span>

<span class="sd">    Returns:</span>
<span class="sd">        Union[float, np.ndarray]: function value at (x, y)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">((</span><span class="mi">1</span><span class="o">+</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">**</span><span class="mf">2.0</span> <span class="o">+</span> <span class="p">((</span><span class="n">y</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">/</span><span class="mf">2.0</span><span class="p">))</span></div>


<div class="viewcode-block" id="lorentz_fit"><a class="viewcode-back" href="../../diffractem.proc2d.html#diffractem.proc2d.lorentz_fit">[docs]</a><span class="nd">@loop_over_stack</span>
<span class="k">def</span> <span class="nf">lorentz_fit</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">amp</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> 
                <span class="n">x_0</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y_0</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> 
                <span class="n">scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">5.0</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span>
                <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>    
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fits a Lorentz profile to find the center (x_0, y_0) of a diffraction</span>
<span class="sd">    pattern, ignoring any pixels with values &lt; threshold.</span>
<span class="sd">    </span>
<span class="sd">    The fit function is based on:</span>

<span class="sd">    amp * [(1 + ((x-x_0)/scale)**2) + (1 + ((y-y_0)/scale)**2)] ** (-shape/2)</span>
<span class="sd">    </span>
<span class="sd">    Build upon optimize.least_squares function  which is thread safe</span>
<span class="sd">    Note: least.sq is not. Analytical Jacobian has been added.</span>
<span class="sd">    </span>
<span class="sd">    Note:</span>
<span class="sd">        If possible (i.e. you leave shape at 2.0), do **not** use this function, </span>
<span class="sd">        it&#39;s really slow. Instead use `lorentz_fast`.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        see fit function above</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        OptimizeResult: result of optimization</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">param</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">amp</span><span class="p">,</span><span class="n">x_0</span><span class="p">,</span><span class="n">y_0</span><span class="p">,</span><span class="n">scale</span><span class="p">,</span> <span class="n">shape</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">jac_lorentz</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
        <span class="n">radius</span> <span class="o">=</span> <span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">**</span><span class="mf">2.0</span> <span class="o">+</span> <span class="p">((</span><span class="n">y</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">**</span><span class="mf">2.0</span>
        <span class="n">func</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span><span class="o">+</span><span class="n">radius</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">/</span><span class="mf">2.0</span><span class="o">-</span><span class="mf">1.0</span><span class="p">))</span>
        <span class="n">d_amp</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span><span class="o">+</span><span class="n">radius</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">/</span><span class="mf">2.0</span><span class="p">))</span> 
        <span class="n">d_x0</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">*</span><span class="n">func</span>
        <span class="n">d_y0</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">*</span><span class="n">func</span>
        <span class="n">d_scale</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">/</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">radius</span><span class="o">*</span><span class="n">func</span>
        <span class="n">d_shape</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">((</span><span class="mi">1</span><span class="o">+</span><span class="n">radius</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">/</span><span class="mf">2.0</span><span class="p">))</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">radius</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="n">d_amp</span><span class="p">,</span> <span class="n">d_x0</span><span class="p">,</span><span class="n">d_y0</span><span class="p">,</span> <span class="n">d_scale</span><span class="p">,</span> <span class="n">d_shape</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">img</span><span class="o">**</span><span class="mf">0.5</span><span class="p">))</span>   
    <span class="k">def</span> <span class="nf">func_error</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">func_lorentz</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">cut</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">cut</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="n">img</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">img</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">cut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">img</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">least_squares</span><span class="p">(</span><span class="n">func_error</span><span class="p">,</span><span class="n">param</span><span class="p">,</span><span class="n">jac_lorentz</span><span class="p">,</span><span class="n">loss</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span>
                                 <span class="n">max_nfev</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span><span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">cut</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">cut</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">img</span><span class="p">[</span><span class="n">cut</span><span class="p">]),</span>
                                 <span class="n">bounds</span><span class="o">=</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="lorentz_fast"><a class="viewcode-back" href="../../diffractem.proc2d.html#diffractem.proc2d.lorentz_fast">[docs]</a><span class="nd">@loop_over_stack</span>
<span class="k">def</span> <span class="nf">lorentz_fast</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">x_0</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">y_0</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">amp</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                 <span class="n">scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">5.0</span><span class="p">,</span> <span class="n">radius</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">limit</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">threshold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">threads</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Fast Lorentzian fit for finding beam center; especially suited for refinement after a reasonable estimate</span>
<span class="sd">    (i.e. to a couple of pixels) has been made by another method such as truncated COM.</span>
<span class="sd">    Compared to the other fits, it always assumes a shape parameter 2 (i.e. standard Lorentzian with asymptotic x^-2).</span>
<span class="sd">    It can restrict the fit to only a small region around the initial value for the beam center, which massively speeds</span>
<span class="sd">    up the function. Also, it auto-estimates the intial parameters somewhat reasonably if nothing else is given.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        img (float): input image or image stack. If a stack is supplied, it is serially looped. Not accepting dask directly.</span>
<span class="sd">        x_0 (float, optional): estimated x beam center. If None, is assumed to be in the center of the image. Defaults to None.</span>
<span class="sd">        y_0 (float, optional): analogous. Defaults to None.</span>
<span class="sd">        amp (float, optional): estimated peak amplitude. If None, is set to the 99.99% percentile of img. Defaults to None.</span>
<span class="sd">        scale (float, optional): peak HWHM estimate in pixels. Defaults to 5.0.</span>
<span class="sd">        radius (float, optional): radius of a box around x_0, y_0 where the fit is actually done. If None, the entire image is used. Defaults to None.</span>
<span class="sd">        limit (float, optional): If not None, the fit result is discarded if the found beam_center is further away than this value from</span>
<span class="sd">            the initial estimate. Defaults to None.</span>
<span class="sd">        threshold (int, optional): pixel value threshold below which pixels are ignored. Defaults to 0.</span>
<span class="sd">        threads (bool, optional): if True, uses scipy.optimize.least_squares, which for larger arrays (radius more than around 15)</span>
<span class="sd">            uses multithreaded function evaluation. Especially for radius &lt; 50, this may be slower than single-threaded.</span>
<span class="sd">            In this case, best set to False. Defaults to False.</span>
<span class="sd">        verbose (bool, optional): if True, a message is printed on some occasions. Defaults to False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: numpy array of refined parameters [amp, x0, y0, scale]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x_0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">x_0</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x_0</span><span class="p">):</span>
        <span class="n">x_0</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">y_0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_0</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">y_0</span><span class="p">):</span>
        <span class="n">y_0</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">radius</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x_0</span> <span class="o">-</span> <span class="n">radius</span><span class="p">)</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x_0</span> <span class="o">+</span> <span class="n">radius</span><span class="p">)</span>
            <span class="n">y1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">y_0</span> <span class="o">-</span> <span class="n">radius</span><span class="p">)</span>
            <span class="n">y2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">y_0</span> <span class="o">+</span> <span class="n">radius</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Weird:&#39;</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">radius</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">err</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">x1</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">x2</span> <span class="o">&gt;</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="n">y1</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">y2</span> <span class="o">&gt;</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Cannot cut image around peak. Centering.&#39;</span><span class="p">)</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">radius</span><span class="p">)</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">radius</span><span class="p">)</span>
            <span class="n">y1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">radius</span><span class="p">)</span>
            <span class="n">y2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">radius</span><span class="p">)</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="p">[</span><span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">y1</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">amp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="mi">99</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Something weird: </span><span class="si">{}</span><span class="s1"> Cannot get image percentile. Img size is </span><span class="si">{}</span><span class="s1">. Skipping.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">x_0</span><span class="p">,</span> <span class="n">y_0</span><span class="p">,</span> <span class="n">scale</span><span class="p">])</span>

    <span class="n">cut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">img</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">cut</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">x1</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">cut</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">y1</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="p">[</span><span class="n">cut</span><span class="p">]</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="n">img</span> <span class="o">**</span> <span class="mf">0.5</span>

    <span class="n">function</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">**</span> <span class="mf">2.0</span> <span class="o">+</span> <span class="p">((</span><span class="n">y</span> <span class="o">-</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">**</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">error</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="p">(</span><span class="n">function</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">-</span> <span class="n">img</span><span class="p">)</span> <span class="o">/</span> <span class="n">norm</span>

    <span class="c1"># The Jacobian is not used anymore, but let&#39;s keep it here, just in case</span>
    <span class="k">def</span> <span class="nf">jacobian</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
        <span class="n">radius</span> <span class="o">=</span> <span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">**</span> <span class="mf">2.0</span> <span class="o">+</span> <span class="p">((</span><span class="n">y</span> <span class="o">-</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">**</span> <span class="mf">2.0</span>
        <span class="n">func</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="n">radius</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mf">2.0</span><span class="p">))</span>
        <span class="n">d_amp</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="n">radius</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">))</span>
        <span class="n">d_x0</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">**</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">func</span>
        <span class="n">d_y0</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">**</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">func</span>
        <span class="n">d_scale</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">func</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">d_amp</span> <span class="o">/</span> <span class="n">norm</span><span class="p">,</span> <span class="n">d_x0</span> <span class="o">/</span> <span class="n">norm</span><span class="p">,</span> <span class="n">d_y0</span> <span class="o">/</span> <span class="n">norm</span><span class="p">,</span> <span class="n">d_scale</span> <span class="o">/</span> <span class="n">norm</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="n">param</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">amp</span><span class="p">,</span> <span class="n">x_0</span><span class="p">,</span> <span class="n">y_0</span><span class="p">,</span> <span class="n">scale</span><span class="p">])</span>
    <span class="c1"># print(param)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">threads</span><span class="p">:</span>
            <span class="c1"># new algorithm: uses multithreaded evaluation sometimes, which is not always desired!</span>
            <span class="c1"># out = optimize.least_squares(error, param, jac=jacobian, loss=&#39;linear&#39;,</span>
            <span class="c1">#                             max_nfev=1000, method=&#39;lm&#39;, verbose=0,</span>
            <span class="c1">#                             x_scale=(amp, 1, 1, 5)).x</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">least_squares</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">loss</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span>
                                        <span class="n">max_nfev</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;lm&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                        <span class="n">x_scale</span><span class="o">=</span><span class="p">(</span><span class="n">amp</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span><span class="n">xtol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">)</span><span class="o">.</span><span class="n">x</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># old algorithm never uses multithreading. May be better.</span>
            <span class="c1"># out = optimize.leastsq(error, param, Dfun=jacobian)[0]</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">leastsq</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">xtol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
        <span class="c1"># print(param)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Fitting did not work: </span><span class="si">{}</span><span class="s1"> with initial parameters </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">param</span><span class="p">))</span>
        <span class="c1"># raise err</span>
        <span class="k">return</span> <span class="n">param</span>

    <span class="n">change</span> <span class="o">=</span> <span class="n">out</span> <span class="o">-</span> <span class="n">param</span>
    <span class="k">if</span> <span class="n">limit</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">change</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">limit</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Found out of limit fit result </span><span class="si">{}</span><span class="s1">. Reverting to init values </span><span class="si">{}</span><span class="s1">.&#39;</span> \
                  <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="n">param</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]))</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">param</span>

    <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="center_of_mass"><a class="viewcode-back" href="../../diffractem.proc2d.html#diffractem.proc2d.center_of_mass">[docs]</a><span class="nd">@loop_over_stack</span>
<span class="k">def</span> <span class="nf">center_of_mass</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the center of mass of an image using all the pixels larger than </span>
<span class="sd">    the threshold. Automatically skips values below threshold. Fast for sparse </span>
<span class="sd">    images, for more crowded ones `center_of_mass2` may be faster.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        img (np.ndarray): Input image</span>
<span class="sd">        threshold (float, optional): minimum pixel value to include. Defaults to 0.0.</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: [x0, y0] -&gt; image center of mass</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">img</span><span class="o">&gt;</span><span class="n">threshold</span><span class="p">)</span>
    <span class="p">(</span><span class="n">y0</span><span class="p">,</span><span class="n">x0</span><span class="p">)</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">img</span><span class="p">[</span><span class="n">cut</span><span class="p">]</span><span class="o">*</span><span class="n">cut</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">img</span><span class="p">[</span><span class="n">cut</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x0</span><span class="p">,</span><span class="n">y0</span><span class="p">])</span></div>


<div class="viewcode-block" id="center_of_mass2"><a class="viewcode-back" href="../../diffractem.proc2d.html#diffractem.proc2d.center_of_mass2">[docs]</a><span class="k">def</span> <span class="nf">center_of_mass2</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">threshold</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the center of mass of an image using all the pixels larger than </span>
<span class="sd">    the threshold. Automatically skips values below threshold. Can be faster</span>
<span class="sd">    than `center_of_mass` for crowded images (just try it out).</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        img (np.ndarray): Input image</span>
<span class="sd">        threshold (float, optional): minimum pixel value to include. If None,</span>
<span class="sd">            does not apply a threshold. Defaults to None.</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: [x0, y0] -&gt; image center of mass</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> 
                               <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">imgt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">img</span> <span class="o">&gt;=</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">imgt</span> <span class="o">=</span> <span class="n">img</span>

    <span class="n">com</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">imgt</span><span class="p">,</span> <span class="n">vec</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="o">/</span><span class="n">imgt</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">com</span></div>


<div class="viewcode-block" id="apply_virtual_detector"><a class="viewcode-back" href="../../diffractem.proc2d.html#diffractem.proc2d.apply_virtual_detector">[docs]</a><span class="nd">@loop_over_stack</span>
<span class="k">def</span> <span class="nf">apply_virtual_detector</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">r_inner</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">r_outer</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> 
                           <span class="n">x0</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">y0</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply a &quot;virtual STEM detector&quot; to stack, with given inner and outer radii. Returns the mean value of all pixels</span>
<span class="sd">    that fall inside this annulus.</span>

<span class="sd">    Args:</span>
<span class="sd">        img (np.ndarray): input image (or stack thereof)</span>
<span class="sd">        r_inner (float): Inner radius</span>
<span class="sd">        r_outer (float): Outer radius</span>
<span class="sd">        x0 (float): Beam center position along x. If None, assumes center of image. Defaults to None. Should follow</span>
<span class="sd">            CXI convention, i.e. relative to pixel center, not corner.</span>
<span class="sd">        y0 (float): Similar for y</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: mean value of pixels inside the annulus defined by r_inner and r_outer</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ysize</span><span class="p">,</span> <span class="n">xsize</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="n">xsize</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="k">if</span> <span class="n">x0</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">x0</span>
    <span class="n">y0</span> <span class="o">=</span> <span class="n">ysize</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="k">if</span> <span class="n">y0</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">y0</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">xsize</span><span class="p">)</span> <span class="o">-</span> <span class="n">x0</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ysize</span><span class="p">)</span> <span class="o">-</span> <span class="n">y0</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">X</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">Y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="c1"># print(r_inner, r_outer)</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="p">((</span><span class="n">R</span> <span class="o">&lt;</span> <span class="n">r_outer</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">R</span> <span class="o">&gt;=</span> <span class="n">r_inner</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">((</span><span class="n">img</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">img</span><span class="p">))</span>
    <span class="c1"># print(mask.sum())</span>
    
    <span class="k">return</span> <span class="n">img</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span></div>


<div class="viewcode-block" id="get_peaks"><a class="viewcode-back" href="../../diffractem.proc2d.html#diffractem.proc2d.get_peaks">[docs]</a><span class="nd">@loop_over_stack</span>
<span class="k">def</span> <span class="nf">get_peaks</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">x0</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">y0</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">max_peaks</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span> 
              <span class="n">pxmask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">min_snr</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">4.</span><span class="p">,</span> <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
              <span class="n">min_pix_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">max_pix_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="n">local_bg_radius</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
              <span class="n">min_res</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">max_res</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span> <span class="n">as_dict</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Find peaks in diffraction pattern using the peakfinder8 algorithm as used in</span>
<span class="sd">    CrystFEL, OnDA and Cheetah. For explanation of the finding parameters, please consult the </span>
<span class="sd">    CrystFEL documentation (or just run `man indexamajig`).</span>

<span class="sd">    Args:</span>
<span class="sd">        img (np.ndarray): image stack</span>
<span class="sd">        x0 (float): image stack x center</span>
<span class="sd">        y0 (float): image stack y center</span>
<span class="sd">        max_peaks (int, optional): maximum number of peaks. Defaults to 500.</span>
<span class="sd">        pxmask (Optional[np.ndarray], optional): pixel mask. Defaults to None.</span>
<span class="sd">        min_snr (float, optional): minimum peak SNR. Defaults to 4..</span>
<span class="sd">        threshold (float, optional): count threshold. Defaults to 8.</span>
<span class="sd">        min_pix_count (int, optional): minimum number of pixels in peak. Defaults to 2.</span>
<span class="sd">        max_pix_count (int, optional): maximum number of pixels in peak. Defaults to 20.</span>
<span class="sd">        local_bg_radius (int, optional): radius for peak backgroud estimation. Defaults to 3.</span>
<span class="sd">        min_res (int, optional): minimum resolution (= radial range) in pixels. Defaults to 0.</span>
<span class="sd">        max_res (int, optional): maximum resolution (= radial range) in pixels. Defaults to 500.</span>
<span class="sd">        as_dict (bool, optional): return results as a dictionary instead of a </span>
<span class="sd">            single numpy array. Defaults to True.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: CXI-format peaks information. If as_dict=False, instead returns a 1d array</span>
<span class="sd">            of size (3 * max_peaks + 1), which contains x positions, y positions, intensities,</span>
<span class="sd">            and number of peaks concatenated.</span>
<span class="sd">            </span>
<span class="sd">    Note:</span>
<span class="sd">        The returned peak positions follow CXI convention, that is, they refer to pixel *centers*,</span>
<span class="sd">        not corners (as in `CrystFEL`). For `CrystFEL`-convention you have to add 0.5 to the</span>
<span class="sd">        returned peak positions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="kn">from</span> <span class="nn">onda.algorithms.crystallography_algorithms</span> <span class="kn">import</span> <span class="n">Peakfinder8PeakDetection</span>

    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">range</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">R</span> <span class="o">=</span> <span class="p">(((</span><span class="n">X</span><span class="o">-</span><span class="n">x0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">Y</span><span class="o">-</span><span class="n">y0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    
    <span class="n">pf</span> <span class="o">=</span> <span class="n">Peakfinder8PeakDetection</span><span class="p">(</span><span class="n">max_num_peaks</span><span class="o">=</span><span class="n">max_peaks</span><span class="p">,</span>
                              <span class="n">asic_nx</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">asic_ny</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                              <span class="n">nasics_x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nasics_y</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                              <span class="n">adc_threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span> <span class="n">minimum_snr</span><span class="o">=</span><span class="n">min_snr</span><span class="p">,</span>
                              <span class="n">min_pixel_count</span><span class="o">=</span><span class="n">min_pix_count</span><span class="p">,</span> <span class="n">max_pixel_count</span><span class="o">=</span><span class="n">max_pix_count</span><span class="p">,</span>
                              <span class="n">local_bg_radius</span><span class="o">=</span><span class="n">local_bg_radius</span><span class="p">,</span>
                              <span class="n">min_res</span><span class="o">=</span><span class="n">min_res</span><span class="p">,</span> <span class="n">max_res</span><span class="o">=</span><span class="n">max_res</span><span class="p">,</span>
                              <span class="n">bad_pixel_map_filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">bad_pixel_map_hdf5_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">radius_pixel_map</span><span class="o">=</span><span class="n">R</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">pxmask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pf</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">pxmask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>

    <span class="n">pks</span> <span class="o">=</span> <span class="n">pf</span><span class="o">.</span><span class="n">find_peaks</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
    <span class="n">fill</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">max_peaks</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">pks</span><span class="o">.</span><span class="n">fs</span><span class="p">))</span>
    
    <span class="k">if</span> <span class="n">as_dict</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;peakXPosRaw&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pks</span><span class="o">.</span><span class="n">fs</span> <span class="o">+</span> <span class="n">fill</span><span class="p">),</span>
                <span class="s1">&#39;peakYPosRaw&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pks</span><span class="o">.</span><span class="n">ss</span> <span class="o">+</span> <span class="n">fill</span><span class="p">),</span>
                <span class="s1">&#39;peakTotalIntensity&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pks</span><span class="o">.</span><span class="n">intensity</span> <span class="o">+</span> <span class="n">fill</span><span class="p">),</span>
                <span class="s1">&#39;nPeaks&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pks</span><span class="o">.</span><span class="n">fs</span><span class="p">))}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pks</span><span class="o">.</span><span class="n">fs</span> <span class="o">+</span> <span class="n">fill</span> <span class="o">+</span> <span class="n">pks</span><span class="o">.</span><span class="n">ss</span> <span class="o">+</span> <span class="n">fill</span> <span class="o">+</span> <span class="n">pks</span><span class="o">.</span><span class="n">intensity</span> <span class="o">+</span> <span class="n">fill</span> <span class="o">+</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">pks</span><span class="o">.</span><span class="n">fs</span><span class="p">)])</span></div>


<div class="viewcode-block" id="radial_proj"><a class="viewcode-back" href="../../diffractem.proc2d.html#diffractem.proc2d.radial_proj">[docs]</a><span class="nd">@loop_over_stack</span>
<span class="k">def</span> <span class="nf">radial_proj</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">x0</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">y0</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                <span class="n">scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">scale_axis</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">my_func</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">,</span> 
    <span class="n">min_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">600</span><span class="p">,</span> <span class="n">max_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">850</span><span class="p">,</span> <span class="n">filter_len</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Applies a function to azimuthal bins of the image around </span>
<span class="sd">    the center (x0, y0) for each integer radius and returns the result </span>
<span class="sd">    in a np.array of size max_size, yielding a radial profile. Skips values that are set to -1 or nan.</span>
<span class="sd">    </span>
<span class="sd">    Optionally, a median filter can be applied to the output.</span>

<span class="sd">    Args:</span>
<span class="sd">        img (np.ndarray): input image or stack</span>
<span class="sd">        x0 (Optional[float], optional): x center of pattern. Center of image is None. Defaults to None.</span>
<span class="sd">        y0 (Optional[float], optional): y center of pattern. Center of image is None. . Defaults to None.</span>
<span class="sd">        my_func (Union[Callable[[np.ndarray], np.ndarray], List[Callable[[np.ndarray], np.ndarray]]], optional): function</span>
<span class="sd">            to call on all pixel values at a given radius, or iterable thereof. Defaults to np.nanmean.</span>
<span class="sd">        min_size (int, optional): Minimum length of the output profile. Defaults to 600.</span>
<span class="sd">        max_size (int, optional): Maximum length of the output profile. Defaults to 850.</span>
<span class="sd">        filter_len (int, optional): Kernel size of median filter applied after profile calculation.</span>
<span class="sd">        filter_len must be odd, and filtering is at the moment incompatible with multiple functions. Defaults to 1.</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: radial profile calculated using my_func</span>
<span class="sd">        </span>
<span class="sd">    Note:</span>
<span class="sd">        The median filter will currently only work, if a single function is used only! Sorry for that.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#TODO ellipticity correction?</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">my_func</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">my_func</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">filter_len</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;radial_proj with filtering only works if a single function is used. Sorry.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">filter_len</span><span class="o">//</span><span class="mi">2</span> <span class="o">==</span> <span class="n">filter_len</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;filter_len must be odd.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">my_func</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">my_func</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">my_func</span> <span class="o">=</span> <span class="p">[</span><span class="n">my_func</span><span class="p">]</span>

    <span class="p">(</span><span class="n">ylen</span><span class="p">,</span><span class="n">xlen</span><span class="p">)</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span>
    <span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ogrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">ylen</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">xlen</span><span class="p">]</span>
    <span class="c1">#print(x0,y0)</span>

    <span class="n">x0</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="k">if</span> <span class="n">x0</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
    <span class="n">y0</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="k">if</span> <span class="n">y0</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">y0</span><span class="p">)</span>

    <span class="c1"># fault tolerance if absurd centers are supplied</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">y0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">x0</span><span class="o">&lt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">x0</span><span class="o">&gt;=</span><span class="n">xlen</span> <span class="ow">or</span> <span class="n">y0</span><span class="o">&lt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">y0</span><span class="o">&gt;=</span><span class="n">ylen</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">max_size</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">my_func</span><span class="p">))</span>
        <span class="n">result</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
    
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="n">y0</span>
    
    <span class="c1"># ellipticity correction</span>
    <span class="k">if</span> <span class="n">scale</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">scale_axis</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">scale_axis</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">scale</span><span class="o">*</span><span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="n">s</span><span class="o">*</span><span class="n">y</span><span class="p">),</span> <span class="n">s</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">c</span><span class="o">*</span><span class="n">y</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">c</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">s</span><span class="o">*</span><span class="n">y</span><span class="p">,</span> <span class="o">-</span><span class="n">s</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">c</span><span class="o">*</span><span class="n">y</span>

    <span class="n">radius</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">((</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span> <span class="c1"># radius coordinate of each pixel</span>
                <span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">))</span>
    
    <span class="n">center</span> <span class="o">=</span> <span class="n">img</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">y0</span><span class="p">)),</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">x0</span><span class="p">))]</span>
    <span class="n">radius</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">img</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">img</span><span class="p">))]</span><span class="o">=</span><span class="mi">0</span> <span class="c1"># ignore bad pixels by setting radius to zero</span>
    <span class="n">row</span> <span class="o">=</span> <span class="n">radius</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">))</span>
    <span class="n">mat</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">img</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)))</span>

    <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="mi">1</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">radius</span><span class="p">),</span> <span class="n">max_size</span><span class="p">])</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">rng</span><span class="p">,</span> <span class="n">min_size</span><span class="p">])</span>
    <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">size</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">my_func</span><span class="p">))</span>
    <span class="n">fstart</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">my_func</span><span class="p">),</span> <span class="n">size</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">rng</span><span class="p">):</span>
        <span class="n">rbin_data</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>

        <span class="k">if</span> <span class="n">rbin_data</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="n">r</span> <span class="o">+</span> <span class="n">fstart</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">fn</span><span class="p">(</span><span class="n">rbin_data</span><span class="p">)</span> <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">my_func</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">center</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">result</span><span class="p">[</span><span class="n">fstart</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">fn</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>  <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">my_func</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">filter_len</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>       
        <span class="n">result</span><span class="p">[</span><span class="n">filter_len</span><span class="o">//</span><span class="mi">2</span><span class="p">:]</span> <span class="o">=</span> <span class="n">median_filter</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">filter_len</span><span class="p">)[</span><span class="n">filter_len</span><span class="o">//</span><span class="mi">2</span><span class="p">:]</span>

    <span class="k">assert</span> <span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">min_size</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">max_size</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="cut_peaks"><a class="viewcode-back" href="../../diffractem.proc2d.html#diffractem.proc2d.cut_peaks">[docs]</a><span class="nd">@loop_over_stack</span>
<span class="k">def</span> <span class="nf">cut_peaks</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">nPeaks</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">peakXPosRaw</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
              <span class="n">peakYPosRaw</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">radius</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">replaceval</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Cuts peaks out of an image and replaces them with replaceval. Peak positions are provided in CXI format.</span>

<span class="sd">    This function is mainly interesting for calculation of radial profiles, ignoring Bragg peaks.</span>

<span class="sd">    Args:</span>
<span class="sd">        img (np.ndarray): Input image (or stack thereof)</span>
<span class="sd">        nPeaks (np.ndarray): number of peaks</span>
<span class="sd">        peakXPosRaw (np.ndarray): peak X positions</span>
<span class="sd">        peakYPosRaw (np.ndarray): peak y positions</span>
<span class="sd">        radius (int, optional): Radius of circle within which image values are replaced around each peak. </span>
<span class="sd">            Defaults to 2.</span>
<span class="sd">        replaceval (Union[int, float, None], optional): Value to paint into the circles. If None,</span>
<span class="sd">            uses -1 on integer images and np.nan otherwise. Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: Image with cut-out peaks.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#print(nPeaks)</span>
    <span class="k">if</span> <span class="n">replaceval</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">replaceval</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">nPeaks</span> <span class="o">=</span> <span class="n">nPeaks</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="n">peakXPosRaw</span> <span class="o">=</span> <span class="n">peakXPosRaw</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="n">peakYPosRaw</span> <span class="o">=</span> <span class="n">peakYPosRaw</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="c1">#print(peakYPosRaw[:nPeaks.squeeze()])</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">img</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
    <span class="c1">#print(img.shape)</span>
    <span class="n">mask</span><span class="p">[(</span><span class="n">peakYPosRaw</span><span class="p">[:</span><span class="n">nPeaks</span><span class="p">])</span><span class="o">.</span><span class="n">round</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="n">peakXPosRaw</span><span class="p">[:</span><span class="n">nPeaks</span><span class="p">])</span><span class="o">.</span><span class="n">round</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">binary_dilation</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span><span class="n">disk</span><span class="p">(</span><span class="n">radius</span><span class="p">),</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">img_nopeaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span><span class="n">replaceval</span><span class="p">,</span><span class="n">img</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">img_nopeaks</span></div>


<div class="viewcode-block" id="strip_img"><a class="viewcode-back" href="../../diffractem.proc2d.html#diffractem.proc2d.strip_img">[docs]</a><span class="nd">@loop_over_stack</span>
<span class="k">def</span> <span class="nf">strip_img</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">prof</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
              <span class="n">x0</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">y0</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
              <span class="n">pxmask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">truncate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
              <span class="n">offset</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">keep_edge_offset</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
              <span class="n">replaceval</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">interp</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> 
              <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Subtract a radial profile from a diffraction pattern, assuming radial symmetry of the background.</span>

<span class="sd">    Args:</span>
<span class="sd">        img (np.ndarray): Input image (or stack thereof)</span>
<span class="sd">        prof (np.ndarray): Radial profile to be subtracted</span>
<span class="sd">        x0 (float, optional): Diffraction pattern center along x. If None, use the image center.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        y0 (float, optional): Diffraction pattern center along y. If None, use the image center.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        pxmask (Optional[np.ndarray], optional): Pixel mask to apply *after* subtraction. Defaults to None.</span>
<span class="sd">        truncate (bool, optional): Replace all values below the offset by replaceval. Defaults to False.</span>
<span class="sd">        offset (Union[float, int], optional): Offset to apply to the output image. Required if</span>
<span class="sd">            you want to keep positive pixel values. Defaults to 0.</span>
<span class="sd">        keep_edge_offset (bool, optional): [description]. Defaults to False.</span>
<span class="sd">        replaceval (Optional[float], optional): Replace value for pixels falling below offset. </span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        interp (bool, optional): Interpolate background pixel values, otherwise use nearest</span>
<span class="sd">            neighbour. Defaults to True.</span>
<span class="sd">        dtype (Optional[np.dtype], optional): If not None, convert output</span>
<span class="sd">            image to this data type. Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: Image with subtracted radial profile.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#TODO ellipticity correction?</span>
    
    <span class="n">x0</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="k">if</span> <span class="n">x0</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
    <span class="n">y0</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="k">if</span> <span class="n">y0</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">y0</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">y0</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="n">prof</span> <span class="o">=</span> <span class="n">prof</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>   <span class="c1"># background profile</span>
    <span class="n">ylen</span><span class="p">,</span><span class="n">xlen</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">y</span><span class="p">,</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ogrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">ylen</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">xlen</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">interpolate</span><span class="p">:</span>
        <span class="n">iprof</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">prof</span><span class="p">)),</span> <span class="n">prof</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">radius</span> <span class="o">=</span> <span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">x0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">y0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
        <span class="n">profile</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">radius</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">))</span>
        <span class="n">bkg</span> <span class="o">=</span> <span class="n">iprof</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">radius</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(((</span><span class="n">x</span><span class="o">-</span><span class="n">x0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">y0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">profile</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">radius</span><span class="p">))</span>
        <span class="n">comlen</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">profile</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">prof</span><span class="p">))</span>
        <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">profile</span><span class="p">[:</span><span class="n">comlen</span><span class="p">],</span> <span class="n">prof</span><span class="p">[:</span><span class="n">comlen</span><span class="p">])</span>
        <span class="n">bkg</span> <span class="o">=</span> <span class="n">profile</span><span class="p">[</span><span class="n">radius</span><span class="p">]</span>

    <span class="n">img_out</span> <span class="o">=</span> <span class="n">img</span> <span class="o">-</span> <span class="n">bkg</span> <span class="o">+</span> <span class="n">offset</span> <span class="k">if</span> <span class="n">keep_edge_offset</span> <span class="k">else</span> <span class="n">img</span> <span class="o">-</span> <span class="n">bkg</span>

    <span class="n">dtype</span> <span class="o">=</span> <span class="n">img_out</span><span class="o">.</span><span class="n">dtype</span> <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">dtype</span>

    <span class="k">if</span> <span class="n">replaceval</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">replaceval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">)</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">if</span> <span class="n">truncate</span><span class="p">:</span>
        <span class="n">img_out</span><span class="p">[</span><span class="n">img_out</span> <span class="o">&lt;</span> <span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">replaceval</span>

    <span class="k">if</span> <span class="n">pxmask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">img_out</span> <span class="o">=</span> <span class="n">correct_dead_pixels</span><span class="p">(</span><span class="n">img_out</span><span class="p">,</span> <span class="n">pxmask</span><span class="p">,</span> <span class="s1">&#39;replace&#39;</span><span class="p">,</span> 
                                      <span class="n">replace_val</span><span class="o">=</span><span class="n">replaceval</span><span class="p">,</span> <span class="n">mask_gaps</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">img_out</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
            <span class="n">img_out</span> <span class="o">=</span> <span class="n">img_out</span><span class="o">.</span><span class="n">round</span><span class="p">()</span>
        <span class="n">img_out</span> <span class="o">=</span> <span class="n">img_out</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">img_out</span></div>


<div class="viewcode-block" id="remove_background"><a class="viewcode-back" href="../../diffractem.proc2d.html#diffractem.proc2d.remove_background">[docs]</a><span class="nd">@loop_over_stack</span>
<span class="k">def</span> <span class="nf">remove_background</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">x0</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">y0</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">nPeaks</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">peakXPosRaw</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">peakYPosRaw</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
    <span class="n">peak_radius</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">filter_len</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">rfunc</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">,</span>
    <span class="n">pxmask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">truncate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>  <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Combines `radial_proj`, `cut_peaks` and `strip_img` into a background-removal protocol for diffration</span>
<span class="sd">    patterns, assuming radial symmetry of the background.</span>
<span class="sd">    </span>
<span class="sd">    The diffraction pattern is first azimuthally integrated, excluding Bragg peaks, and the resulting radial</span>
<span class="sd">    profile is further smoothed. The profile is then re-projected to the full image and subtracted. This procedure</span>
<span class="sd">    usually works excellently well - at least, if the peak finding has been done carefully. If there are hard</span>
<span class="sd">    issues with peak finding, it might be worth setting rfunc=np.nanmedian.</span>
<span class="sd">    </span>
<span class="sd">    Peaks have to be provided in CXI format and convention.</span>

<span class="sd">    Args:</span>
<span class="sd">        img (np.ndarray): Input image or stack thereof</span>
<span class="sd">        x0 (Optional[float], optional): Diffraction pattern center along x. If None, use the image center.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        y0 (Optional[float], optional): Diffraction pattern center along y. If None, use the image center.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        nPeaks (Optional[np.ndarray], optional): Number of peaks. Defaults to None.</span>
<span class="sd">        peakXPosRaw (Optional[np.ndarray], optional): peak X positions. Defaults to None.</span>
<span class="sd">        peakYPosRaw (Optional[np.ndarray], optional): peak Y positions. Defaults to None.</span>
<span class="sd">        peak_radius (int, optional): Radius around each peak excluded from background calculation. Defaults to 3.</span>
<span class="sd">        filter_len (int, optional): Range of median filter applied to radial profile. Defaults to 5.</span>
<span class="sd">        rfunc (Callable[[np.ndarray], np.ndarray], optional): Function for calculation of the radial profile</span>
<span class="sd">            through azimuthal averaging. Defaults to np.nanmean.</span>
<span class="sd">        pxmask ([type], optional): Pixel mask to be applied after correction. Defaults to None.</span>
<span class="sd">        truncate (bool, optional): Set all pixels of value &lt; offset to 0. Defaults to False.</span>
<span class="sd">        offset (int, optional): Offset for the output image. Defaults to 0.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: [description]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span> <span class="ow">and</span> <span class="n">offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Removing background on an integer image with zero offset will likely cause trouble later on.&#39;</span><span class="p">)</span>

    <span class="n">replace_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">)</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>

    <span class="n">x0</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="o">.</span><span class="mi">5</span> <span class="k">if</span> <span class="n">x0</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">x0</span>
    <span class="n">y0</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="o">.</span><span class="mi">5</span> <span class="k">if</span> <span class="n">y0</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">y0</span>

    <span class="n">pxmask</span> <span class="o">=</span> <span class="p">((</span><span class="n">img</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">img</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="k">if</span> <span class="n">pxmask</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">pxmask</span>
    <span class="c1">#print((pxmask == 0).sum())</span>

    <span class="c1"># print(nPeaks)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">nPeaks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">nPeaks</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">img_nopk</span> <span class="o">=</span> <span class="n">cut_peaks</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">nPeaks</span><span class="p">,</span> <span class="n">peakXPosRaw</span><span class="p">,</span> <span class="n">peakYPosRaw</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="n">peak_radius</span><span class="p">,</span> <span class="n">replaceval</span><span class="o">=</span><span class="n">replace_val</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">img_nopk</span> <span class="o">=</span> <span class="n">img</span>
        
    <span class="c1"># ALWAYS mask gaps for the background determination</span>
    <span class="n">img_nopk</span> <span class="o">=</span> <span class="n">correct_dead_pixels</span><span class="p">(</span><span class="n">img_nopk</span><span class="p">,</span> <span class="n">pxmask</span><span class="p">,</span> <span class="n">mask_gaps</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s1">&#39;replace&#39;</span><span class="p">)</span>

    <span class="n">r0</span> <span class="o">=</span> <span class="n">radial_proj</span><span class="p">(</span><span class="n">img_nopk</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">my_func</span><span class="o">=</span><span class="n">rfunc</span><span class="p">,</span> <span class="n">filter_len</span><span class="o">=</span><span class="n">filter_len</span><span class="p">)</span>
    <span class="n">img_nobg</span> <span class="o">=</span> <span class="n">strip_img</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">prof</span><span class="o">=</span><span class="n">r0</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="o">=</span><span class="n">y0</span><span class="p">,</span> <span class="n">pxmask</span><span class="o">=</span><span class="n">pxmask</span><span class="p">,</span> <span class="n">truncate</span><span class="o">=</span><span class="n">truncate</span><span class="p">,</span> 
        <span class="n">keep_edge_offset</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">interp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">img_nobg</span></div>


<span class="nd">@jit</span><span class="p">([</span><span class="s1">&#39;int32[:,:](int32[:,:], float64, float64, int64, int64, int64)&#39;</span><span class="p">,</span>
      <span class="s1">&#39;int16[:,:](int16[:,:], float64, float64, int64, int64, int64)&#39;</span><span class="p">,</span>
      <span class="s1">&#39;int64[:,:](int64[:,:], float64, float64, int64, int64, int64)&#39;</span><span class="p">,</span>
      <span class="s1">&#39;float64[:,:](float64[:,:], float64, float64, int64, int64, float64)&#39;</span><span class="p">,</span>
      <span class="s1">&#39;float32[:,:](float32[:,:], float64, float64, int64, int64, float64)&#39;</span><span class="p">],</span>
     <span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># ahead-of-time compilation using numba. Otherwise painfully slow.</span>
<span class="k">def</span> <span class="nf">_center_sgl_image</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">xsize</span><span class="p">,</span> <span class="n">ysize</span><span class="p">,</span> <span class="n">padval</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Shifts a *single* image (not applicable to stacks!), such that the original image coordinates x0, y0 </span>
<span class="sd">    are in the center of the output image, which has a size of xsize, ysize.</span>
<span class="sd">    </span>
<span class="sd">    This function is typically used to change diffraction images such that the zero-order beam sits in the</span>
<span class="sd">    center of the image. The size of the output image should be sufficiently larger as to not truncate</span>
<span class="sd">    the shifted diffraction pattern.</span>
<span class="sd">    </span>
<span class="sd">    Note:</span>
<span class="sd">        The coordinates in this function refer to pixel centers (CXI convention), *not* pixel corners</span>
<span class="sd">        (CrystFEL convention). I.e., if shifting based on CrystFEL output or similar, the shifts</span>
<span class="sd">        must be increased by 0.5.</span>

<span class="sd">    Args:</span>
<span class="sd">        img (np.ndarray): Input image</span>
<span class="sd">        x0 (float): x position in input image to be shifted to the center of the output image</span>
<span class="sd">        y0 (float): y position in input image to be shifted to the center of the output image</span>
<span class="sd">        xsize (int): x size of the output image</span>
<span class="sd">        ysize (int): y size of the output image</span>
<span class="sd">        padval (float or int): value of the pixels used to pad the output image.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: output image of size (ysize, xsize) with centered diffraction pattern</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">simg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">padval</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">ysize</span><span class="p">,</span> <span class="n">xsize</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="c1">#int64=np.int64</span>
    <span class="c1">#x0 -= 0.5</span>
    <span class="n">xin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">xsize</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">xsize</span> <span class="o">/</span> <span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="n">x0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">int64</span><span class="p">)</span>  <span class="c1"># initial coordinate system</span>
    <span class="n">xout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">simg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">int64</span><span class="p">)</span>  <span class="c1"># now start constructing the final coordinate system</span>
    <span class="k">if</span> <span class="n">xin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">xout</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">xin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">xin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">xin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">xout</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">xout</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">xin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">xin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">yin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">ysize</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ysize</span> <span class="o">/</span> <span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="n">y0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">yout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">simg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">int64</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">yin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">yout</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">yin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">yin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">yin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">yout</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">yout</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">yin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">yin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1">#print(xin,xout,yin,yout)</span>
    <span class="n">simg</span><span class="p">[</span><span class="n">yout</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">yout</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">xout</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">xout</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">img</span><span class="p">[</span><span class="n">yin</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">yin</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">xin</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">xin</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">simg</span>


<div class="viewcode-block" id="center_image"><a class="viewcode-back" href="../../diffractem.proc2d.html#diffractem.proc2d.center_image">[docs]</a><span class="k">def</span> <span class="nf">center_image</span><span class="p">(</span><span class="n">imgs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">],</span> <span class="n">x0</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">],</span> 
                 <span class="n">y0</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">],</span> <span class="n">xsize</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">ysize</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> 
                 <span class="n">padval</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">parallel</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Shifts a stack of images, such that the original image coordinates x0, y0 </span>
<span class="sd">    are in the center of the output image, which has a size of xsize, ysize.</span>
<span class="sd">    </span>
<span class="sd">    This function is typically used to change diffraction images such that the zero-order beam sits in the</span>
<span class="sd">    center of the image. The size of the output image should be sufficiently larger as to not truncate</span>
<span class="sd">    the shifted diffraction pattern.</span>
<span class="sd">    </span>
<span class="sd">    Note:</span>
<span class="sd">        The coordinates in this function refer to pixel centers (CXI convention), *not* pixel corners</span>
<span class="sd">        (CrystFEL convention). I.e., if shifting based on CrystFEL output or similar, the shifts</span>
<span class="sd">        must be increased by 0.5.</span>

<span class="sd">    Args:</span>
<span class="sd">        imgs (Union[np.ndarray, da.Array]): Input image stack</span>
<span class="sd">        x0 (Union[np.ndarray, da.Array]): x position in input image to be shifted to the center of the output image</span>
<span class="sd">        y0 (Union[np.ndarray, da.Array]): y position in input image to be shifted to the center of the output image</span>
<span class="sd">        xsize (int): x size of the output image</span>
<span class="sd">        ysize (int): y size of the output image</span>
<span class="sd">        padval (Union[float, int, None], optional): value of the pixels used to pad the output image. </span>
<span class="sd">            If None, use nan for float images and -1 for integer images. Defaults to None.</span>
<span class="sd">        parallel (bool, optional): execute operation in parallel. Defaults to True.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Union[np.ndarray, da.Array]: output image stack of size (ysize, xsize) with centered diffraction patterns</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">padval</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">padval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">imgs</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
    
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">imgs</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">):</span>
        <span class="c1"># Preprocess arguments and call function again, using map_blocks along the stack direction</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">x0</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">y0</span> <span class="o">=</span> <span class="n">y0</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">):</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="p">(</span><span class="n">imgs</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">):</span>
            <span class="n">y0</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="p">(</span><span class="n">imgs</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">imgs</span><span class="o">.</span><span class="n">map_blocks</span><span class="p">(</span><span class="n">center_image</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">xsize</span><span class="p">,</span> <span class="n">ysize</span><span class="p">,</span> <span class="n">padval</span><span class="p">,</span>
                               <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="n">imgs</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ysize</span><span class="p">,</span> <span class="n">xsize</span><span class="p">),</span>
                               <span class="n">dtype</span><span class="o">=</span><span class="n">imgs</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># condition the input arguments a bit...</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="n">x0</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">x0</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x0</span><span class="p">)]</span> <span class="o">=</span> <span class="n">imgs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">y0</span> <span class="o">=</span> <span class="n">y0</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">y0</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">y0</span><span class="p">)]</span> <span class="o">=</span> <span class="n">imgs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">simgs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">padval</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">imgs</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">imgs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ysize</span><span class="p">,</span> <span class="n">xsize</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">imgs</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">parallel</span><span class="p">:</span>
        <span class="n">it</span> <span class="o">=</span> <span class="n">prange</span><span class="p">(</span><span class="n">imgs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># uses numba&#39;s prange for parallelization</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">it</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">imgs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
        <span class="n">simg</span> <span class="o">=</span> <span class="n">_center_sgl_image</span><span class="p">(</span><span class="n">imgs</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">x0</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">y0</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">xsize</span><span class="p">,</span> <span class="n">ysize</span><span class="p">,</span> <span class="n">padval</span><span class="p">)</span>
        <span class="n">simgs</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">simg</span>

    <span class="k">return</span> <span class="n">simgs</span></div>


<div class="viewcode-block" id="apply_saturation_correction"><a class="viewcode-back" href="../../diffractem.proc2d.html#diffractem.proc2d.apply_saturation_correction">[docs]</a><span class="k">def</span> <span class="nf">apply_saturation_correction</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">exp_time</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">dead_time</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.9e-3</span><span class="p">,</span> 
                                <span class="n">gap_factor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Apply detector correction function to image. Should ideally be done even before flatfield.</span>
<span class="sd">    Uses a 5th order polynomial approximation to the Lambert function, which is appropriate</span>
<span class="sd">    for a paralyzable detector, up to the point where its signal starts inverting (which is where</span>
<span class="sd">    nothing can be done anymore)</span>
<span class="sd">    </span>
<span class="sd">    The default dead time value of 1.9 microseconds has been determined for a Medipix3 sensor.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        img (np.ndarray): Input image or image stack</span>
<span class="sd">        exp (float): Exposure time in ms</span>
<span class="sd">        dead_time (float, optional): Dead time of detector in ms. Defaults to 1.9e-3.</span>
<span class="sd">        gap_factor (float, optional): Factor to scale dead time for gap pixels. Defaults to 2.4.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lambert</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">-</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">8</span><span class="o">/</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">125</span><span class="o">/</span><span class="mi">24</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">5</span>
    <span class="n">satcorr</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">y</span><span class="p">,</span> <span class="n">sat</span><span class="p">:</span> <span class="o">-</span><span class="n">lambert</span><span class="p">(</span><span class="o">-</span><span class="n">sat</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="n">sat</span> <span class="c1"># saturation parameter: dead time/exposure time</span>
    <span class="k">if</span> <span class="n">gap_factor</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">dead_time</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">gap_factor</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">gap_pixels</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">dead_time</span>
        
    <span class="k">return</span> <span class="n">satcorr</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">dt</span><span class="o">/</span><span class="n">exp_time</span><span class="p">)</span></div>


<div class="viewcode-block" id="apply_flatfield"><a class="viewcode-back" href="../../diffractem.proc2d.html#diffractem.proc2d.apply_flatfield">[docs]</a><span class="k">def</span> <span class="nf">apply_flatfield</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">reference</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">keep_type</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> 
                    <span class="n">ref_smooth_range</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>  
                    <span class="n">normalize_reference</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Corrects the detector response by dividing the images in the image (stack) by a reference</span>
<span class="sd">    image (gain reference image), which should vary around 1.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        img (np.ndarray): Input image</span>
<span class="sd">        reference (Union[np.ndarray, str]): array containing the reference image, or filename of</span>
<span class="sd">            a TIF file containing the reference image</span>
<span class="sd">        keep_type (bool, optional): Keep the image data type, that is, round the pixel values</span>
<span class="sd">            back to integers if the input is an integer image. If False, the output image</span>
<span class="sd">            will always be a float. Defaults to True.</span>
<span class="sd">        ref_smooth_range (Optional[float], optional): If not None, applies a Gaussian blur to the</span>
<span class="sd">            reference image before correction, use this parameter to set its width. Defaults to None.</span>
<span class="sd">        normalize_reference (bool, optional): Re-normalize the reference image such that its</span>
<span class="sd">            average value is exactly 1. Defaults to False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: flatfield-corrected image</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">reference</span> <span class="o">=</span> <span class="n">imread</span><span class="p">(</span><span class="n">reference</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">reference</span> <span class="o">=</span> <span class="n">reference</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;reference must be either numpy array or TIF filename&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">normalize_reference</span><span class="p">:</span>
        <span class="n">reference</span> <span class="o">=</span> <span class="n">reference</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">reference</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">ref_smooth_range</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">reference</span> <span class="o">=</span> <span class="n">convolve</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">Gaussian2DKernel</span><span class="p">(</span><span class="n">ref_smooth_range</span><span class="p">),</span>
                             <span class="n">boundary</span><span class="o">=</span><span class="s1">&#39;extend&#39;</span><span class="p">,</span> <span class="n">nan_treatment</span><span class="o">=</span><span class="s1">&#39;interpolate&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">reference</span> <span class="o">=</span> <span class="n">reference</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">reference</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span><span class="n">reference</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

    <span class="k">if</span> <span class="n">keep_type</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">img</span><span class="o">/</span><span class="n">reference</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">img</span><span class="o">/</span><span class="n">reference</span></div>


<div class="viewcode-block" id="correct_dead_pixels"><a class="viewcode-back" href="../../diffractem.proc2d.html#diffractem.proc2d.correct_dead_pixels">[docs]</a><span class="k">def</span> <span class="nf">correct_dead_pixels</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">],</span> <span class="n">pxmask</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> 
                        <span class="n">strategy</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;interpolate&#39;</span><span class="p">,</span> 
                        <span class="n">interp_range</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">replace_val</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                        <span class="n">mask_gaps</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">edge_mask_x</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">70</span><span class="p">,</span> 
                        <span class="n">edge_mask_y</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">invert_mask</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Corrects a set of images for dead pixels by either replacing values with a </span>
<span class="sd">    constant, or interpolation from a Gaussian-smoothed version of the image. It </span>
<span class="sd">    requires a binary array (pxmask) which is 1 (or 255 or True) for dead pixels. </span>
<span class="sd">    The function accepts a 3D array where the first dimension corresponds to a stack/movie.</span>

<span class="sd">    Args:</span>
<span class="sd">        img (np.ndarray): the image or image stack (first dimension is stack). </span>
<span class="sd">            For strategy==&#39;replace&#39; it can be a dask or numpy array, otherwise numpy only.</span>
<span class="sd">        pxmask (Union[np.ndarray, str]): pixel mask with values as described above, or name of</span>
<span class="sd">            a TIF file containing the pixel mask</span>
<span class="sd">        strategy (str, optional): &#39;interpolate&#39; or &#39;replace&#39;. Defaults to &#39;interpolate&#39;.</span>
<span class="sd">        interp_range (int, optional): range of interpolation for &#39;interpolate&#39; strategy, in pixels. </span>
<span class="sd">            Defaults to 1.</span>
<span class="sd">        replace_val (Union[float, int], optional): replacement value for &#39;replace&#39; strategy. If None, use</span>
<span class="sd">            -1 for integer images and nan for float images. Defaults to None.</span>
<span class="sd">        mask_gaps (bool, optional): mask gaps between detector panels as returned by the gap_pixels() function. </span>
<span class="sd">            Defaults to False.</span>
<span class="sd">        edge_mask_x (int, optional): Declare this number of pixels near the edges along x as</span>
<span class="sd">            invalid and replace them with replaceval. Defaults to 70.</span>
<span class="sd">        edge_mask_y (int, optional): Declare this number of pixels near the edges along y as</span>
<span class="sd">            invalid and replace them with replaceval. Defaults to 0.</span>
<span class="sd">        invert_mask (bool, optional): invert the pixel mask, i.e., invalid pixels are zero/False. Defaults to False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: dead-pixel corrected image. Can be da.Array for &#39;replace&#39; strategy.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">assert</span> <span class="n">strategy</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;interpolate&#39;</span><span class="p">,</span> <span class="s1">&#39;replace&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">replace_val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">replace_val</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pxmask</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">pxmask</span> <span class="o">=</span> <span class="n">imread</span><span class="p">(</span><span class="n">pxmask</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pxmask</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pxmask</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">):</span>
        <span class="n">pxmask</span> <span class="o">=</span> <span class="n">pxmask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">invert_mask</span><span class="p">:</span>
            <span class="n">pxmask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">pxmask</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;pxmask must be either Numpy array, or TIF file name&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mask_gaps</span><span class="p">:</span>
        <span class="n">pxmask</span><span class="p">[</span><span class="n">gap_pixels</span><span class="p">()]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">edge_mask_x</span><span class="p">:</span>
        <span class="n">pxmask</span><span class="p">[:,</span> <span class="p">:</span><span class="n">edge_mask_x</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">pxmask</span><span class="p">[:,</span> <span class="o">-</span><span class="n">edge_mask_x</span><span class="p">:]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">edge_mask_y</span><span class="p">:</span>
        <span class="n">pxmask</span><span class="p">[:</span><span class="n">edge_mask_y</span><span class="p">,:]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">pxmask</span><span class="p">[</span><span class="o">-</span><span class="n">edge_mask_y</span><span class="p">:,:]</span> <span class="o">=</span> <span class="kc">True</span>
        
    <span class="k">if</span> <span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;interpolate&#39;</span><span class="p">:</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">and</span> <span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;interpolate&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">correct_dead_pixels</span><span class="p">(</span><span class="n">theImg</span><span class="p">,</span> <span class="n">pxmask</span><span class="o">=</span><span class="n">pxmask</span><span class="p">,</span> 
                                                 <span class="n">strategy</span><span class="o">=</span><span class="s1">&#39;interpolate&#39;</span><span class="p">,</span> <span class="n">interp_range</span><span class="o">=</span><span class="n">interp_range</span><span class="p">,</span>
                                                 <span class="n">replace_val</span><span class="o">=</span><span class="n">replace_val</span><span class="p">)</span> <span class="k">for</span> <span class="n">theImg</span> <span class="ow">in</span> <span class="n">img</span><span class="p">])</span>

        <span class="n">kernel</span> <span class="o">=</span> <span class="n">Gaussian2DKernel</span><span class="p">(</span><span class="n">interp_range</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">catch_warnings</span><span class="p">():</span>
            <span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
            <span class="n">img_flt</span> <span class="o">=</span> <span class="n">convolve</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="s1">&#39;extend&#39;</span><span class="p">,</span> 
                            <span class="n">nan_treatment</span><span class="o">=</span><span class="s1">&#39;interpolate&#39;</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">pxmask</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
            <span class="n">img_flt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">img_flt</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">nan</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        
        <span class="n">img_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">pxmask</span><span class="p">,</span> <span class="n">img_flt</span><span class="p">,</span> <span class="n">img</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">img_out</span>

    <span class="k">elif</span> <span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;replace&#39;</span><span class="p">:</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># putmask does not support broadcasting</span>
                <span class="n">np</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">pxmask</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> 
                           <span class="n">replace_val</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">pxmask</span><span class="p">,</span> <span class="n">replace_val</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">img</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">):</span>
             <span class="c1">#dask arrays are immutable. This requires a slightly different way</span>
            <span class="n">sz</span> <span class="o">=</span> <span class="n">pxmask</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">pml</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">pxmask</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">sz</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">sz</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> 
                                <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">sz</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">sz</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">pml</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">pml</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">chunks</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">da</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">pml</span><span class="p">,</span> <span class="n">replace_val</span><span class="p">,</span> <span class="n">img</span><span class="p">)</span></div>
    
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Robert Bücker

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>