

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>diffractem.proc2d &mdash; diffractem  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> diffractem
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../pre_processing.html">Preprocessing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crystfel.html">CrystFEL integration</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">diffractem</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>diffractem.proc2d</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for diffractem.proc2d</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">tifffile</span>
<span class="kn">from</span> <span class="nn">tifffile</span> <span class="kn">import</span> <span class="n">imread</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
<span class="kn">import</span> <span class="nn">dask</span>
<span class="kn">from</span> <span class="nn">dask.distributed</span> <span class="kn">import</span> <span class="n">Client</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">jit</span><span class="p">,</span> <span class="n">prange</span><span class="p">,</span> <span class="n">int64</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">gap_pixels</span>
<span class="kn">from</span> <span class="nn">.pre_proc_opts</span> <span class="kn">import</span> <span class="n">PreProcOpts</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">optimize</span><span class="p">,</span> <span class="n">sparse</span><span class="p">,</span> <span class="n">special</span><span class="p">,</span> <span class="n">interpolate</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage.morphology</span> <span class="kn">import</span> <span class="n">binary_dilation</span>
<span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">disk</span>
<span class="kn">from</span> <span class="nn">astropy.convolution</span> <span class="kn">import</span> <span class="n">Gaussian2DKernel</span><span class="p">,</span> <span class="n">convolve</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage.filters</span> <span class="kn">import</span> <span class="n">median_filter</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Dict</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<div class="viewcode-block" id="stack_nested"><a class="viewcode-back" href="../../diffractem.proc2d.html#diffractem.proc2d.stack_nested">[docs]</a><span class="k">def</span> <span class="nf">stack_nested</span><span class="p">(</span><span class="n">data_list</span><span class="p">,</span> <span class="n">fun</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">):</span> 
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">data_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">data_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">data_list</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">stack_nested</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">fun</span><span class="p">)</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">data_list</span><span class="p">))</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">stack_nested</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">fun</span><span class="p">)</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">data_list</span><span class="p">))</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">stack_nested</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">o</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">data_list</span><span class="p">),</span> <span class="n">fun</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">data_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fun</span><span class="p">(</span><span class="n">data_list</span><span class="p">)</span></div>

<div class="viewcode-block" id="loop_over_stack"><a class="viewcode-back" href="../../diffractem.proc2d.html#diffractem.proc2d.loop_over_stack">[docs]</a><span class="k">def</span> <span class="nf">loop_over_stack</span><span class="p">(</span><span class="n">fun</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Decorator to (sequentially) loop a 2D processing function over a stack. </span>
<span class="sd">    Works on all functions with signature fun(imgs, *args, **kwargs), where </span>
<span class="sd">    imgs is a 3D stack or a 2D single image. </span>
<span class="sd">    If any of the positional/named arguments is an iterable of the same length </span>
<span class="sd">    as the image stack, it is distributed over the function calls for each </span>
<span class="sd">    image.</span>
<span class="sd">    </span>
<span class="sd">    :param fun     : function to be decorated</span>
<span class="sd">    :return         : decorated function</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#TODO: handle functions with multiple outputs, and return a list of ndarrays</span>
    <span class="c1">#TODO: allow switches for paralellization</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">fun</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">loop_fun</span><span class="p">(</span><span class="n">imgs</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># this is NOT intended for dask arrays!</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">imgs</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;loop_over_stack only works on numpy arrays (not dask etc.). &#39;</span>
                            <span class="sa">f</span><span class="s1">&#39;Passed type to </span><span class="si">{</span><span class="n">fun</span><span class="si">}</span><span class="s1"> is </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">imgs</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">imgs</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fun</span><span class="p">(</span><span class="n">imgs</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">imgs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># some gymnastics if arrays are on weird dimensions (often after map_blocks)</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">else</span> <span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">else</span> <span class="n">a</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="k">return</span> <span class="n">stack_nested</span><span class="p">([</span><span class="n">fun</span><span class="p">(</span><span class="n">imgs</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)])</span>

        <span class="c1">#print(&#39;Applying {} to {} images of shape {}&#39;.format(fun, imgs.shape[0], imgs.shape[1:]))</span>

        <span class="k">def</span> <span class="nf">_isiterable</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="p">(</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="n">iter_args</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_isiterable</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">imgs</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
                <span class="n">iter_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># iter_args.append(repeat(a, lenb(imgs)))</span>
                <span class="n">iter_args</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">a</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">imgs</span><span class="p">))</span>

        <span class="n">iter_kwargs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">_isiterable</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">imgs</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
                <span class="n">iter_kwargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># iter_kwargs.append(repeat(a, len(imgs)))</span>
                <span class="n">iter_kwargs</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">a</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">imgs</span><span class="p">))</span>

        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">imgs</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">iter_args</span> <span class="o">+</span> <span class="n">iter_kwargs</span><span class="p">)):</span>
            <span class="n">theArgs</span> <span class="o">=</span> <span class="n">arg</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)]</span>
            <span class="n">theKwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">arg</span><span class="p">[</span><span class="mi">1</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">):])}</span>
            <span class="c1"># print(&#39;Arguments: &#39;, theArgs)</span>
            <span class="c1"># print(&#39;KW Args:   &#39;, theKwargs)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fun</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">*</span><span class="n">theArgs</span><span class="p">,</span> <span class="o">**</span><span class="n">theKwargs</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">out</span><span class="p">:</span>
            <span class="c1"># required for dask map_blocks init runs</span>
            <span class="c1"># print(&#39;Looping of&#39;,fun,&#39;requested for zero-size input.&#39;)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">imgs</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">imgs</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># print(type(out), type(out[0]))</span>
            <span class="k">return</span> <span class="n">stack_nested</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
                
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Function&#39;</span><span class="p">,</span><span class="n">fun</span><span class="p">,</span><span class="s1">&#39;failed for output array construction.&#39;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">err</span>

    <span class="k">return</span> <span class="n">loop_fun</span></div>


<span class="nd">@loop_over_stack</span>
<span class="k">def</span> <span class="nf">_generate_pattern_info</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">opts</span><span class="p">:</span> <span class="n">PreProcOpts</span><span class="p">,</span> <span class="n">reference</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">pxmask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="c1"># computations on diffraction patterns. To be called from get_pattern_info.</span>
    
    <span class="n">reference</span> <span class="o">=</span> <span class="n">opts</span><span class="o">.</span><span class="n">reference</span> <span class="k">if</span> <span class="n">reference</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">reference</span>
    <span class="n">pxmask</span> <span class="o">=</span> <span class="n">opts</span><span class="o">.</span><span class="n">pxmask</span> <span class="k">if</span> <span class="n">pxmask</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">pxmask</span>
        
    <span class="kn">from</span> <span class="nn">diffractem.proc_peaks</span> <span class="kn">import</span> <span class="n">_ctr_from_pks</span>
    
    <span class="c1"># apply flatfield and dead-pixel correction to get more accurate COM</span>
    <span class="c1"># CONSIDER DOING THIS OUTSIDE GET PATTERN INFO!</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">apply_flatfield</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">reference</span><span class="p">,</span> <span class="n">keep_type</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">correct_dead_pixels</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">pxmask</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s1">&#39;replace&#39;</span><span class="p">,</span> <span class="n">mask_gaps</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">replace_val</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># thresholded center-of-mass calculation over x-axis sub-range</span>
    <span class="n">img_ct</span> <span class="o">=</span> <span class="n">img</span><span class="p">[:,(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">opts</span><span class="o">.</span><span class="n">com_xrng</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">:(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">opts</span><span class="o">.</span><span class="n">com_xrng</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">com</span> <span class="o">=</span> <span class="n">center_of_mass</span><span class="p">(</span><span class="n">img_ct</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">opts</span><span class="o">.</span><span class="n">com_threshold</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">img_ct</span><span class="p">,</span><span class="mi">1</span><span class="o">-</span><span class="mf">5e-5</span><span class="p">))</span> <span class="o">+</span> <span class="p">[(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">opts</span><span class="o">.</span><span class="n">com_xrng</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    
    <span class="c1"># Lorentz fit of direct beam</span>
    <span class="n">lorentz</span> <span class="o">=</span> <span class="n">lorentz_fast</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">com</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">radius</span><span class="o">=</span><span class="n">opts</span><span class="o">.</span><span class="n">lorentz_radius</span><span class="p">,</span>
                                        <span class="n">limit</span><span class="o">=</span><span class="n">opts</span><span class="o">.</span><span class="n">lorentz_maxshift</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">threads</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    
    <span class="c1"># Get peaks using peakfinder8. Note that pf8 parameters are taken straight from the options file,</span>
    <span class="c1"># with automatic underscore/hyphen replacement.</span>
    <span class="c1"># Note that peak positions are CXI convention, i.e. refer to pixel _center_</span>
    <span class="n">peak_data</span> <span class="o">=</span> <span class="n">get_peaks</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">lorentz</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">lorentz</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">pxmask</span><span class="o">=</span><span class="n">pxmask</span><span class="p">,</span> <span class="n">max_peaks</span><span class="o">=</span><span class="n">opts</span><span class="o">.</span><span class="n">max_peaks</span><span class="p">,</span>
                                <span class="o">**</span><span class="p">{</span><span class="n">k</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span><span class="s1">&#39;_&#39;</span><span class="p">):</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">opts</span><span class="o">.</span><span class="n">peak_search_params</span><span class="o">.</span><span class="n">items</span><span class="p">()},</span>
                                <span class="n">as_dict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">peak_data</span><span class="p">[</span><span class="s1">&#39;nPeaks&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">opts</span><span class="o">.</span><span class="n">min_peaks</span><span class="p">:</span>  
        
        <span class="c1"># prepare peak list. Note the .5, as _ctr_from_pks expects CrystFEL peak convention,</span>
        <span class="c1"># i.e. positions refer to pixel _corner_</span>
        <span class="n">pkl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">peak_data</span><span class="p">[</span><span class="s1">&#39;peakXPosRaw&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="n">peak_data</span><span class="p">[</span><span class="s1">&#39;peakYPosRaw&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="o">.</span><span class="mi">5</span><span class="p">,</span> 
                        <span class="n">peak_data</span><span class="p">[</span><span class="s1">&#39;peakTotalIntensity&#39;</span><span class="p">]),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)[:</span><span class="nb">int</span><span class="p">(</span><span class="n">peak_data</span><span class="p">[</span><span class="s1">&#39;nPeaks&#39;</span><span class="p">]),:]</span>
        <span class="k">if</span> <span class="n">opts</span><span class="o">.</span><span class="n">friedel_max_radius</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rsq</span> <span class="o">=</span> <span class="p">(</span><span class="n">pkl</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">lorentz</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">pkl</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">lorentz</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="n">pkl</span> <span class="o">=</span> <span class="n">pkl</span><span class="p">[</span><span class="n">rsq</span> <span class="o">&lt;</span> <span class="n">opts</span><span class="o">.</span><span class="n">friedel_max_radius</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>
        
        <span class="n">ctr_refined</span><span class="p">,</span> <span class="n">cost</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_ctr_from_pks</span><span class="p">(</span><span class="n">pkl</span><span class="p">,</span> <span class="n">lorentz</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="n">int_weight</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
                    <span class="n">sigma</span><span class="o">=</span><span class="n">opts</span><span class="o">.</span><span class="n">peak_sigma</span><span class="p">)</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ctr_refined</span><span class="p">,</span> <span class="n">cost</span> <span class="o">=</span> <span class="n">lorentz</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="n">pattern_info</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;com_x&#39;</span><span class="p">:</span> <span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;com_y&#39;</span><span class="p">:</span> <span class="n">com</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                    <span class="s1">&#39;lor_pk&#39;</span><span class="p">:</span> <span class="n">lorentz</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                    <span class="s1">&#39;lor_x&#39;</span><span class="p">:</span> <span class="n">lorentz</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                    <span class="s1">&#39;lor_y&#39;</span><span class="p">:</span> <span class="n">lorentz</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                    <span class="s1">&#39;lor_hwhm&#39;</span><span class="p">:</span> <span class="n">lorentz</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
                    <span class="s1">&#39;center_x&#39;</span><span class="p">:</span> <span class="n">ctr_refined</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="s1">&#39;center_y&#39;</span><span class="p">:</span> <span class="n">ctr_refined</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                    <span class="s1">&#39;center_refine_score&#39;</span><span class="p">:</span> <span class="n">cost</span><span class="p">,</span>
                    <span class="s1">&#39;num_peaks&#39;</span><span class="p">:</span> <span class="n">peak_data</span><span class="p">[</span><span class="s1">&#39;nPeaks&#39;</span><span class="p">],</span>
                    <span class="s1">&#39;peak_data&#39;</span><span class="p">:</span> <span class="n">peak_data</span><span class="p">}</span>
        
    <span class="k">return</span> <span class="n">pattern_info</span>


<div class="viewcode-block" id="get_pattern_info"><a class="viewcode-back" href="../../diffractem.proc2d.html#diffractem.proc2d.get_pattern_info">[docs]</a><span class="k">def</span> <span class="nf">get_pattern_info</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">opts</span><span class="p">:</span> <span class="n">PreProcOpts</span><span class="p">,</span> <span class="n">client</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Client</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                     <span class="n">reference</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                     <span class="n">pxmask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                     <span class="n">lazy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">sync</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    PATTERN PROCESSING MACRO</span>
<span class="sd">    ...returns a DataFrame + dict!</span>
<span class="sd">    get_pattern_info computes information on a given diffraction pattern or stack thereof </span>
<span class="sd">    (as 3D numpy array), returned as a dask.delayed object that computes to a dictionary.</span>
<span class="sd">    It can be altered as required, but in this incarnation it computes center of mass,</span>
<span class="sd">    Parameters of a Lorentzian fit, Pattern center as determined from Friedel pair</span>
<span class="sd">    matching, and Found peaks using peakfinder8 in CXI format (as a sub-dict).</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">reference</span> <span class="o">=</span> <span class="n">imread</span><span class="p">(</span><span class="n">opts</span><span class="o">.</span><span class="n">reference</span><span class="p">)</span> <span class="k">if</span> <span class="n">reference</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">reference</span>
    <span class="n">pxmask</span> <span class="o">=</span> <span class="n">imread</span><span class="p">(</span><span class="n">opts</span><span class="o">.</span><span class="n">pxmask</span><span class="p">)</span> <span class="k">if</span> <span class="n">pxmask</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">pxmask</span>
<span class="c1">#     print(type(pxmask))</span>
    
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">):</span>
        <span class="n">cts</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">to_delayed</span><span class="p">()</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">res_del</span> <span class="o">=</span> <span class="p">[</span><span class="n">dask</span><span class="o">.</span><span class="n">delayed</span><span class="p">(</span><span class="n">_generate_pattern_info</span><span class="p">,</span> <span class="n">nout</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
                                <span class="n">pure</span><span class="o">=</span><span class="kc">True</span><span class="p">)(</span><span class="n">c</span><span class="p">,</span> <span class="n">opts</span><span class="o">=</span><span class="n">opts</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="n">reference</span><span class="p">,</span> <span class="n">pxmask</span><span class="o">=</span><span class="n">pxmask</span><span class="p">,</span>
                                           <span class="n">dask_key_name</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;pattern_info_chunk_</span><span class="si">{</span><span class="n">ii</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cts</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">lazy</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">res_del</span>
        <span class="k">if</span> <span class="n">client</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ftrs</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">res_del</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Running get_pattern_info on cluster at </span><span class="si">{</span><span class="n">client</span><span class="o">.</span><span class="n">scheduler_info</span><span class="p">()[</span><span class="s2">&quot;address&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">. </span><span class="se">\n</span><span class="s1">&#39;</span>
                  <span class="sa">f</span><span class="s1">&#39;Watch progress at </span><span class="si">{</span><span class="n">client</span><span class="o">.</span><span class="n">dashboard_link</span><span class="si">}</span><span class="s1"> (or forward port if remote).&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">sync</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ftrs</span>
            <span class="n">alldat</span> <span class="o">=</span> <span class="n">stack_nested</span><span class="p">(</span><span class="n">client</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">ftrs</span><span class="p">),</span> <span class="n">fun</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;get_pattern_info is run on a dask array without distributed client - might be slow!&#39;</span><span class="p">)</span>
            <span class="n">alldat</span> <span class="o">=</span> <span class="n">dask</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
            
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">alldat</span> <span class="o">=</span> <span class="n">_generate_pattern_info</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">opts</span><span class="o">=</span><span class="n">opts</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="n">reference</span><span class="p">,</span> <span class="n">pxmask</span><span class="o">=</span><span class="n">pxmask</span><span class="p">)</span>
        
    <span class="n">shotdata</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">alldat</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)})</span>
    <span class="n">peakinfo</span> <span class="o">=</span> <span class="n">alldat</span><span class="p">[</span><span class="s1">&#39;peak_data&#39;</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">shotdata</span><span class="p">,</span> <span class="n">peakinfo</span>    </div>


<span class="nd">@loop_over_stack</span>
<span class="k">def</span> <span class="nf">_compute_corr_img</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                      <span class="n">x0</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y0</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> 
                      <span class="n">nPeaks</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> 
                      <span class="n">peakXPosRaw</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> 
                      <span class="n">peakYPosRaw</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> 
                      <span class="n">opts</span><span class="p">:</span> <span class="n">PreProcOpts</span><span class="p">,</span>
                      <span class="n">reference</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                      <span class="n">pxmask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Inner function for image correction, to be called from correct_image</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">opts</span><span class="o">.</span><span class="n">correct_saturation</span><span class="p">:</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">apply_saturation_correction</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">opts</span><span class="o">.</span><span class="n">shutter_time</span><span class="p">,</span> <span class="n">opts</span><span class="o">.</span><span class="n">dead_time</span><span class="p">)</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">apply_flatfield</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="n">reference</span><span class="p">)</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">correct_dead_pixels</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">pxmask</span><span class="o">=</span><span class="n">pxmask</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s1">&#39;replace&#39;</span><span class="p">,</span> <span class="n">mask_gaps</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="c1"># TODO: CHANGE PXMASK HANDLING TO ALLOW FOR INTERPOLATED/GAP-INCLUDING IMAGES</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">remove_background</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">nPeaks</span><span class="p">,</span> <span class="n">peakXPosRaw</span><span class="p">,</span> <span class="n">peakYPosRaw</span><span class="p">,</span> <span class="n">pxmask</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    
    <span class="c1"># has to be re-done after background correction</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">correct_dead_pixels</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">pxmask</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s1">&#39;replace&#39;</span><span class="p">,</span> <span class="n">mask_gaps</span><span class="o">=</span><span class="n">opts</span><span class="o">.</span><span class="n">mask_gaps</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">img</span>


<div class="viewcode-block" id="correct_image"><a class="viewcode-back" href="../../diffractem.proc2d.html#diffractem.proc2d.correct_image">[docs]</a><span class="k">def</span> <span class="nf">correct_image</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">],</span> <span class="n">opts</span><span class="p">:</span> <span class="n">PreProcOpts</span><span class="p">,</span> 
                  <span class="n">x0</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                  <span class="n">y0</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                  <span class="n">peakinfo</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                  <span class="n">reference</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                  <span class="n">pxmask</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Runs correction pipeline on stack of diffraction images (numpy or dask). The pipeline comprises</span>
<span class="sd">    flat-field, saturation and dead-pixel correction, as well as background subtraction, optionally</span>
<span class="sd">    including peak exclusion (recommended).</span>

<span class="sd">    Arguments:</span>
<span class="sd">        img {Union[np.ndarray, da.Array]} -- Diffraction pattern stack</span>
<span class="sd">        opts {PreProcOpts} -- Pre-processing options. Options used are: (...)</span>

<span class="sd">    Keyword Arguments:</span>
<span class="sd">        x0 {Union[None, np.ndarray, da.Array]} -- Pattern X centers </span>
<span class="sd">            (default: use image center)</span>
<span class="sd">        y0 {Union[None, np.ndarray, da.Array]} -- Pattern Y centers </span>
<span class="sd">            (default: use image center)</span>
<span class="sd">        peakinfo {Union[None, Dict[Union[np.ndarray, da.Array]]]} -- Diffraction peak dict in CXI format</span>
<span class="sd">            (default: no peak exclusion during background subtraction)</span>
<span class="sd">        reference {Union[None, Union[np.ndarray, str]]} -- Flat-field reference </span>
<span class="sd">            (default: use reference file specified in options)</span>
<span class="sd">        pxmask {Union[None, Union[np.ndarray, str]]} -- [description] </span>
<span class="sd">            (default: use pixel mask file specified in options)</span>

<span class="sd">    Returns:</span>
<span class="sd">        [Union[np.ndarray, da.Array]] -- Corrected diffraction image stack.</span>
<span class="sd">        </span>
<span class="sd">    Note:</span>
<span class="sd">        This function essentially wraps proc2d._compute_corr_image. If you want to change the </span>
<span class="sd">        correction pipeline, that is the function to modify.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="c1"># take care of numpy image with dask arguments (just in case)</span>
        <span class="n">innerargs</span> <span class="o">=</span> <span class="p">[</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">peakinfo</span><span class="p">[</span><span class="s1">&#39;nPeaks&#39;</span><span class="p">],</span> <span class="n">peakinfo</span><span class="p">[</span><span class="s1">&#39;peakXPosRaw&#39;</span><span class="p">],</span> <span class="n">peakinfo</span><span class="p">[</span><span class="s1">&#39;peakYPosRaw&#39;</span><span class="p">]]</span>
        <span class="n">innerargs</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">)</span> <span class="k">else</span> <span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">innerargs</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">_compute_corr_img</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="o">*</span><span class="n">innerargs</span><span class="p">,</span> <span class="n">opts</span><span class="p">,</span> <span class="n">reference</span><span class="p">,</span> <span class="n">pxmask</span><span class="p">)</span>
    
    <span class="n">reference</span> <span class="o">=</span> <span class="n">imread</span><span class="p">(</span><span class="n">opts</span><span class="o">.</span><span class="n">reference</span><span class="p">)</span> <span class="k">if</span> <span class="n">reference</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">reference</span>
    <span class="n">pxmask</span> <span class="o">=</span> <span class="n">imread</span><span class="p">(</span><span class="n">opts</span><span class="o">.</span><span class="n">pxmask</span><span class="p">)</span> <span class="k">if</span> <span class="n">pxmask</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">pxmask</span>
    
    <span class="n">N</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">x0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">y0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">y0</span> <span class="o">=</span> <span class="kc">None</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">):</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">x0</span><span class="o">.</span><span class="n">values</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)</span> <span class="k">else</span> <span class="n">x0</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">y0</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">y0</span><span class="o">.</span><span class="n">values</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)</span> <span class="k">else</span> <span class="n">y0</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    
    <span class="k">if</span> <span class="n">peakinfo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">npk</span> <span class="o">=</span> <span class="n">pkx</span> <span class="o">=</span> <span class="n">pky</span> <span class="o">=</span> <span class="kc">None</span>
        
    <span class="k">else</span><span class="p">:</span>     
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">peakinfo</span><span class="p">[</span><span class="s1">&#39;nPeaks&#39;</span><span class="p">],</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">):</span>
            <span class="n">peakinfo</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;nPeaks&#39;</span><span class="p">:</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">peakinfo</span><span class="p">[</span><span class="s1">&#39;nPeaks&#39;</span><span class="p">],</span> <span class="n">chunks</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                    <span class="s1">&#39;peakXPosRaw&#39;</span><span class="p">:</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">peakinfo</span><span class="p">[</span><span class="s1">&#39;peakXPosRaw&#39;</span><span class="p">],</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">)),</span>
                    <span class="s1">&#39;peakYPosRaw&#39;</span><span class="p">:</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">peakinfo</span><span class="p">[</span><span class="s1">&#39;peakYPosRaw&#39;</span><span class="p">],</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">))}</span>

        <span class="n">npk</span> <span class="o">=</span> <span class="n">peakinfo</span><span class="p">[</span><span class="s1">&#39;nPeaks&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">pkx</span> <span class="o">=</span> <span class="n">peakinfo</span><span class="p">[</span><span class="s1">&#39;peakXPosRaw&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">pky</span> <span class="o">=</span> <span class="n">peakinfo</span><span class="p">[</span><span class="s1">&#39;peakYPosRaw&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="n">da</span><span class="o">.</span><span class="n">map_blocks</span><span class="p">(</span><span class="n">_compute_corr_img</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">x0</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)),</span> <span class="n">y0</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)),</span> 
                         <span class="n">npk</span><span class="p">,</span> <span class="n">pkx</span><span class="p">,</span> <span class="n">pky</span><span class="p">,</span> 
                         <span class="n">reference</span><span class="o">=</span><span class="n">reference</span><span class="p">,</span> <span class="n">pxmask</span><span class="o">=</span><span class="n">pxmask</span><span class="p">,</span> <span class="n">opts</span><span class="o">=</span><span class="n">opts</span><span class="p">,</span>
                         <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">chunks</span><span class="p">)</span></div>


<div class="viewcode-block" id="mean_clip"><a class="viewcode-back" href="../../diffractem.proc2d.html#diffractem.proc2d.mean_clip">[docs]</a><span class="k">def</span> <span class="nf">mean_clip</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">sigma</span><span class="o">=</span><span class="mf">2.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Iteratively keeps only the values from the array that satisfies</span>
<span class="sd">            0 &lt; c &lt; c_mean + sigma*std </span>
<span class="sd">    and return the mean of the array. Assumes the</span>
<span class="sd">    array contains positive entries, </span>
<span class="sd">    if it does not or the array is empty returns -1 </span>
<span class="sd">    </span>
<span class="sd">    :param vector   : input vector of values.</span>
<span class="sd">    :param sigma    : number of standard deviations away from the mean </span>
<span class="sd">                    : that is allowed.</span>
<span class="sd">    :return c_mean  : mean of clipped values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">c</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">c</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">while</span> <span class="n">delta</span><span class="p">:</span>
        <span class="n">c_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">size</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">c</span> <span class="o">&lt;</span> <span class="n">c_mean</span> <span class="o">+</span> <span class="n">sigma</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">c_mean</span><span class="p">)]</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">size</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">size</span>
    <span class="k">return</span> <span class="n">c_mean</span></div>


<div class="viewcode-block" id="func_lorentz"><a class="viewcode-back" href="../../diffractem.proc2d.html#diffractem.proc2d.func_lorentz">[docs]</a><span class="k">def</span> <span class="nf">func_lorentz</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function that returns a Student&#39;t distribution or generalised Cauchy</span>
<span class="sd">    distribution in Two Dimensions(x,y).</span>
<span class="sd">    :param p    :  [amp x_0 y_0 scale shape]</span>
<span class="sd">    :param x    : x coordinate</span>
<span class="sd">    :param y    : y coordinate</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">((</span><span class="mi">1</span><span class="o">+</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">**</span><span class="mf">2.0</span> <span class="o">+</span> <span class="p">((</span><span class="n">y</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">/</span><span class="mf">2.0</span><span class="p">))</span></div>


<div class="viewcode-block" id="lorentz_fit_simple"><a class="viewcode-back" href="../../diffractem.proc2d.html#diffractem.proc2d.lorentz_fit_simple">[docs]</a><span class="nd">@loop_over_stack</span>
<span class="k">def</span> <span class="nf">lorentz_fit_simple</span><span class="p">(</span><span class="n">profile</span><span class="p">,</span> <span class="n">bin_min</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">bin_max</span> <span class="o">=</span> <span class="mi">40</span><span class="p">,</span> <span class="n">amp</span><span class="o">=</span><span class="mf">500.0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="mf">2.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simplified Lorentz fit in the 1D-radial.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">profile</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>

    <span class="c1"># section to handle arrays of profiles</span>
    <span class="k">if</span> <span class="n">profile</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">xall</span> <span class="o">=</span> <span class="p">[</span><span class="n">lorentz_fit_simple</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">bin_min</span><span class="p">,</span> <span class="n">bin_max</span><span class="p">,</span> <span class="n">amp</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">profile</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">xall</span><span class="p">)</span>

    <span class="n">param</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">amp</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">shape</span><span class="p">])</span>
    <span class="n">profile</span><span class="o">=</span><span class="n">profile</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">profile</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">profile</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">jac_lorenz_rad</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">counts</span><span class="p">):</span>
        <span class="n">fun</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="p">(</span><span class="n">r</span><span class="o">/</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span>
        <span class="n">d_amp</span> <span class="o">=</span> <span class="n">fun</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
        <span class="n">d_scale</span> <span class="o">=</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**-</span><span class="mf">3.0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">fun</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="mf">2.0</span><span class="o">-</span><span class="mf">1.0</span><span class="p">))</span>
        <span class="n">d_shape</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">fun</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="mf">2.0</span><span class="p">))</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">fun</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="n">d_amp</span><span class="p">,</span> <span class="n">d_scale</span><span class="p">,</span> <span class="n">d_shape</span><span class="p">]</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">counts</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">func_lorenz_rad</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="p">(</span><span class="n">r</span><span class="o">/</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">func_error</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">counts</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">func_lorenz_rad</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> <span class="o">-</span> <span class="n">counts</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
    <span class="n">cut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">profile</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">cut</span> <span class="o">=</span> <span class="n">cut</span><span class="p">[(</span><span class="n">cut</span> <span class="o">&gt;=</span> <span class="n">bin_min</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">cut</span> <span class="o">&lt;=</span> <span class="n">bin_max</span><span class="p">)]</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">least_squares</span><span class="p">(</span><span class="n">func_error</span><span class="p">,</span><span class="n">param</span><span class="p">,</span> <span class="n">jac_lorenz_rad</span><span class="p">,</span> 
                                 <span class="n">max_nfev</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">cut</span><span class="p">,</span><span class="n">profile</span><span class="p">[</span><span class="n">cut</span><span class="p">]),</span>
                                 <span class="n">bounds</span><span class="o">=</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">x</span></div>


<div class="viewcode-block" id="apply_virtual_detector"><a class="viewcode-back" href="../../diffractem.proc2d.html#diffractem.proc2d.apply_virtual_detector">[docs]</a><span class="k">def</span> <span class="nf">apply_virtual_detector</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="n">r_inner</span><span class="p">,</span> <span class="n">r_outer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply a &quot;virtual STEM detector&quot; to stack, with given inner and outer radii. Returns the mean value of all pixels</span>
<span class="sd">    that fall inside this annulus.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">ysize</span><span class="p">,</span> <span class="n">xsize</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">xsize</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">xsize</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">xsize</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">ysize</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">ysize</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">ysize</span><span class="p">)</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">X</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">Y</span><span class="o">**</span><span class="mi">2</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:,:]</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="p">((</span><span class="n">R</span> <span class="o">&lt;</span> <span class="n">r_outer</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">R</span> <span class="o">&gt;=</span> <span class="n">r_inner</span><span class="p">))</span> <span class="o">|</span> <span class="p">(</span><span class="n">stack</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">da</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">stack</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span></div>


<div class="viewcode-block" id="lorentz_fit"><a class="viewcode-back" href="../../diffractem.proc2d.html#diffractem.proc2d.lorentz_fit">[docs]</a><span class="nd">@loop_over_stack</span>
<span class="k">def</span> <span class="nf">lorentz_fit</span><span class="p">(</span><span class="n">img</span><span class="p">,</span><span class="n">amp</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">x_0</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">y_0</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span><span class="n">shape</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span>
                <span class="n">threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>    
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fits a Lorentz profile to find the centroid (x_0,y_0) of an image. </span>
<span class="sd">    Build upon optimize.least_squares function  which is thread safe</span>
<span class="sd">    Note: least.sq is not. Analytical Jacobian has been added.</span>
<span class="sd">    </span>
<span class="sd">    :param amp      : normalisation of Lorentzian</span>
<span class="sd">    :param x_0      : initial x position of centroid</span>
<span class="sd">    :param y_0      : initial y position of centroid</span>
<span class="sd">    :param scale    : scale of Lorentzian</span>
<span class="sd">    :param shape    : shape of Lorentzian</span>
<span class="sd">    :return         : output of least_squares</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">param</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">amp</span><span class="p">,</span><span class="n">x_0</span><span class="p">,</span><span class="n">y_0</span><span class="p">,</span><span class="n">scale</span><span class="p">,</span> <span class="n">shape</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">jac_lorentz</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
        <span class="n">radius</span> <span class="o">=</span> <span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">**</span><span class="mf">2.0</span> <span class="o">+</span> <span class="p">((</span><span class="n">y</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">**</span><span class="mf">2.0</span>
        <span class="n">func</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span><span class="o">+</span><span class="n">radius</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">/</span><span class="mf">2.0</span><span class="o">-</span><span class="mf">1.0</span><span class="p">))</span>
        <span class="n">d_amp</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span><span class="o">+</span><span class="n">radius</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">/</span><span class="mf">2.0</span><span class="p">))</span> 
        <span class="n">d_x0</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">*</span><span class="n">func</span>
        <span class="n">d_y0</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">*</span><span class="n">func</span>
        <span class="n">d_scale</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">/</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">radius</span><span class="o">*</span><span class="n">func</span>
        <span class="n">d_shape</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">((</span><span class="mi">1</span><span class="o">+</span><span class="n">radius</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">/</span><span class="mf">2.0</span><span class="p">))</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">radius</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="n">d_amp</span><span class="p">,</span> <span class="n">d_x0</span><span class="p">,</span><span class="n">d_y0</span><span class="p">,</span> <span class="n">d_scale</span><span class="p">,</span> <span class="n">d_shape</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">img</span><span class="o">**</span><span class="mf">0.5</span><span class="p">))</span>   
    <span class="k">def</span> <span class="nf">func_error</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">func_lorentz</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">cut</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">cut</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="n">img</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">img</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">cut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">img</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">least_squares</span><span class="p">(</span><span class="n">func_error</span><span class="p">,</span><span class="n">param</span><span class="p">,</span><span class="n">jac_lorentz</span><span class="p">,</span><span class="n">loss</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span>
                                 <span class="n">max_nfev</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span><span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">cut</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">cut</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">img</span><span class="p">[</span><span class="n">cut</span><span class="p">]),</span>
                                 <span class="n">bounds</span><span class="o">=</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="lorentz_fit_moving"><a class="viewcode-back" href="../../diffractem.proc2d.html#diffractem.proc2d.lorentz_fit_moving">[docs]</a><span class="k">def</span> <span class="nf">lorentz_fit_moving</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">com</span><span class="p">,</span> <span class="n">update_init</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">block_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                       <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">minimum_data</span> <span class="o">=</span> <span class="mi">500</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the center positions and peak heights from Lorentz fits for a stack </span>
<span class="sd">    of images, initializing each fit with the result of the previous one </span>
<span class="sd">    within the stack.</span>
<span class="sd">    </span>
<span class="sd">    :param img          : Image stack</span>
<span class="sd">    :param com          : Center-of-mass positions as N-by-2 array</span>
<span class="sd">    :param update_init  : If true, tries to initialize each fit with the </span>
<span class="sd">                        : results of the previous one.</span>
<span class="sd">    :param block_id     : Optional, just used for status message.</span>
<span class="sd">    :return             : Numpy array of the fit results</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">fres</span><span class="o">=</span> <span class="p">[]</span>
    <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">suppress</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">com</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="c1"># this case happens if function is called through a map_blocks</span>
        <span class="n">com</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">com</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">com</span><span class="p">)):</span>

        <span class="k">try</span><span class="p">:</span>

            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">update_init</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">success</span><span class="p">:</span>
                <span class="n">x0</span> <span class="o">=</span> <span class="p">[</span><span class="n">im</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x0</span> <span class="o">=</span> <span class="n">fres</span><span class="o">.</span><span class="n">x</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Block </span><span class="si">{}</span><span class="s1">, Img </span><span class="si">{}</span><span class="s1"> </span><span class="se">\n</span><span class="s1"> in </span><span class="si">{}</span><span class="s1">&#39;</span>\
                      <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">block_id</span><span class="p">,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">x0</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">im</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">minimum_data</span><span class="p">:</span>
                <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Not enough values&#39;</span><span class="p">)</span>


            <span class="n">fres</span> <span class="o">=</span> <span class="n">lorentz_fit</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">amp</span><span class="o">=</span><span class="n">x0</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_0</span><span class="o">=</span><span class="n">x0</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">y_0</span><span class="o">=</span><span class="n">x0</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                               <span class="n">scale</span><span class="o">=</span><span class="n">x0</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">shape</span><span class="o">=</span><span class="n">x0</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
            <span class="n">hes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">fres</span><span class="o">.</span><span class="n">jac</span><span class="p">),</span><span class="n">fres</span><span class="o">.</span><span class="n">jac</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fres</span><span class="o">.</span><span class="n">x</span><span class="p">,</span><span class="n">hes</span><span class="p">))</span>
            <span class="n">success</span> <span class="o">=</span> <span class="n">fres</span><span class="o">.</span><span class="n">success</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">dummy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
            <span class="n">dummy</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dummy</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Exception during fit of block </span><span class="si">{}</span><span class="s1">, img</span><span class="si">{}</span><span class="s1">. skipped: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">block_id</span><span class="p">,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">err</span><span class="p">))</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; out </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fres</span><span class="o">.</span><span class="n">x</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="lorentz_fast"><a class="viewcode-back" href="../../diffractem.proc2d.html#diffractem.proc2d.lorentz_fast">[docs]</a><span class="nd">@loop_over_stack</span>
<span class="k">def</span> <span class="nf">lorentz_fast</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">x_0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y_0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">amp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">threads</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fast Lorentzian fit for finding beam center; especially suited for refinement after a reasonable estimate</span>
<span class="sd">    (i.e. to a couple of pixels) has been made by another method such as truncated COM.</span>
<span class="sd">    Compared to the other fits, it always assumes a shape parameter 2 (i.e. standard Lorentzian with asymptotic x^-2).</span>
<span class="sd">    It can restrict the fit to only a small region around the initial value for the beam center, which massively speeds</span>
<span class="sd">    up the function. Also, it auto-estimates the intial parameters somewhat reasonably if nothing else is given.</span>
<span class="sd">    :param img: input image or image stack. If a stack is supplied, it is serially looped. Not accepting dask directly.</span>
<span class="sd">    :param x_0: estimated x beam center. If None, is assumed to be in the center of the image.</span>
<span class="sd">    :param y_0: analogous.</span>
<span class="sd">    :param amp: estimated peak amplitude. If None, is set to the 99.99% percentile of img.</span>
<span class="sd">    :param scale: peak HWHM estimate. Default: 5 pixels</span>
<span class="sd">    :param radius: radius of a box around x_0, y_0 where the fit is actually done. If None, the entire image is used.</span>
<span class="sd">    :param limit: If not None, the fit result is discarded if the found beam_center is further away than this value from</span>
<span class="sd">        the initial estimate.</span>
<span class="sd">    :param threshold: pixel value threshold below which pixels are ignored. Best left at 0 usually.</span>
<span class="sd">    :param threads: if True, uses scipy.optimize.least_squares, which for larger arrays (radius more than around 15)</span>
<span class="sd">        uses multithreaded function evaluation. Especially for radius &lt; 50, this may be slower than single-threaded.</span>
<span class="sd">        In this case, best set to False</span>
<span class="sd">    :param verbose: if True, a message is printed on some occasions</span>
<span class="sd">    :return: numpy array of refined parameters [amp, x0, y0, scale]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x_0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">x_0</span><span class="p">)):</span>
        <span class="n">x_0</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">y_0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">x_0</span><span class="p">)):</span>
        <span class="n">y_0</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">radius</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x_0</span> <span class="o">-</span> <span class="n">radius</span><span class="p">)</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x_0</span> <span class="o">+</span> <span class="n">radius</span><span class="p">)</span>
        <span class="n">y1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">y_0</span> <span class="o">-</span> <span class="n">radius</span><span class="p">)</span>
        <span class="n">y2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">y_0</span> <span class="o">+</span> <span class="n">radius</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">x1</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">x2</span> <span class="o">&gt;</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="n">y1</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">y2</span> <span class="o">&gt;</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Cannot cut image around peak. Centering.&#39;</span><span class="p">)</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">radius</span><span class="p">)</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">radius</span><span class="p">)</span>
            <span class="n">y1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">radius</span><span class="p">)</span>
            <span class="n">y2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">radius</span><span class="p">)</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="p">[</span><span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">y1</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">amp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="mi">99</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Something weird: </span><span class="si">{}</span><span class="s1"> Cannot get image percentile. Img size is </span><span class="si">{}</span><span class="s1">. Skipping.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">x_0</span><span class="p">,</span> <span class="n">y_0</span><span class="p">,</span> <span class="n">scale</span><span class="p">])</span>

    <span class="n">cut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">img</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">cut</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">x1</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">cut</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">y1</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="p">[</span><span class="n">cut</span><span class="p">]</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="n">img</span> <span class="o">**</span> <span class="mf">0.5</span>

    <span class="n">function</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">**</span> <span class="mf">2.0</span> <span class="o">+</span> <span class="p">((</span><span class="n">y</span> <span class="o">-</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">**</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">error</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="p">(</span><span class="n">function</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">-</span> <span class="n">img</span><span class="p">)</span> <span class="o">/</span> <span class="n">norm</span>

    <span class="k">def</span> <span class="nf">jacobian</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
        <span class="n">radius</span> <span class="o">=</span> <span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">**</span> <span class="mf">2.0</span> <span class="o">+</span> <span class="p">((</span><span class="n">y</span> <span class="o">-</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">**</span> <span class="mf">2.0</span>
        <span class="n">func</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="n">radius</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mf">2.0</span><span class="p">))</span>
        <span class="n">d_amp</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="n">radius</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">))</span>
        <span class="n">d_x0</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">**</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">func</span>
        <span class="n">d_y0</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">**</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">func</span>
        <span class="n">d_scale</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">func</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">d_amp</span> <span class="o">/</span> <span class="n">norm</span><span class="p">,</span> <span class="n">d_x0</span> <span class="o">/</span> <span class="n">norm</span><span class="p">,</span> <span class="n">d_y0</span> <span class="o">/</span> <span class="n">norm</span><span class="p">,</span> <span class="n">d_scale</span> <span class="o">/</span> <span class="n">norm</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="n">param</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">amp</span><span class="p">,</span> <span class="n">x_0</span><span class="p">,</span> <span class="n">y_0</span><span class="p">,</span> <span class="n">scale</span><span class="p">])</span>
    <span class="c1"># print(param)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">threads</span><span class="p">:</span>
            <span class="c1"># new algorithm: uses multithreaded evaluation sometimes, which is not always desired!</span>
            <span class="c1"># out = optimize.least_squares(error, param, jac=jacobian, loss=&#39;linear&#39;,</span>
            <span class="c1">#                             max_nfev=1000, method=&#39;lm&#39;, verbose=0,</span>
            <span class="c1">#                             x_scale=(amp, 1, 1, 5)).x</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">least_squares</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">loss</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span>
                                        <span class="n">max_nfev</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;lm&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                        <span class="n">x_scale</span><span class="o">=</span><span class="p">(</span><span class="n">amp</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span><span class="n">xtol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">)</span><span class="o">.</span><span class="n">x</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># old algorithm never uses multithreading. May be better.</span>
            <span class="c1"># out = optimize.leastsq(error, param, Dfun=jacobian)[0]</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">leastsq</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">xtol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
        <span class="c1"># print(param)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Fitting did not work: </span><span class="si">{}</span><span class="s1"> with initial parameters </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">param</span><span class="p">))</span>
        <span class="c1"># raise err</span>
        <span class="k">return</span> <span class="n">param</span>

    <span class="n">change</span> <span class="o">=</span> <span class="n">out</span> <span class="o">-</span> <span class="n">param</span>
    <span class="k">if</span> <span class="n">limit</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">change</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">limit</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Found out of limit fit result </span><span class="si">{}</span><span class="s1">. Reverting to init values </span><span class="si">{}</span><span class="s1">.&#39;</span> \
                  <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="n">param</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]))</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">param</span>

    <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="center_of_mass"><a class="viewcode-back" href="../../diffractem.proc2d.html#diffractem.proc2d.center_of_mass">[docs]</a><span class="nd">@loop_over_stack</span>
<span class="k">def</span> <span class="nf">center_of_mass</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the center of mass of an image using all the pixels larger than </span>
<span class="sd">    the threshold. Automatically skips values below threshold. Fast for sparse </span>
<span class="sd">    images.</span>
<span class="sd">    :param img              : Input image</span>
<span class="sd">    :param threshold        : minimum pixel value to include</span>
<span class="sd">    :return (x0,y0)         :Return location</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">img</span><span class="o">&gt;</span><span class="n">threshold</span><span class="p">)</span>
    <span class="p">(</span><span class="n">y0</span><span class="p">,</span><span class="n">x0</span><span class="p">)</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">img</span><span class="p">[</span><span class="n">cut</span><span class="p">]</span><span class="o">*</span><span class="n">cut</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">img</span><span class="p">[</span><span class="n">cut</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x0</span><span class="p">,</span><span class="n">y0</span><span class="p">])</span></div>


<div class="viewcode-block" id="center_of_mass2"><a class="viewcode-back" href="../../diffractem.proc2d.html#diffractem.proc2d.center_of_mass2">[docs]</a><span class="k">def</span> <span class="nf">center_of_mass2</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Alternative COM function, acting on 3D arrays directly, </span>
<span class="sd">    including lazy dask arrays. Tends to be slower than center_of_mass for </span>
<span class="sd">    sparse images with high thresholds, otherwise faster.</span>
<span class="sd">    :param img: </span>
<span class="sd">    :return: </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> 
                               <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">imgt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">img</span> <span class="o">&gt;=</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">imgt</span> <span class="o">=</span> <span class="n">img</span>

    <span class="n">com</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">imgt</span><span class="p">,</span> <span class="n">vec</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="o">/</span><span class="n">imgt</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="c1">#if img.ndim &lt; 3:</span>
    <span class="c1">#   com = com.squeeze()</span>

    <span class="k">return</span> <span class="n">com</span></div>


<div class="viewcode-block" id="get_peaks"><a class="viewcode-back" href="../../diffractem.proc2d.html#diffractem.proc2d.get_peaks">[docs]</a><span class="nd">@loop_over_stack</span>
<span class="k">def</span> <span class="nf">get_peaks</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">x0</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">y0</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">max_peaks</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span> 
            <span class="n">pxmask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">min_snr</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">4.</span><span class="p">,</span> <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
              <span class="n">min_pix_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">max_pix_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="n">local_bg_radius</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
             <span class="n">min_res</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">max_res</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span> <span class="n">as_dict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Find peaks in diffraction pattern using the peakfinder8 algorithm as used in</span>
<span class="sd">    CrystFEL, OnDA and Cheetah. Requires installation of OnDA.</span>
<span class="sd">    </span>
<span class="sd">    Arguments:</span>
<span class="sd">        img -- Input image or stack</span>
<span class="sd">        x0 -- Beam center along x</span>
<span class="sd">        y0 -- Beam center along y</span>
<span class="sd">    </span>
<span class="sd">    Keyword Arguments:</span>
<span class="sd">        max_peaks {int} -- Maximum number of peaks (default: {500})</span>
<span class="sd">        pxmask {float} -- Pixel mask. Pixels with value greater than 0 are ignored. (default: {None})</span>
<span class="sd">        min_snr {float} -- minimum signal-to-noise ratio for peak detection (default: {4})</span>
<span class="sd">        threshold {float} -- minimum pixel value for peak detection (default: {8})</span>
<span class="sd">        min_pix_count {int} -- minimum size of a peak in pixels (default: {2})</span>
<span class="sd">        max_pix_count {int} -- maximum size of a peak in pixels (default: {20})</span>
<span class="sd">        local_bg_radius {int} -- radius for the estimation of the local background in pixels (default: {3})</span>
<span class="sd">        min_res {int} --  minimum resolution for a peak in pixels (default: {0})</span>
<span class="sd">        max_res {int} -- maximum resolution for a peak in pixels (default: {500})</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        [ndarray] -- Vector of shape (3 * pkmax) + 1, or stack thereof (matrix). First {pkmax} entries are peak</span>
<span class="sd">        x postions, then {pkmax} y positions, {pkmax} intensities, and finally the number of peaks.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span> <span class="nn">onda.algorithms.crystallography_algorithms</span> <span class="kn">import</span> <span class="n">Peakfinder8PeakDetection</span>

    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">range</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">R</span> <span class="o">=</span> <span class="p">(((</span><span class="n">X</span><span class="o">-</span><span class="n">x0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">Y</span><span class="o">-</span><span class="n">y0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    
    <span class="n">pf</span> <span class="o">=</span> <span class="n">Peakfinder8PeakDetection</span><span class="p">(</span><span class="n">max_num_peaks</span><span class="o">=</span><span class="n">max_peaks</span><span class="p">,</span>
                              <span class="n">asic_nx</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">asic_ny</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                              <span class="n">nasics_x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nasics_y</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                              <span class="n">adc_threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span> <span class="n">minimum_snr</span><span class="o">=</span><span class="n">min_snr</span><span class="p">,</span>
                              <span class="n">min_pixel_count</span><span class="o">=</span><span class="n">min_pix_count</span><span class="p">,</span> <span class="n">max_pixel_count</span><span class="o">=</span><span class="n">max_pix_count</span><span class="p">,</span>
                              <span class="n">local_bg_radius</span><span class="o">=</span><span class="n">local_bg_radius</span><span class="p">,</span>
                              <span class="n">min_res</span><span class="o">=</span><span class="n">min_res</span><span class="p">,</span> <span class="n">max_res</span><span class="o">=</span><span class="n">max_res</span><span class="p">,</span>
                              <span class="n">bad_pixel_map_filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">bad_pixel_map_hdf5_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">radius_pixel_map</span><span class="o">=</span><span class="n">R</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">pxmask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pf</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">pxmask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>

    <span class="n">pks</span> <span class="o">=</span> <span class="n">pf</span><span class="o">.</span><span class="n">find_peaks</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
    <span class="n">fill</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">max_peaks</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">pks</span><span class="o">.</span><span class="n">fs</span><span class="p">))</span>
    
    <span class="k">if</span> <span class="n">as_dict</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;peakXPosRaw&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pks</span><span class="o">.</span><span class="n">fs</span> <span class="o">+</span> <span class="n">fill</span><span class="p">),</span>
                <span class="s1">&#39;peakYPosRaw&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pks</span><span class="o">.</span><span class="n">ss</span> <span class="o">+</span> <span class="n">fill</span><span class="p">),</span>
                <span class="s1">&#39;peakTotalIntensity&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pks</span><span class="o">.</span><span class="n">intensity</span> <span class="o">+</span> <span class="n">fill</span><span class="p">),</span>
                <span class="s1">&#39;nPeaks&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pks</span><span class="o">.</span><span class="n">fs</span><span class="p">))}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pks</span><span class="o">.</span><span class="n">fs</span> <span class="o">+</span> <span class="n">fill</span> <span class="o">+</span> <span class="n">pks</span><span class="o">.</span><span class="n">ss</span> <span class="o">+</span> <span class="n">fill</span> <span class="o">+</span> <span class="n">pks</span><span class="o">.</span><span class="n">intensity</span> <span class="o">+</span> <span class="n">fill</span> <span class="o">+</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">pks</span><span class="o">.</span><span class="n">fs</span><span class="p">)])</span></div>

<div class="viewcode-block" id="radial_proj"><a class="viewcode-back" href="../../diffractem.proc2d.html#diffractem.proc2d.radial_proj">[docs]</a><span class="nd">@loop_over_stack</span>
<span class="k">def</span> <span class="nf">radial_proj</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">x0</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y0</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
    <span class="n">my_func</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">,</span> 
    <span class="n">min_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">600</span><span class="p">,</span> <span class="n">max_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">850</span><span class="p">,</span> <span class="n">filter_len</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies the function to the azimuthal bins of the image around </span>
<span class="sd">    the center (x0,y0) for each integer radius and returns the result </span>
<span class="sd">    in a np.array of size max_size. Skips values that are set to -1 or nan.</span>
<span class="sd">    :param img: input image</span>
<span class="sd">    :param x0: x center of mass of image</span>
<span class="sd">    :param y0: y center of mass of image</span>
<span class="sd">    :param my_func: function to be applied to the bins, or list thereof</span>
<span class="sd">    :param min_size: minimum length of output array</span>
<span class="sd">    :param max_size: maximum length of output array</span>
<span class="sd">    :param filter_len: kernel size of median filter applied after profile calculation.</span>
<span class="sd">        filter_len must be odd, and filtering is at the moment incompatible with multiple functions</span>
<span class="sd">    :return result: array of function returns on each radius.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># BUG: median filter </span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">my_func</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">my_func</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">filter_len</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;radial_proj with filtering only works if a single function is used. Sorry.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">filter_len</span><span class="o">//</span><span class="mi">2</span> <span class="o">==</span> <span class="n">filter_len</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;filter_len must be odd.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">my_func</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">my_func</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">my_func</span> <span class="o">=</span> <span class="p">[</span><span class="n">my_func</span><span class="p">]</span>

    <span class="p">(</span><span class="n">ylen</span><span class="p">,</span><span class="n">xlen</span><span class="p">)</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span>
    <span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ogrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">ylen</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">xlen</span><span class="p">]</span>
    <span class="c1">#print(x0,y0)</span>

    <span class="n">x0</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span> <span class="k">if</span> <span class="n">x0</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
    <span class="n">y0</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span> <span class="k">if</span> <span class="n">y0</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">y0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">y0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">x0</span><span class="o">&lt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">x0</span><span class="o">&gt;=</span><span class="n">xlen</span> <span class="ow">or</span> <span class="n">y0</span><span class="o">&lt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">y0</span><span class="o">&gt;=</span><span class="n">ylen</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">max_size</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">my_func</span><span class="p">))</span>
        <span class="n">result</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="n">radius</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(((</span><span class="n">x</span><span class="o">-</span><span class="n">x0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">y0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span> <span class="c1"># radius coordinate of each pixel</span>
                <span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">))</span>
    <span class="n">center</span> <span class="o">=</span> <span class="n">img</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">y0</span><span class="p">)),</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">x0</span><span class="p">))]</span>
    <span class="n">radius</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">img</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">img</span><span class="p">))]</span><span class="o">=</span><span class="mi">0</span> <span class="c1"># ignore bad pixels by setting radius to zero</span>
    <span class="n">row</span> <span class="o">=</span> <span class="n">radius</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">))</span>
    <span class="n">mat</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">img</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)))</span>

    <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="mi">1</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">radius</span><span class="p">),</span> <span class="n">max_size</span><span class="p">])</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">rng</span><span class="p">,</span> <span class="n">min_size</span><span class="p">])</span>
    <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">size</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">my_func</span><span class="p">))</span>
    <span class="n">fstart</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">my_func</span><span class="p">),</span> <span class="n">size</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">rng</span><span class="p">):</span>
        <span class="n">rbin_data</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>

        <span class="k">if</span> <span class="n">rbin_data</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="n">r</span> <span class="o">+</span> <span class="n">fstart</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">fn</span><span class="p">(</span><span class="n">rbin_data</span><span class="p">)</span> <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">my_func</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">center</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">result</span><span class="p">[</span><span class="n">fstart</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">fn</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>  <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">my_func</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">filter_len</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>       
        <span class="n">result</span><span class="p">[</span><span class="n">filter_len</span><span class="o">//</span><span class="mi">2</span><span class="p">:]</span> <span class="o">=</span> <span class="n">median_filter</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">filter_len</span><span class="p">)[</span><span class="n">filter_len</span><span class="o">//</span><span class="mi">2</span><span class="p">:]</span>

    <span class="k">assert</span> <span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">min_size</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">max_size</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="cut_peaks"><a class="viewcode-back" href="../../diffractem.proc2d.html#diffractem.proc2d.cut_peaks">[docs]</a><span class="nd">@loop_over_stack</span>
<span class="k">def</span> <span class="nf">cut_peaks</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">nPeaks</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">peakXPosRaw</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">peakYPosRaw</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">replaceval</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Cuts peaks out of an image and replaces them with replaceval.</span>
<span class="sd">    Peak positions are provided in CXI format.</span>
<span class="sd">    </span>
<span class="sd">    Arguments:</span>
<span class="sd">        img {np.array} -- Input image</span>
<span class="sd">        nPeaks {np.array} -- Number of peaks</span>
<span class="sd">        peakXPosRaw {np.array} -- X position of peaks</span>
<span class="sd">        peakYPosRaw {np.array} -- Y position of peaks</span>
<span class="sd">    </span>
<span class="sd">    Keyword Arguments:</span>
<span class="sd">        radius {int} -- Radius in pixel of peak cut-out region (default: {2})</span>
<span class="sd">        replaceval {int} -- Value to change the cut pixels to (default: {-1})</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        [as img] -- Image with peaks cut out</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#print(nPeaks)</span>
    <span class="n">nPeaks</span> <span class="o">=</span> <span class="n">nPeaks</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="n">peakXPosRaw</span> <span class="o">=</span> <span class="n">peakXPosRaw</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="n">peakYPosRaw</span> <span class="o">=</span> <span class="n">peakYPosRaw</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="c1">#print(peakYPosRaw[:nPeaks.squeeze()])</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">img</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
    <span class="c1">#print(img.shape)</span>
    <span class="n">mask</span><span class="p">[(</span><span class="n">peakYPosRaw</span><span class="p">[:</span><span class="n">nPeaks</span><span class="p">])</span><span class="o">.</span><span class="n">round</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="n">peakXPosRaw</span><span class="p">[:</span><span class="n">nPeaks</span><span class="p">])</span><span class="o">.</span><span class="n">round</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">binary_dilation</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span><span class="n">disk</span><span class="p">(</span><span class="n">radius</span><span class="p">),</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">img_nopeaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span><span class="n">replaceval</span><span class="p">,</span><span class="n">img</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">img_nopeaks</span></div>

<div class="viewcode-block" id="strip_img"><a class="viewcode-back" href="../../diffractem.proc2d.html#diffractem.proc2d.strip_img">[docs]</a><span class="nd">@loop_over_stack</span>
<span class="k">def</span> <span class="nf">strip_img</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">prof</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pxmask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">truncate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
    <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keep_edge_offset</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">replaceval</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">interp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given an image, center coordinate(x0,y0) and a radial profile, removes the</span>
<span class="sd">    radial profile from the image.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">y0</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="n">prof</span> <span class="o">=</span> <span class="n">prof</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>   <span class="c1"># background profile</span>
    <span class="n">ylen</span><span class="p">,</span><span class="n">xlen</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">y</span><span class="p">,</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ogrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">ylen</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">xlen</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">interpolate</span><span class="p">:</span>
        <span class="n">iprof</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">prof</span><span class="p">)),</span> <span class="n">prof</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">radius</span> <span class="o">=</span> <span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">x0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">y0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
        <span class="n">profile</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">radius</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">))</span>
        <span class="n">bkg</span> <span class="o">=</span> <span class="n">iprof</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">radius</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(((</span><span class="n">x</span><span class="o">-</span><span class="n">x0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">y0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">profile</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">radius</span><span class="p">))</span>
        <span class="n">comlen</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">profile</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">prof</span><span class="p">))</span>
        <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">profile</span><span class="p">[:</span><span class="n">comlen</span><span class="p">],</span> <span class="n">prof</span><span class="p">[:</span><span class="n">comlen</span><span class="p">])</span>
        <span class="n">bkg</span> <span class="o">=</span> <span class="n">profile</span><span class="p">[</span><span class="n">radius</span><span class="p">]</span>

    <span class="n">img_out</span> <span class="o">=</span> <span class="n">img</span> <span class="o">-</span> <span class="n">bkg</span> <span class="o">+</span> <span class="n">offset</span> <span class="k">if</span> <span class="n">keep_edge_offset</span> <span class="k">else</span> <span class="n">img</span> <span class="o">-</span> <span class="n">bkg</span>

    <span class="n">dtype</span> <span class="o">=</span> <span class="n">img_out</span><span class="o">.</span><span class="n">dtype</span> <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">dtype</span>

    <span class="k">if</span> <span class="n">replaceval</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">replaceval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">)</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">if</span> <span class="n">truncate</span><span class="p">:</span>
        <span class="n">img_out</span><span class="p">[</span><span class="n">img_out</span> <span class="o">&lt;</span> <span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">replaceval</span>

    <span class="k">if</span> <span class="n">pxmask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">img_out</span> <span class="o">=</span> <span class="n">correct_dead_pixels</span><span class="p">(</span><span class="n">img_out</span><span class="p">,</span> <span class="n">pxmask</span><span class="p">,</span> <span class="s1">&#39;replace&#39;</span><span class="p">,</span> 
                                      <span class="n">replace_val</span><span class="o">=</span><span class="n">replaceval</span><span class="p">,</span> <span class="n">mask_gaps</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">img_out</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
            <span class="n">img_out</span> <span class="o">=</span> <span class="n">img_out</span><span class="o">.</span><span class="n">round</span><span class="p">()</span>
        <span class="n">img_out</span> <span class="o">=</span> <span class="n">img_out</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">img_out</span></div>


<div class="viewcode-block" id="remove_background"><a class="viewcode-back" href="../../diffractem.proc2d.html#diffractem.proc2d.remove_background">[docs]</a><span class="nd">@loop_over_stack</span>
<span class="k">def</span> <span class="nf">remove_background</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">x0</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">y0</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">nPeaks</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">peakXPosRaw</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">peakYPosRaw</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
    <span class="n">peak_radius</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">filter_len</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">rfunc</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">,</span>
    <span class="n">pxmask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">truncate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>  <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span> <span class="ow">and</span> <span class="n">offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Removing background on an integer image with zero offset will likely cause trouble later on.&#39;</span><span class="p">)</span>

    <span class="n">replace_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">)</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>

    <span class="n">x0</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span> <span class="k">if</span> <span class="n">x0</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">x0</span>
    <span class="n">y0</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span> <span class="k">if</span> <span class="n">y0</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">y0</span>

    <span class="n">pxmask</span> <span class="o">=</span> <span class="p">((</span><span class="n">img</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">img</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="k">if</span> <span class="n">pxmask</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">pxmask</span>
    <span class="c1">#print((pxmask == 0).sum())</span>

    <span class="c1">#print(nPeaks)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">nPeaks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">nPeaks</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">img_nopk</span> <span class="o">=</span> <span class="n">cut_peaks</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">nPeaks</span><span class="p">,</span> <span class="n">peakXPosRaw</span><span class="p">,</span> <span class="n">peakYPosRaw</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="n">peak_radius</span><span class="p">,</span> <span class="n">replaceval</span><span class="o">=</span><span class="n">replace_val</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">img_nopk</span> <span class="o">=</span> <span class="n">img</span>

    <span class="n">r0</span> <span class="o">=</span> <span class="n">radial_proj</span><span class="p">(</span><span class="n">img_nopk</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">my_func</span><span class="o">=</span><span class="n">rfunc</span><span class="p">,</span> <span class="n">filter_len</span><span class="o">=</span><span class="n">filter_len</span><span class="p">)</span>
    <span class="n">img_nobg</span> <span class="o">=</span> <span class="n">strip_img</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="n">pxmask</span><span class="o">=</span><span class="n">pxmask</span><span class="p">,</span> <span class="n">truncate</span><span class="o">=</span><span class="n">truncate</span><span class="p">,</span> 
        <span class="n">keep_edge_offset</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">interp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">img_nobg</span></div>


<span class="nd">@jit</span><span class="p">([</span><span class="s1">&#39;int32[:,:](int32[:,:], float64, float64, int64, int64, int64)&#39;</span><span class="p">,</span>
      <span class="s1">&#39;int16[:,:](int16[:,:], float64, float64, int64, int64, int64)&#39;</span><span class="p">,</span>
      <span class="s1">&#39;int64[:,:](int64[:,:], float64, float64, int64, int64, int64)&#39;</span><span class="p">,</span>
      <span class="s1">&#39;float64[:,:](float64[:,:], float64, float64, int64, int64, float64)&#39;</span><span class="p">,</span>
      <span class="s1">&#39;float32[:,:](float32[:,:], float64, float64, int64, int64, float64)&#39;</span><span class="p">],</span>
     <span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># ahead-of-time compilation using numba. Otherwise painfully slow.</span>
<span class="k">def</span> <span class="nf">_center_sgl_image</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">xsize</span><span class="p">,</span> <span class="n">ysize</span><span class="p">,</span> <span class="n">padval</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Shits a single image, such that the original image coordinates x0, y0 are in the center of the</span>
<span class="sd">    output image, which as a size of xsize, ysize.</span>
<span class="sd">    IMPORTANT NOTE: the coordinates in this function refer to pixel centers, not pixel corners</span>
<span class="sd">    (as e.g. CrystFELs peak positions). I.e., if shifting based on CrystFEL output or similar, the shifts</span>
<span class="sd">    must be increased by 0.5.</span>
<span class="sd">    :param img: input image (2D array, must be integer)</span>
<span class="sd">    :param x0: x coordinate in img to be in center of output image</span>
<span class="sd">    :param y0: y coordinate in img to be in center of output image</span>
<span class="sd">    :param xsize: x size of output image</span>
<span class="sd">    :param ysize: y size of output image</span>
<span class="sd">    :param padval: padding value of undefined pixels in output image</span>
<span class="sd">    :return: output image of shape (ysize, xsize)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">simg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">padval</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">ysize</span><span class="p">,</span> <span class="n">xsize</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="c1">#int64=np.int64</span>
    <span class="c1">#x0 -= 0.5</span>
    <span class="n">xin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">xsize</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">xsize</span> <span class="o">/</span> <span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="n">x0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">int64</span><span class="p">)</span>  <span class="c1"># initial coordinate system</span>
    <span class="n">xout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">simg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">int64</span><span class="p">)</span>  <span class="c1"># now start constructing the final coordinate system</span>
    <span class="k">if</span> <span class="n">xin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">xout</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">xin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">xin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">xin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">xout</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">xout</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">xin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">xin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">yin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">ysize</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ysize</span> <span class="o">/</span> <span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="n">y0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">yout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">simg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">int64</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">yin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">yout</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">yin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">yin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">yin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">yout</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">yout</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">yin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">yin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1">#print(xin,xout,yin,yout)</span>
    <span class="n">simg</span><span class="p">[</span><span class="n">yout</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">yout</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">xout</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">xout</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">img</span><span class="p">[</span><span class="n">yin</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">yin</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">xin</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">xin</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">simg</span>


<div class="viewcode-block" id="center_image"><a class="viewcode-back" href="../../diffractem.proc2d.html#diffractem.proc2d.center_image">[docs]</a><span class="k">def</span> <span class="nf">center_image</span><span class="p">(</span><span class="n">imgs</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">xsize</span><span class="p">,</span> <span class="n">ysize</span><span class="p">,</span> <span class="n">padval</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Centers a whole stack of images. See center_sgl_image for details... now, imgs is a 3D stack,</span>
<span class="sd">    x0 and y0 are 1d arrays. imgs can be a dask array, map_blocks is automatically invoked then</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">imgs</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">):</span>
        <span class="c1"># Preprocess arguments and call function again, using map_blocks along the stack direction</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">x0</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">y0</span> <span class="o">=</span> <span class="n">y0</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">):</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="p">(</span><span class="n">imgs</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">):</span>
            <span class="n">y0</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="p">(</span><span class="n">imgs</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">imgs</span><span class="o">.</span><span class="n">map_blocks</span><span class="p">(</span><span class="n">center_image</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">xsize</span><span class="p">,</span> <span class="n">ysize</span><span class="p">,</span> <span class="n">padval</span><span class="p">,</span>
                               <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="n">imgs</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ysize</span><span class="p">,</span> <span class="n">xsize</span><span class="p">),</span>
                               <span class="n">dtype</span><span class="o">=</span><span class="n">imgs</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># condition the input arguments a bit...</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="n">x0</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">x0</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x0</span><span class="p">)]</span> <span class="o">=</span> <span class="n">imgs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">y0</span> <span class="o">=</span> <span class="n">y0</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">y0</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">y0</span><span class="p">)]</span> <span class="o">=</span> <span class="n">imgs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">simgs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">padval</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">imgs</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">imgs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ysize</span><span class="p">,</span> <span class="n">xsize</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">imgs</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">parallel</span><span class="p">:</span>
        <span class="n">it</span> <span class="o">=</span> <span class="n">prange</span><span class="p">(</span><span class="n">imgs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># uses numba&#39;s prange for parallelization</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">it</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">imgs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
        <span class="n">simg</span> <span class="o">=</span> <span class="n">_center_sgl_image</span><span class="p">(</span><span class="n">imgs</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">x0</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">y0</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">xsize</span><span class="p">,</span> <span class="n">ysize</span><span class="p">,</span> <span class="n">padval</span><span class="p">)</span>
        <span class="n">simgs</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">simg</span>

    <span class="k">return</span> <span class="n">simgs</span></div>


<div class="viewcode-block" id="apply_saturation_correction"><a class="viewcode-back" href="../../diffractem.proc2d.html#diffractem.proc2d.apply_saturation_correction">[docs]</a><span class="k">def</span> <span class="nf">apply_saturation_correction</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">exp_time</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">dead_time</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.9e-3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Apply detector correction function to image. Should ideally be done even before flatfield.</span>
<span class="sd">    Uses a 5th order polynomial approximation to the Lambert function, which is appropriate</span>
<span class="sd">    for a paralyzable detector, up to the point where its signal starts inverting (which is where</span>
<span class="sd">    nothing can be done anymore)</span>
<span class="sd">    </span>
<span class="sd">    Arguments:</span>
<span class="sd">        img {np.ndarray} -- Input image or image stack</span>
<span class="sd">        exp {float} -- Exposure time in ms</span>
<span class="sd">    </span>
<span class="sd">    Keyword Arguments:</span>
<span class="sd">        dead_time {float} -- Dead time of detector in ms (default: {1.9e-3})</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lambert</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">-</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">8</span><span class="o">/</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">125</span><span class="o">/</span><span class="mi">24</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">5</span>
    <span class="n">satcorr</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">y</span><span class="p">,</span> <span class="n">sat</span><span class="p">:</span> <span class="o">-</span><span class="n">lambert</span><span class="p">(</span><span class="o">-</span><span class="n">sat</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="n">sat</span> <span class="c1"># saturation parameter: dead time/exposure time</span>

    <span class="k">return</span> <span class="n">satcorr</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">dead_time</span><span class="o">/</span><span class="n">exp_time</span><span class="p">)</span></div>


<div class="viewcode-block" id="apply_flatfield"><a class="viewcode-back" href="../../diffractem.proc2d.html#diffractem.proc2d.apply_flatfield">[docs]</a><span class="k">def</span> <span class="nf">apply_flatfield</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keep_type</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ref_smooth_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                    <span class="n">normalize_reference</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies a flatfield (gain reference) image to a single image or stack.</span>
<span class="sd">    :param img              : Input image or image stack</span>
<span class="sd">    :param reference        : Gain reference image (usually normalized to 1)</span>
<span class="sd">    :param keep_type        : Keep integer data type of the initial image, </span>
<span class="sd">                            : even if it requires rounding</span>
<span class="sd">    :param ref_smooth_range : Optionally, smooth the reference image out</span>
<span class="sd">    :param normalize_reference</span>
<span class="sd">                            : Optionally, re-normalize the image</span>
<span class="sd">    :param kwargs           : Nothing, currently</span>
<span class="sd">    :return                 : Corrected image</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">tifffile</span><span class="o">.</span><span class="n">TiffFile</span><span class="p">(</span><span class="n">reference</span><span class="p">)</span> <span class="k">as</span> <span class="n">tif</span><span class="p">:</span>
            <span class="n">reference</span> <span class="o">=</span> <span class="n">tif</span><span class="o">.</span><span class="n">asarray</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">reference</span> <span class="o">=</span> <span class="n">reference</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;reference must be either numpy array or TIF filename&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">normalize_reference</span><span class="p">:</span>
        <span class="n">reference</span> <span class="o">=</span> <span class="n">reference</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">reference</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">ref_smooth_range</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">reference</span> <span class="o">=</span> <span class="n">convolve</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">Gaussian2DKernel</span><span class="p">(</span><span class="n">ref_smooth_range</span><span class="p">),</span>
                             <span class="n">boundary</span><span class="o">=</span><span class="s1">&#39;extend&#39;</span><span class="p">,</span> <span class="n">nan_treatment</span><span class="o">=</span><span class="s1">&#39;interpolate&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">reference</span> <span class="o">=</span> <span class="n">reference</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">reference</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span><span class="n">reference</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

    <span class="k">if</span> <span class="n">keep_type</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">img</span><span class="o">/</span><span class="n">reference</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">img</span><span class="o">/</span><span class="n">reference</span></div>


<div class="viewcode-block" id="correct_dead_pixels"><a class="viewcode-back" href="../../diffractem.proc2d.html#diffractem.proc2d.correct_dead_pixels">[docs]</a><span class="k">def</span> <span class="nf">correct_dead_pixels</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pxmask</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> 
                        <span class="n">strategy</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;interpolate&#39;</span><span class="p">,</span> 
                        <span class="n">interp_range</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">replace_val</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                        <span class="n">mask_gaps</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">edge_mask_x</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">70</span><span class="p">,</span> <span class="n">edge_mask_y</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Corrects a set of images for dead pixels by either replacing values with a </span>
<span class="sd">    constant (e.g. for Diffraction Analysis with mask support), or </span>
<span class="sd">    interpolation from a Gaussian-smoothed version of the image (e.g. for SPA </span>
<span class="sd">    or general imaging). It requires a binary array (pxmask) which is </span>
<span class="sd">    1/255/True for dead pixels. The function accepts a 3D array where the first </span>
<span class="sd">    dimension corresponds to a stack/movie. The convolution used for the Gauss </span>
<span class="sd">    filter is taken from the astropy package, which allows to ignore NaNs. </span>
<span class="sd">    While the function does support stacks, this may be slow, especially with </span>
<span class="sd">    interpolation. In these cases, better apply to single images in parallel </span>
<span class="sd">    (e.g. using diffractem.compute.process_stack).</span>
<span class="sd">    :param img      : the image or image stack (first dimension is stack) </span>
<span class="sd">                    : to process. For replace strategy it can be a dask array.</span>
<span class="sd">    :param pxmask   : pixel mask with dimension of the image, or TIF file </span>
<span class="sd">                    : containing pixel mask</span>
<span class="sd">    :param strategy : &#39;replace&#39; with constant or &#39;interpolate&#39; with smoothed </span>
<span class="sd">                    : adjacent region</span>
<span class="sd">    :param interp_range : range over which interpolation pixels are calculated </span>
<span class="sd">                    : (if strategy is &#39;interpolate&#39;)</span>
<span class="sd">    :param replace_val: value with which dead pixels are replaced </span>
<span class="sd">                    : (if strategy is &#39;replace&#39;)</span>
<span class="sd">    :param mask_gaps: treat the interpolated pixels between the panels as dead</span>
<span class="sd">    :param edge_mask_[x/y]: number of pixels at outer [left/right]/[upper/lower] edges to treat as </span>
<span class="sd">                    : dead (because of shading)</span>
<span class="sd">    :param kwargs   : not doing anything so far</span>
<span class="sd">    :return         : corrected image</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">assert</span> <span class="n">strategy</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;interpolate&#39;</span><span class="p">,</span> <span class="s1">&#39;replace&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">replace_val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">replace_val</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pxmask</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">pxmask</span> <span class="o">=</span> <span class="n">imread</span><span class="p">(</span><span class="n">pxmask</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pxmask</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pxmask</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">):</span>
        <span class="n">pxmask</span> <span class="o">=</span> <span class="n">pxmask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;pxmask must be either Numpy array, or TIF file name&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mask_gaps</span><span class="p">:</span>
        <span class="n">pxmask</span><span class="p">[</span><span class="n">gap_pixels</span><span class="p">()]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">edge_mask_x</span><span class="p">:</span>
        <span class="n">pxmask</span><span class="p">[:,</span> <span class="p">:</span><span class="n">edge_mask_x</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">pxmask</span><span class="p">[:,</span> <span class="o">-</span><span class="n">edge_mask_x</span><span class="p">:]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">edge_mask_y</span><span class="p">:</span>
        <span class="n">pxmask</span><span class="p">[:</span><span class="n">edge_mask_y</span><span class="p">,:]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">pxmask</span><span class="p">[</span><span class="o">-</span><span class="n">edge_mask_y</span><span class="p">:,:]</span> <span class="o">=</span> <span class="kc">True</span>
        
    <span class="k">if</span> <span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;interpolate&#39;</span><span class="p">:</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">and</span> <span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;interpolate&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">correct_dead_pixels</span><span class="p">(</span><span class="n">theImg</span><span class="p">,</span> <span class="n">pxmask</span><span class="o">=</span><span class="n">pxmask</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s1">&#39;interpolate&#39;</span><span class="p">,</span> <span class="n">interp_range</span><span class="o">=</span><span class="n">interp_range</span><span class="p">,</span><span class="n">replace_val</span><span class="o">=</span><span class="n">replace_val</span><span class="p">)</span> <span class="k">for</span> <span class="n">theImg</span> <span class="ow">in</span> <span class="n">img</span><span class="p">])</span>

        <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">img_flt</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">img_flt</span><span class="p">[</span><span class="n">pxmask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">kernel</span> <span class="o">=</span> <span class="n">Gaussian2DKernel</span><span class="p">(</span><span class="n">interp_range</span><span class="p">)</span>
        <span class="n">img_flt</span> <span class="o">=</span> <span class="n">convolve</span><span class="p">(</span><span class="n">img_flt</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="s1">&#39;extend&#39;</span><span class="p">,</span> 
                           <span class="n">nan_treatment</span><span class="o">=</span><span class="s1">&#39;interpolate&#39;</span><span class="p">)</span>
        <span class="n">img_flt</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">img_flt</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">img_flt</span><span class="p">)</span>
        <span class="n">img</span><span class="p">[</span><span class="n">pxmask</span><span class="p">]</span> <span class="o">=</span> <span class="n">img_flt</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="p">)[</span><span class="n">pxmask</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">img</span>

    <span class="k">elif</span> <span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;replace&#39;</span><span class="p">:</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># putmask does not support broadcasting</span>
                <span class="n">np</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">pxmask</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> 
                           <span class="n">replace_val</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">pxmask</span><span class="p">,</span> <span class="n">replace_val</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">img</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">):</span>
             <span class="c1">#dask arrays are immutable. This requires a slightly different way</span>
            <span class="n">sz</span> <span class="o">=</span> <span class="n">pxmask</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">pml</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">pxmask</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">sz</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">sz</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> 
                                <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">sz</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">sz</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">pml</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">pml</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">chunks</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">da</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">pml</span><span class="p">,</span> <span class="n">replace_val</span><span class="p">,</span> <span class="n">img</span><span class="p">)</span></div>
    
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Robert Buecker

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>