

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>diffractem.dataset &mdash; diffractem  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> diffractem
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../pre_processing.html">Preprocessing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crystfel.html">CrystFEL integration</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">diffractem</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>diffractem.dataset</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for diffractem.dataset</h1><div class="highlight"><pre>
<span></span><span class="c1"># dedicated to Thea and The Penguin</span>

<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">dask.array.gufunc</span>
<span class="kn">from</span> <span class="nn">dask</span> <span class="kn">import</span> <span class="n">array</span> <span class="k">as</span> <span class="n">da</span>
<span class="kn">from</span> <span class="nn">dask.diagnostics</span> <span class="kn">import</span> <span class="n">ProgressBar</span>
<span class="kn">from</span> <span class="nn">dask.distributed</span> <span class="kn">import</span> <span class="n">Client</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">io</span><span class="p">,</span> <span class="n">nexus</span>
<span class="kn">from</span> <span class="nn">.stream_parser</span> <span class="kn">import</span> <span class="n">StreamParser</span>
<span class="kn">from</span> <span class="nn">.map_image</span> <span class="kn">import</span> <span class="n">MapImage</span>
<span class="kn">import</span> <span class="nn">h5py</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Callable</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span><span class="p">,</span> <span class="n">catch_warnings</span><span class="p">,</span> <span class="n">simplefilter</span>
<span class="kn">from</span> <span class="nn">tables</span> <span class="kn">import</span> <span class="n">NaturalNameWarning</span>
<span class="kn">from</span> <span class="nn">concurrent.futures</span> <span class="kn">import</span> <span class="n">ProcessPoolExecutor</span><span class="p">,</span> <span class="n">wait</span><span class="p">,</span> <span class="n">FIRST_EXCEPTION</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">jit</span>

<span class="c1"># top-level helper functions for chunking operations</span>
<span class="c1"># ...to be refactored into tools or compute later...</span>
<span class="k">def</span> <span class="nf">_check_commensurate</span><span class="p">(</span><span class="n">init</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">final</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> 
                        <span class="n">equal_size</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;check if blocks with sizes in init are commensurate with (i.e. have boundaries aligned with)</span>
<span class="sd">    blocks in final, and (optionally) if final blocks in final are equally-sized within each block in initial.</span>
<span class="sd">    Useful to check if a dask rechunk operation will act across boundaries of existing chunks,</span>
<span class="sd">    which is often something you&#39;ll want to try to avoid (and might be a sign that something is going wrong).</span>
<span class="sd">    Blocks in final must hence be smaller than those in init, i.e. len(final) &gt;= len(init), </span>
<span class="sd">    and of course: sum(final) == sum(init).</span>
<span class="sd">    Returns whether the blocks are commensurate, and (if so), the number of  </span>
<span class="sd">    final blocks in each of the initial block.&#39;&#39;&#39;</span>
    <span class="c1">#TODO consider using numba jit</span>

    <span class="n">final_inv</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">final</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># invert for faster popping</span>
    <span class="n">init</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">init</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">init</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">final</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Sum of init and final must be identical.&#39;</span><span class="p">)</span>
    <span class="n">blocksize</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">equal_size</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">s0</span> <span class="ow">in</span> <span class="n">init</span><span class="p">:</span>
            <span class="c1"># iterate over initial blocks</span>
            <span class="n">n_final_in_initial</span> <span class="o">=</span> <span class="n">s0</span> <span class="o">//</span> <span class="n">final_inv</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_final_in_initial</span><span class="p">):</span>
                <span class="c1"># iterate over final blocks within initial</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">s0</span> <span class="o">%</span> <span class="n">final_inv</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span>
            <span class="n">blocksize</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n_final_in_initial</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">s0</span> <span class="ow">in</span> <span class="n">init</span><span class="p">:</span>
            <span class="c1"># iterate over initial blocks</span>
            <span class="c1"># n_rem = copy.copy(s0)</span>
            <span class="n">n_rem</span> <span class="o">=</span> <span class="n">s0</span>
            <span class="n">b_num</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">n_rem</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">n_rem</span> <span class="o">-=</span> <span class="n">final_inv</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">b_num</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">n_rem</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># incommensurate block found!</span>
                    <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span>
            <span class="n">blocksize</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b_num</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">final_inv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">blocksize</span>

<span class="k">def</span> <span class="nf">_agg_groups</span><span class="p">(</span><span class="n">stack</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">],</span> <span class="n">agg_function</span><span class="p">:</span> <span class="n">callable</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Apply aggregating function to a numpy stack group-by-group, with groups defined by unique labels,</span>
<span class="sd">    and return the concatenated results; i.e., the length of the result along the aggregation</span>
<span class="sd">    axis equals the number of unique labels.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">res_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">lbl</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
        <span class="n">res_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">agg_function</span><span class="p">(</span><span class="n">stack</span><span class="p">[</span><span class="n">labels</span> <span class="o">==</span> <span class="n">lbl</span><span class="p">,</span><span class="o">...</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">res_list</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_map_sub_blocks</span><span class="p">(</span><span class="n">stack</span><span class="p">:</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">],</span> <span class="n">func</span><span class="p">:</span> <span class="n">callable</span><span class="p">,</span> <span class="n">aggregating</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                     <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Wrapper for da.map_blocks, which instead of applying the function chunk-by-chunk can apply it also to sub-groups</span>
<span class="sd">    within each chunk, as identified by unique labels (e.g. integers). Useful if you want to use large chunks to have fast computation, but</span>
<span class="sd">    want to apply the function to smaller blocks. Obvious example: you want to sum frames from a diffraction</span>
<span class="sd">    movie, but have many diffraction movies stored in each single chunk, as otherwise the chunk number would be too large.</span>
<span class="sd">    The input stack must be chunked along its 0th axis only, and len(labels) must equal the height of the stack. </span>
<span class="sd">    If aggregating=True, func is assumed to reduce the sub-block height to 1 (like summing all stack frames), whereas</span>
<span class="sd">    aggregating=False assumes func to leave the sub-block sizes as is (e.g. for cumulative summing).&#39;&#39;&#39;</span>

    <span class="n">chunked_labels</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">labels</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)),</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;sub_block_label&#39;</span><span class="p">)</span>
    <span class="n">cc_out</span> <span class="o">=</span> <span class="n">_check_commensurate</span><span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span> <span class="n">equal_size</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">cc_out</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Mismatched chunk structure: mapping groups are not within single chunk each&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="s1">&#39;chunks&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">final_chunks</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;chunks&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">final_chunks</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">cc_out</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">)</span> <span class="o">+</span> <span class="n">stack</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">if</span> <span class="n">aggregating</span> <span class="k">else</span> <span class="n">stack</span><span class="o">.</span><span class="n">chunks</span>
    <span class="k">return</span> <span class="n">da</span><span class="o">.</span><span class="n">map_blocks</span><span class="p">(</span><span class="n">_agg_groups</span><span class="p">,</span> <span class="n">stack</span><span class="p">,</span> <span class="n">chunked_labels</span><span class="p">,</span> 
        <span class="n">agg_function</span><span class="o">=</span><span class="n">func</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="n">final_chunks</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="Dataset"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset">[docs]</a><span class="k">class</span> <span class="nc">Dataset</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_shots_changed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_peaks_changed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_predict_changed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_features_changed</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># HDF5 file addresses</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_pattern</span> <span class="o">=</span> <span class="s1">&#39;/%/data&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shots_pattern</span> <span class="o">=</span> <span class="s1">&#39;/%/shots&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fallback_shots_pattern</span> <span class="o">=</span> <span class="s1">&#39;/%/data/shots&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result_pattern</span> <span class="o">=</span> <span class="s1">&#39;/%/results&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map_pattern</span> <span class="o">=</span> <span class="s1">&#39;/%/map&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">instrument_pattern</span> <span class="o">=</span> <span class="s1">&#39;/%/instrument&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parallel_io</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># internal stuff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_file_handles</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stacks</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shot_id_cols</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="s1">&#39;Event&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_feature_id_cols</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;crystal_id&#39;</span><span class="p">,</span> <span class="s1">&#39;region&#39;</span><span class="p">,</span> <span class="s1">&#39;sample&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_diff_stack_label</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

        <span class="c1"># tables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_shot_id_cols</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_feature_id_cols</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;selected&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_peaks</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_shot_id_cols</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_predict</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_shot_id_cols</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_features</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_feature_id_cols</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="s1">&#39;subset&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s1">&#39;diffractem Dataset object spanning </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span><span class="si">}</span><span class="s1"> NeXus/HDF5 files</span><span class="se">\n</span><span class="s1">-----</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> shots (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">selected</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="si">}</span><span class="s1"> selected)</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_peaks</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> peaks, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_predict</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> predictions, &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_features</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> features</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_stacks</span><span class="p">)</span><span class="si">}</span><span class="s1"> data stacks: </span><span class="si">{</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_stacks</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="sa">f</span><span class="s1">&#39;Diffraction data stack: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_diff_stack_label</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="sa">f</span><span class="s1">&#39;Data files open: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_files_open</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="sa">f</span><span class="s1">&#39;Data files writable: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_files_writable</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="c1"># allows to access stacks with dot notation</span>
        <span class="k">if</span> <span class="n">attr</span> <span class="o">==</span> <span class="s1">&#39;_stacks&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">()</span>  <span class="c1"># needed for copying the object to avoid infinite recursion</span>
        <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stacks</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stacks</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s1"> is neither a dataset attribute, nor a stack name.&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_files_open</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_handles</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_files_writable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_files_open</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">([</span><span class="n">f</span><span class="o">.</span><span class="n">mode</span> <span class="o">!=</span> <span class="s1">&#39;r&#39;</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_handles</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_stack_in_memory</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">sn</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">stk</span><span class="o">.</span><span class="n">dask</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">stk</span><span class="o">.</span><span class="n">numblocks</span><span class="p">)</span> <span class="k">for</span> <span class="n">sn</span><span class="p">,</span> <span class="n">stk</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stacks</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">file_handles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># handles to HDF5 files, if open. Otherwise None.</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">fn</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_file_handles</span><span class="p">[</span><span class="n">fn</span><span class="p">]</span> <span class="k">if</span> <span class="n">fn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_file_handles</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">stacks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stacks</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">files</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shots</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span>

    <span class="nd">@shots</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">shots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">index</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Shot index is different from existing one. Use modify_shots to change index.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_shot_id_cols</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_shot_id_cols</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Shot ID columns are different from existing ones. Use modify_shots to change index.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shots_changed</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;The prediction table functionality will likely be removed.&#39;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_predict</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">features</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_features</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">peaks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;The peak table functionality will likely be removed.&#39;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_peaks</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">zchunks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># z chunks of dataset stacks</span>
        <span class="n">allchk</span> <span class="o">=</span> <span class="p">[</span><span class="n">stk</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">stk</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stacks</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
        <span class="k">if</span> <span class="n">allchk</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">([</span><span class="n">chk</span> <span class="o">==</span> <span class="n">allchk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">chk</span> <span class="ow">in</span> <span class="n">allchk</span><span class="p">]):</span>
            <span class="k">return</span> <span class="n">allchk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>        
        
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">diff_stack_label</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_diff_stack_label</span>
    
    <span class="nd">@diff_stack_label</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">diff_stack_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stacks</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_diff_stack_label</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s1"> is not a stack.&#39;</span><span class="p">)</span>
            
    <span class="nd">@peaks</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">peaks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;The peak table functionality will likely be removed.&#39;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_peaks</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_peaks_changed</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="nd">@predict</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;The prediction table functionality will likely be removed.&#39;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_predict</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_predict_changed</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="nd">@features</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">features</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_features</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_features_changed</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="Dataset.from_files"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.from_files">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_files</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">files</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">],</span> <span class="n">open_stacks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">chunking</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> 
                   <span class="n">persist_meta</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">init_stacks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">load_tables</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> 
                   <span class="n">diff_stack_label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;raw_counts&#39;</span><span class="p">,</span> <span class="n">validate_files</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a data set from:</span>
<span class="sd">            * a .lst file name, which contains a simple list of H5 files (on separate lines). If the .lst file has CrystFEL-style</span>
<span class="sd">                event indicators in it, it will be loaded, and the events present in the list will be selected, the others not.</span>
<span class="sd">            * a glob pattern (like: &#39;data/*.h5&#39;)</span>
<span class="sd">            * a python iterable of files. </span>
<span class="sd">            * a simple HDF5 file path</span>
<span class="sd">        :param files: see above</span>
<span class="sd">        :param init_stacks: initialize stacks, that is, briefly open the data stacks, check their lengths, and close</span>
<span class="sd">                them again. Does not hurt usually.</span>
<span class="sd">        :param load_tables: load the additional tables stored in the files (features, peaks, predictions)</span>
<span class="sd">        :param diff_stack_label: name of stack to be used for generating the shot table, if it&#39;s not stored in the files</span>
<span class="sd">        :param **kwargs: Dataset attributes to be set right away</span>
<span class="sd">        :return: dataset object</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">file_list</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">expand_files</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="n">scan_shots</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="n">validate_files</span><span class="p">)</span>
        <span class="c1"># print(list(file_list))</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">file_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Single-file dataset, disabling parallel I/O.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parallel_io</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">load_tables</span><span class="p">(</span><span class="n">shots</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">files</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">file_list</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">unique</span><span class="p">()))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">init_shot_table</span><span class="p">(</span><span class="n">file_list</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">],</span> <span class="n">stack_label</span><span class="o">=</span><span class="n">diff_stack_label</span><span class="p">)</span>

        <span class="c1"># now set selected property...</span>
        <span class="k">if</span> <span class="s1">&#39;Event&#39;</span> <span class="ow">in</span> <span class="n">file_list</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="p">[</span><span class="s1">&#39;selected&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_shot_id_cols</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">file_list</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_shot_id_cols</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># and initialize stacks and tables</span>
        <span class="k">if</span> <span class="n">init_stacks</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">open_stacks</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">init_stacks</span><span class="p">(</span><span class="n">chunking</span><span class="o">=</span><span class="n">chunking</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">load_tables</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_tables</span><span class="p">(</span><span class="n">features</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">peaks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">predict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>          
        <span class="k">if</span> <span class="n">open_stacks</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">open_stacks</span><span class="p">(</span><span class="n">chunking</span><span class="o">=</span><span class="n">chunking</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">open_stacks</span> <span class="ow">and</span> <span class="n">persist_meta</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">persist_stacks</span><span class="p">(</span><span class="n">exclude</span><span class="o">=</span><span class="n">diff_stack_label</span><span class="p">,</span> <span class="n">include_3d</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>
    
    <span class="n">from_list</span> <span class="o">=</span> <span class="n">from_files</span> <span class="c1"># for compatibility</span>

    <span class="c1">#TODO What is this method doing here? Shouldn&#39;t it go into some tool module?</span>
<div class="viewcode-block" id="Dataset.init_shot_table"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.init_shot_table">[docs]</a>    <span class="k">def</span> <span class="nf">init_shot_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">files</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">stack_label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;raw_counts&#39;</span><span class="p">):</span>
        <span class="n">identifiers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_pattern</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;%&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">shots</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">identifiers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">subsets</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">subsets</span> <span class="o">=</span> <span class="n">fh</span><span class="p">[</span><span class="n">identifiers</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

                <span class="n">file_shots</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">subset</span> <span class="ow">in</span> <span class="n">subsets</span><span class="p">:</span>
                    <span class="n">tbl_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shots_pattern</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;%&#39;</span><span class="p">,</span> <span class="n">subset</span><span class="p">)</span>
                    <span class="n">stk_path</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_pattern</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">stack_label</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;%&#39;</span><span class="p">,</span> <span class="n">subset</span><span class="p">)</span>
                    
                    <span class="n">stk_height</span> <span class="o">=</span> <span class="n">fh</span><span class="p">[</span><span class="n">stk_path</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">sss</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">stk_height</span><span class="p">),</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;shot_in_subset&#39;</span><span class="p">])</span>
                    <span class="n">sss</span><span class="p">[</span><span class="s1">&#39;subset&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">subset</span>
                    <span class="n">sss</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fn</span>
                    <span class="n">sss</span><span class="p">[</span><span class="s1">&#39;Event&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">subset</span> <span class="o">+</span> <span class="s1">&#39;//&#39;</span> <span class="o">+</span> <span class="n">sss</span><span class="p">[</span><span class="s1">&#39;shot_in_subset&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
                    <span class="n">sss</span><span class="p">[</span><span class="s1">&#39;frame&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">sss</span><span class="p">[</span><span class="s1">&#39;selected&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">file_shots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sss</span><span class="p">)</span>
                    
            <span class="n">shots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">file_shots</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">shots</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Found </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> shots, initialized shot table.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Dataset.load_tables"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.load_tables">[docs]</a>    <span class="k">def</span> <span class="nf">load_tables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">peaks</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">predict</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">files</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load pandas metadata tables from the HDF5 files. Set the argument for the table you want to load to True.</span>
<span class="sd">        :param shots: shot table</span>
<span class="sd">        :param features: feature table</span>
<span class="sd">        :param peaks: peak table</span>
<span class="sd">        :param predict: prediction table</span>
<span class="sd">        :param files: ...allows to supply a custom file list, instead of the stored one. Dangerous.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">files</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">files</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">files</span>

        <span class="k">if</span> <span class="n">shots</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;You are reloading the shot table. This can be dangerous. If you want to ensure a consistent&#39;</span>
                     <span class="s1">&#39; data set, use the from_list class method instead, or start from an empty dataset.&#39;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span> <span class="o">=</span> <span class="n">nexus</span><span class="o">.</span><span class="n">get_table</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shots_pattern</span><span class="p">,</span>
                                                  <span class="n">parallel</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parallel_io</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span> <span class="o">=</span> <span class="n">nexus</span><span class="o">.</span><span class="n">get_table</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fallback_shots_pattern</span><span class="p">,</span>
                                                  <span class="n">parallel</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parallel_io</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_shots_changed</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="k">if</span> <span class="s1">&#39;shot_in_subset&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                    <span class="k">if</span> <span class="s1">&#39;shot&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                        <span class="c1"># seems to be a raw file from acquisition...</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;shot&#39;</span><span class="p">:</span> <span class="s1">&#39;shot_in_subset&#39;</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="p">[</span><span class="s1">&#39;shot_in_subset&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="s1">&#39;subset&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">cumcount</span><span class="p">()</span>

                <span class="k">if</span> <span class="s1">&#39;Event&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="p">[</span><span class="s1">&#39;Event&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">subset</span> <span class="o">+</span> <span class="s1">&#39;//&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">shot_in_subset</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>

                <span class="k">if</span> <span class="s1">&#39;selected&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="p">[</span><span class="s1">&#39;selected&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="k">if</span> <span class="s1">&#39;stem&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                    <span class="c1"># deprecated....</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;stem&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;No shots found at &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">shots_pattern</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">features</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_features</span> <span class="o">=</span> <span class="n">nexus</span><span class="o">.</span><span class="n">get_table</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_pattern</span> <span class="o">+</span> <span class="s1">&#39;/features&#39;</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parallel_io</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_features_changed</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="k">if</span> <span class="s1">&#39;sample&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_features</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                    <span class="n">sdat</span> <span class="o">=</span> <span class="n">nexus</span><span class="o">.</span><span class="n">get_meta_fields</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_features</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">unique</span><span class="p">()),</span>
                                                 <span class="p">[</span><span class="s1">&#39;/%/sample/name&#39;</span><span class="p">,</span> <span class="s1">&#39;/%/sample/region_id&#39;</span><span class="p">,</span> <span class="s1">&#39;/%/sample/run_id&#39;</span><span class="p">])</span><span class="o">.</span> \
                        <span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;region_id&#39;</span><span class="p">:</span> <span class="s1">&#39;region&#39;</span><span class="p">,</span> <span class="s1">&#39;run_id&#39;</span><span class="p">:</span> <span class="s1">&#39;run&#39;</span><span class="p">})</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_features</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_features</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">sdat</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="s1">&#39;subset&#39;</span><span class="p">])</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_features</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_feature_id_cols</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;No features found at &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_pattern</span> <span class="o">+</span> <span class="s1">&#39;/features&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">peaks</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_peaks</span> <span class="o">=</span> <span class="n">nexus</span><span class="o">.</span><span class="n">get_table</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">result_pattern</span> <span class="o">+</span> <span class="s1">&#39;/peaks&#39;</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parallel_io</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_peaks_changed</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>
                <span class="c1">#print(&#39;No peaks found at &#39; + self.result_pattern + &#39;/peaks&#39;)</span>

        <span class="k">if</span> <span class="n">predict</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_predict</span> <span class="o">=</span> <span class="n">nexus</span><span class="o">.</span><span class="n">get_table</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">result_pattern</span> <span class="o">+</span> <span class="s1">&#39;/predict&#39;</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parallel_io</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_predict_changed</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span></div>
                <span class="c1">#print(&#39;No predictions found at &#39; + self.result_pattern + &#39;/predict&#39;)</span>

<div class="viewcode-block" id="Dataset.store_tables"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.store_tables">[docs]</a>    <span class="k">def</span> <span class="nf">store_tables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shots</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">features</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">peaks</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">predict</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;nexus&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Stores the metadata tables (shots, features, peaks, predictions) into HDF5 files. For each of the tables,</span>
<span class="sd">        it can be automatically determined if they have changed and should be stored...</span>
<span class="sd">        HOWEVER, this only works if no inplace changes have been made. So don&#39;t rely on it too much.</span>
<span class="sd">        :param shots: True -&gt; store shot list, False -&gt; don&#39;t store shot list, None -&gt; only store if changed</span>
<span class="sd">        :param features: similar</span>
<span class="sd">        :param peaks: similar</span>
<span class="sd">        :param predict: similar</span>
<span class="sd">        :param format: format to write metadata tables. &#39;nexus&#39; (recommended) or &#39;tables&#39; (old-style)</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1">#TODO automatically handle readonly-opened files</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_files_open</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">format</span> <span class="o">==</span> <span class="s1">&#39;tables&#39;</span><span class="p">):</span>
            <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Data files are open, and will be transiently closed. You will need to re-create derived stacks.&#39;</span><span class="p">,</span>
                 <span class="ne">RuntimeWarning</span><span class="p">)</span>
            <span class="n">stacks_were_open</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">close_stacks</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stacks_were_open</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">simplefilter</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">NaturalNameWarning</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">shots</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots_changed</span><span class="p">)</span> <span class="ow">or</span> <span class="n">shots</span><span class="p">:</span>
            <span class="c1"># sh = self.shots.drop([&#39;Event&#39;, &#39;shot_in_subset&#39;], axis=1)</span>
            <span class="c1"># sh[&#39;id&#39;] = sh[[&#39;sample&#39;, &#39;region&#39;, &#39;run&#39;, &#39;crystal_id&#39;]].apply(lambda x: &#39;//&#39;.join(x.astype(str)), axis=1)</span>
            <span class="n">fs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">nexus</span><span class="o">.</span><span class="n">store_table</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shots_pattern</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parallel_io</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_shots_changed</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">features</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_features_changed</span><span class="p">)</span> <span class="ow">or</span> <span class="n">features</span><span class="p">:</span>
            <span class="n">fs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">nexus</span><span class="o">.</span><span class="n">store_table</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_pattern</span> <span class="o">+</span> <span class="s1">&#39;/features&#39;</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parallel_io</span><span class="p">,</span>
                                        <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_features_changed</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">peaks</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_peaks_changed</span><span class="p">)</span> <span class="ow">or</span> <span class="n">peaks</span><span class="p">:</span>
            <span class="n">fs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="n">nexus</span><span class="o">.</span><span class="n">store_table</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">peaks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">result_pattern</span> <span class="o">+</span> <span class="s1">&#39;/peaks&#39;</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parallel_io</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_peaks_changed</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">predict</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_predict_changed</span><span class="p">)</span> <span class="ow">or</span> <span class="n">predict</span><span class="p">:</span>
            <span class="n">fs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">nexus</span><span class="o">.</span><span class="n">store_table</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">result_pattern</span> <span class="o">+</span> <span class="s1">&#39;/predict&#39;</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parallel_io</span><span class="p">,</span>
                                        <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_predict_changed</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">stacks_were_open</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">open_stacks</span><span class="p">()</span></div>

<div class="viewcode-block" id="Dataset.merge_stream"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.merge_stream">[docs]</a>    <span class="k">def</span> <span class="nf">merge_stream</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">streamfile</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">StreamParser</span><span class="p">,</span> <span class="nb">str</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads a CrystFEL stream file, and merges its contents into the dataset object.</span>
<span class="sd">        :param streamfile: file name of streamfile, or StreamParser object</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># ...it would be way more elegant, to just associate a StreamParser object, and merge the list in</span>
        <span class="c1"># accessors. But the merges can become pretty slow for large files, so we do it only here.</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">streamfile</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="n">StreamParser</span><span class="p">(</span><span class="n">streamfile</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="n">streamfile</span>

        <span class="n">cols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">columns</span><span class="p">))</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shot_id_cols</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;subset&#39;</span><span class="p">,</span>
                                                                                                 <span class="s1">&#39;shot_in_subset&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="p">[</span><span class="n">cols</span><span class="p">]</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">shots</span><span class="p">,</span>
                                            <span class="n">on</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_shot_id_cols</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;subset&#39;</span><span class="p">,</span> <span class="s1">&#39;shot_in_subset&#39;</span><span class="p">],</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span>
                                            <span class="n">validate</span><span class="o">=</span><span class="s1">&#39;1:1&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="p">[</span><span class="s1">&#39;selected&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="p">[</span><span class="s1">&#39;serial&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">notna</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">peaks</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">peaks</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_shot_id_cols</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;subset&#39;</span><span class="p">,</span> <span class="s1">&#39;shot_in_subset&#39;</span><span class="p">]],</span>
                                        <span class="n">on</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_shot_id_cols</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;inner&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">predict</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">indexed</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_shot_id_cols</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;subset&#39;</span><span class="p">,</span> <span class="s1">&#39;shot_in_subset&#39;</span><span class="p">]],</span>
                                            <span class="n">on</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_shot_id_cols</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;inner&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Dataset.get_map"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.get_map">[docs]</a>    <span class="k">def</span> <span class="nf">get_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">subset</span><span class="o">=</span><span class="s1">&#39;entry&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MapImage</span><span class="p">:</span>
        <span class="c1"># TODO: get a MapImage from stored data, with tables filled in from dataset</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;does not work yet, sorry.&#39;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_sel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">h5py</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        General method to pick items that belong to selected shots from many kinds of data types.</span>
<span class="sd">        - For DataFrames, it matches the selected items by the datasets ID columns (usually &#39;file&#39; and &#39;Event&#39;,</span>
<span class="sd">        or &#39;crystal_id&#39; and &#39;region&#39;)</span>
<span class="sd">        - For anything slicable (dask or numpy array), it picks elements along the first array dimension,</span>
<span class="sd">        assuming that the stack is ordered the same way as the shot list.</span>
<span class="sd">        - Also accepts lists or dicts of all such objects and returns a corresponding list or dict.</span>
<span class="sd">        :param obj: DataFrame, numpy Array, dask Array, h5py Dataset, list, dict</span>
<span class="sd">        :return: same as obj</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">selected</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">c</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">columns</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shot_id_cols</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">selected</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shot_id_cols</span><span class="p">],</span>
                             <span class="n">on</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_shot_id_cols</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;inner&#39;</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="s1">&#39;m:1&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">c</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">columns</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_feature_id_cols</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_feature_id_cols</span><span class="p">],</span>
                             <span class="n">on</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_feature_id_cols</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;inner&#39;</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="s1">&#39;1:m&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;DataFrame must contain the columns </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_shot_id_cols</span><span class="si">}</span><span class="s1"> or </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_feature_id_cols</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_sel</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sel</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">obj</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">selected</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>

<div class="viewcode-block" id="Dataset.select"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.select">[docs]</a>    <span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;True&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the &#39;selected&#39; column of the shot list by a string query (eg. &#39;num_peaks &gt; 30 and frame == 1&#39;).</span>
<span class="sd">        See pandas documentation for &#39;query&#39; and &#39;eval&#39;. If you want to add another criterion to the existing</span>
<span class="sd">        selection you can also do sth. like &#39;selected and hit == 1&#39;.</span>
<span class="sd">        :param query: if left empty, defaults to &#39;True&#39; -&gt; selects all shots.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">selection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">selection</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;query must return a boolean!&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">selected</span> <span class="o">=</span> <span class="n">selection</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">selected</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="si">}</span><span class="s1"> shots out of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> selected.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Dataset.change_filenames"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.change_filenames">[docs]</a>    <span class="k">def</span> <span class="nf">change_filenames</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_suffix</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;.h5&#39;</span><span class="p">,</span> <span class="n">file_prefix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
                         <span class="n">new_folder</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">fn_map</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">keep_raw</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change file names in all lists using some handy modifications. The old file names are copied to a &quot;file_raw&quot;</span>
<span class="sd">        column, if not already present (can be overriden with keep_raw).</span>
<span class="sd">        :param file_suffix: add suffix to file, INCLUDING file extension, e.g. &#39;_modified.h5&#39;</span>
<span class="sd">        :param file_prefix: add prefix to actual filenames (not folder/full path!), e.g. &#39;aggregated_</span>
<span class="sd">        :param new_folder: if not None, changes folder name to this path</span>
<span class="sd">        :param fn_map: if not None, gives an explicit table (pd.DataFrame) with columns &#39;file&#39; and &#39;file_new&#39;</span>
<span class="sd">            that manually maps old to new filenames. All other parameters are ignored, if provided</span>
<span class="sd">        :param keep_raw: if True (default), does not change the file_raw column in the shot list,</span>
<span class="sd">            unless there is none yet (in which case the old file names are _always_ copied to keep_raw)</span>
<span class="sd">        :return: DataFrame with a map from old to new file names (for reference)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">fn_map</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># name mangling pt. 1: make map of old names to new names</span>
            <span class="n">fn_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="p">[[</span><span class="s1">&#39;file&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span>
            <span class="n">folder_file</span> <span class="o">=</span> <span class="n">fn_map</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">file_suffix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_fn</span> <span class="o">=</span> <span class="n">file_prefix</span> <span class="o">+</span> <span class="n">folder_file</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">file_suffix</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_fn</span> <span class="o">=</span> <span class="n">file_prefix</span> <span class="o">+</span> <span class="n">folder_file</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">new_folder</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_fn</span> <span class="o">=</span> <span class="n">new_folder</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">new_fn</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_fn</span> <span class="o">=</span> <span class="n">folder_file</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">new_fn</span>
            <span class="n">fn_map</span><span class="p">[</span><span class="s1">&#39;file_new&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_fn</span>
            <span class="c1"># print(fn_map)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">fn_map</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">fn_map</span><span class="p">[</span><span class="s1">&#39;file_new&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;New and old file names are the same! Nothing will happen.&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">fn_map</span>

        <span class="c1"># name mangling pt. 2: change names in all tables</span>
        <span class="k">for</span> <span class="n">lbl</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;_shots&#39;</span><span class="p">,</span> <span class="s1">&#39;_peaks&#39;</span><span class="p">,</span> <span class="s1">&#39;_predict&#39;</span><span class="p">,</span> <span class="s1">&#39;_features&#39;</span><span class="p">]:</span>
            <span class="n">table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">lbl</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">table</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">newtable</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">fn_map</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span> \
                <span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;file_new&#39;</span><span class="p">:</span> <span class="s1">&#39;file&#39;</span><span class="p">})</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">lbl</span> <span class="o">==</span> <span class="s1">&#39;_shots&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">keep_raw</span> <span class="ow">or</span> <span class="s1">&#39;file_raw&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
                <span class="n">newtable</span><span class="p">[</span><span class="s1">&#39;file_raw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">file</span>

            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">lbl</span><span class="p">]</span> <span class="o">=</span> <span class="n">newtable</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">lbl</span> <span class="o">+</span> <span class="s1">&#39;_changed&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># invalidate all the hdf file references (note that references into old files might still exist)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_file_handles</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="n">fn_map</span></div>

<div class="viewcode-block" id="Dataset.reset_id"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.reset_id">[docs]</a>    <span class="k">def</span> <span class="nf">reset_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keep_raw</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resets shot_in_subset and Event columns to continuous numbering. Useful after dataset reduction. The old</span>
<span class="sd">        Event strings are copied to a &quot;Event_raw&quot; column, if not already present (can be overriden with keep_raw).</span>
<span class="sd">        :param keep_raw: if True (default), does not change the Event_raw column in the shot list,</span>
<span class="sd">            unless there is none yet (in which case the old Event IDs are _always_ copied to keep_raw)</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">id_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_shot_id_cols</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">id_map</span><span class="p">[</span><span class="s1">&#39;new_sis&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="s1">&#39;subset&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">cumcount</span><span class="p">()</span>
        <span class="n">id_map</span><span class="p">[</span><span class="s1">&#39;new_Event&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">subset</span> <span class="o">+</span> <span class="s1">&#39;//&#39;</span> <span class="o">+</span> <span class="n">id_map</span><span class="p">[</span><span class="s1">&#39;new_sis&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">lbl</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;_shots&#39;</span><span class="p">,</span> <span class="s1">&#39;_peaks&#39;</span><span class="p">,</span> <span class="s1">&#39;_predict&#39;</span><span class="p">]:</span>
            <span class="n">table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">lbl</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">table</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;new_Event&#39;</span><span class="p">:</span> <span class="s1">&#39;Event&#39;</span><span class="p">,</span> <span class="s1">&#39;new_sis&#39;</span><span class="p">:</span> <span class="s1">&#39;shot_in_subset&#39;</span><span class="p">}</span> <span class="k">if</span> <span class="s1">&#39;shot_in_subset&#39;</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">columns</span> \
                <span class="k">else</span> <span class="p">{</span><span class="s1">&#39;new_Event&#39;</span><span class="p">:</span> <span class="s1">&#39;Event&#39;</span><span class="p">}</span>
            <span class="n">newtable</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">id_map</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_shot_id_cols</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">cols</span><span class="o">.</span><span class="n">keys</span><span class="p">())],</span> <span class="n">on</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_shot_id_cols</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span><span class="o">.</span> \
                <span class="n">drop</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">cols</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">cols</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">lbl</span> <span class="o">==</span> <span class="s1">&#39;_shots&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">keep_raw</span> <span class="ow">or</span> <span class="s1">&#39;Event_raw&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
                <span class="n">newtable</span><span class="p">[</span><span class="s1">&#39;Event_raw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">Event</span>

            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">lbl</span><span class="p">]</span> <span class="o">=</span> <span class="n">newtable</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">lbl</span> <span class="o">+</span> <span class="s1">&#39;_changed&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Dataset.init_files"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.init_files">[docs]</a>    <span class="k">def</span> <span class="nf">init_files</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">keep_features</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">exclude_list</span><span class="o">=</span><span class="p">()):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make new files corresponding to the shot list, by copying over instrument metadata and maps (but not</span>
<span class="sd">        results, shot list, data arrays,...) from the raw files (as stored in file_raw).</span>
<span class="sd">        :param overwrite: overwrite new files if not yet existing</span>
<span class="sd">        :param keep_features: copy over the feature list from the files</span>
<span class="sd">        :param exclude_list: custom list of HDF5 groups or datasets to exclude from copying</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fn_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="p">[[</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="s1">&#39;file_raw&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span>

        <span class="n">exc</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;%/detector/data&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_pattern</span> <span class="o">+</span> <span class="s1">&#39;/%&#39;</span><span class="p">,</span>
               <span class="bp">self</span><span class="o">.</span><span class="n">result_pattern</span> <span class="o">+</span> <span class="s1">&#39;/%&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shots_pattern</span> <span class="o">+</span> <span class="s1">&#39;/%&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">keep_features</span><span class="p">:</span>
            <span class="n">exc</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_pattern</span> <span class="o">+</span> <span class="s1">&#39;/features&#39;</span><span class="p">,</span> <span class="s1">&#39;%/ref/features&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">exclude_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">exc</span> <span class="o">+=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">exclude_list</span><span class="p">)</span>

        <span class="c1"># print(fn_map)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parallel_io</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">ProcessPoolExecutor</span><span class="p">()</span> <span class="k">as</span> <span class="n">p</span><span class="p">:</span>
                <span class="n">futures</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">filepair</span> <span class="ow">in</span> <span class="n">fn_map</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                    <span class="n">futures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">nexus</span><span class="o">.</span><span class="n">copy_h5</span><span class="p">,</span>
                                            <span class="n">filepair</span><span class="p">[</span><span class="s1">&#39;file_raw&#39;</span><span class="p">],</span> <span class="n">filepair</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">],</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span> <span class="k">if</span> <span class="n">overwrite</span> <span class="k">else</span> <span class="s1">&#39;w-&#39;</span><span class="p">,</span>
                                            <span class="n">exclude</span><span class="o">=</span><span class="n">exc</span><span class="p">,</span>
                                            <span class="n">print_skipped</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>

                <span class="n">wait</span><span class="p">(</span><span class="n">futures</span><span class="p">,</span> <span class="n">return_when</span><span class="o">=</span><span class="n">FIRST_EXCEPTION</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">futures</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">exception</span><span class="p">():</span>
                        <span class="k">raise</span> <span class="n">f</span><span class="o">.</span><span class="n">exception</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">futures</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">filepair</span> <span class="ow">in</span> <span class="n">fn_map</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                <span class="n">nexus</span><span class="o">.</span><span class="n">copy_h5</span><span class="p">(</span><span class="n">filepair</span><span class="p">[</span><span class="s1">&#39;file_raw&#39;</span><span class="p">],</span> <span class="n">filepair</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">],</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span> <span class="k">if</span> <span class="n">overwrite</span> <span class="k">else</span> <span class="s1">&#39;w-&#39;</span><span class="p">,</span>
                              <span class="n">exclude</span><span class="o">=</span><span class="n">exc</span><span class="p">,</span>
                              <span class="n">print_skipped</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Dataset.get_meta"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.get_meta">[docs]</a>    <span class="k">def</span> <span class="nf">get_meta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="s1">&#39;/%/instrument/detector/collection/shutter_time&#39;</span><span class="p">):</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="p">{}</span>    
        <span class="k">for</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="s1">&#39;subset&#39;</span><span class="p">]):</span>
            <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">lbl</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
                <span class="n">meta</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">lbl</span><span class="p">)]</span> <span class="o">=</span> <span class="n">fh</span><span class="p">[</span><span class="n">path</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;%&#39;</span><span class="p">,</span> <span class="n">lbl</span><span class="p">[</span><span class="mi">1</span><span class="p">])][</span><span class="o">...</span><span class="p">]</span>
                <span class="c1">#print(type(meta[tuple(lbl)]))</span>
                <span class="c1">#print(meta[tuple(lbl)].shape)</span>
                <span class="k">if</span> <span class="n">meta</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">lbl</span><span class="p">)]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">meta</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">lbl</span><span class="p">)]</span> <span class="o">=</span> <span class="n">meta</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">lbl</span><span class="p">)][()]</span>
                <span class="k">elif</span> <span class="n">meta</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">lbl</span><span class="p">)]</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">meta</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">lbl</span><span class="p">)]</span> <span class="o">=</span> <span class="n">meta</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">lbl</span><span class="p">)][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">path</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="Dataset.merge_meta"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.merge_meta">[docs]</a>    <span class="k">def</span> <span class="nf">merge_meta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="s1">&#39;%/instrument/detector/collection/shutter_time&#39;</span><span class="p">):</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_meta</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="s1">&#39;subset&#39;</span><span class="p">])</span></div>

<div class="viewcode-block" id="Dataset.get_selection"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.get_selection">[docs]</a>    <span class="k">def</span> <span class="nf">get_selection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                      <span class="n">file_suffix</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;_sel.h5&#39;</span><span class="p">,</span> <span class="n">file_prefix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
                      <span class="n">new_folder</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                      <span class="n">reset_id</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Dataset&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new dataset object by applying a selection. By default, returns all shots with selected == True.</span>
<span class="sd">        Optionally, a different query string can be supplied (which leaves the selection unaffected).</span>
<span class="sd">        The stored file names will be changed, to avoid collisions. This can be controlled with the file_suffix and</span>
<span class="sd">        file_prefix parameters.</span>
<span class="sd">        :param query: Optional query string, as in the select method</span>
<span class="sd">        :param file_suffix: as in Dataset.change_filenames</span>
<span class="sd">        :param file_prefix: as in Dataset.change_filenames</span>
<span class="sd">        :param new_folder: as in Dataset.change_filenames</span>
<span class="sd">        :return: new data set.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">query</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cur_sel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">selected</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">newset</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">newset</span><span class="o">.</span><span class="n">_shots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sel</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">newset</span><span class="o">.</span><span class="n">_peaks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_peaks</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">newset</span><span class="o">.</span><span class="n">_predict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_predict</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">newset</span><span class="o">.</span><span class="n">_features</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_features</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">newset</span><span class="o">.</span><span class="n">_shots</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_feature_id_cols</span><span class="p">],</span>
                                                    <span class="n">on</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_feature_id_cols</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;inner&#39;</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="s1">&#39;1:m&#39;</span><span class="p">)</span><span class="o">.</span>\
                <span class="n">drop_duplicates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_feature_id_cols</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">newset</span><span class="o">.</span><span class="n">_stacks</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="n">newset</span><span class="o">.</span><span class="n">change_filenames</span><span class="p">(</span><span class="n">file_suffix</span><span class="p">,</span> <span class="n">file_prefix</span><span class="p">,</span> <span class="n">new_folder</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">reset_id</span><span class="p">:</span>
                <span class="n">newset</span><span class="o">.</span><span class="n">reset_id</span><span class="p">()</span>
            <span class="n">newset</span><span class="o">.</span><span class="n">_file_handles</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stacks</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">newset</span><span class="o">.</span><span class="n">add_stack</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sel</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
                
            <span class="n">newset</span><span class="o">.</span><span class="n">persist_stacks</span><span class="p">([</span><span class="n">sn</span> <span class="k">for</span> <span class="n">sn</span><span class="p">,</span> <span class="n">inmem</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stack_in_memory</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">inmem</span><span class="p">])</span>

        <span class="k">finally</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">query</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">selected</span> <span class="o">=</span> <span class="n">cur_sel</span>

        <span class="k">return</span> <span class="n">newset</span></div>

<div class="viewcode-block" id="Dataset.aggregate"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.aggregate">[docs]</a>    <span class="k">def</span> <span class="nf">aggregate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">by</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;region&#39;</span><span class="p">,</span> <span class="s1">&#39;run&#39;</span><span class="p">,</span> <span class="s1">&#39;crystal_id&#39;</span><span class="p">),</span>
                  <span class="n">how</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;mean&#39;</span><span class="p">,</span>
                  <span class="n">file_suffix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;_agg.h5&#39;</span><span class="p">,</span> <span class="n">file_prefix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">new_folder</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                  <span class="n">query</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">force_commensurate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                  <span class="n">exclude_stacks</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Dataset&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Aggregate sub-sets of stacks using different aggregation functions. Typical application: sum sub-stacks of</span>
<span class="sd">        dose fractionation movies, or shots with different tilt angles (quasi-precession)</span>
<span class="sd">        :param by: shot table columns to group by for aggregation. Default: (&#39;run&#39;, &#39;region&#39;, &#39;crystal_id&#39;, &#39;sample&#39;)</span>
<span class="sd">        :param how: aggregation types. &#39;sum&#39;, &#39;mean&#39;, and &#39;cumsum&#39; are supported. Can be a single operation for all</span>
<span class="sd">            stacks, or a dict, specifying different ones for each, in which case all non-explicitly specified stacks</span>
<span class="sd">            will default to &#39;mean&#39;, e.g. how={&#39;raw_counts&#39;: &#39;sum&#39;}.</span>
<span class="sd">        :param file_suffix: as in Dataset.change_filenames</span>
<span class="sd">        :param file_prefix: as in Dataset.change_filenames</span>
<span class="sd">        :param new_folder: as in Dataset.change_filenames</span>
<span class="sd">        :param query: apply a query (see select or get_selection)</span>
<span class="sd">        :return: a new data set with aggregation applied</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#TODO: fast agg only works on 3D arrays currently!</span>
        <span class="c1"># from time import time</span>
        <span class="c1"># T0 = time()</span>
        <span class="n">by</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">by</span><span class="p">)</span>
        <span class="n">newset</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">newset</span><span class="o">.</span><span class="n">_stacks</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">exclude_stacks</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">exclude_stacks</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">exclude_stacks</span>
        
        <span class="c1"># PART 1: MAKE A NEW SHOT TABLE ---</span>
        
        <span class="c1"># get shot selection and aggregation groups</span>
        <span class="n">shsel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">query</span><span class="p">)</span> <span class="k">if</span> <span class="n">query</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">by</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">gb</span> <span class="o">=</span> <span class="n">shsel</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">by</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        
        <span class="c1"># get shot list columns that are (non-)identical within each aggregation group</span>
        <span class="n">nonid</span> <span class="o">=</span> <span class="p">(</span><span class="n">gb</span><span class="o">.</span><span class="n">nunique</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
        <span class="n">cols_nonid</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nonid</span><span class="p">[</span><span class="n">nonid</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="n">cols_id</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nonid</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">nonid</span><span class="p">)]</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

        <span class="c1"># add some information to shot list</span>
        <span class="n">sh_initial</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">shsel</span><span class="p">,</span> <span class="n">gb</span><span class="o">.</span><span class="n">ngroup</span><span class="p">()</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;_agg_grp_id&#39;</span><span class="p">),</span> <span class="n">gb</span><span class="o">.</span><span class="n">cumcount</span><span class="p">()</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;_agg_shot_in_grp&#39;</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># re-sort initial table if required</span>
        <span class="n">monotonous</span> <span class="o">=</span> <span class="p">(</span><span class="n">sh_initial</span><span class="p">[</span><span class="s1">&#39;_agg_grp_id&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">values</span> <span class="o">-</span> <span class="n">sh_initial</span><span class="p">[</span><span class="s1">&#39;_agg_grp_id&#39;</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">monotonous</span><span class="p">:</span>
            <span class="n">sh_initial</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_agg_grp_id&#39;</span><span class="p">,</span><span class="s1">&#39;_agg_shot_in_grp&#39;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            
        <span class="c1"># some sanity checks and status report</span>
        <span class="n">by_frame</span> <span class="o">=</span> <span class="p">(</span><span class="n">sh_initial</span><span class="p">[</span><span class="s1">&#39;frame&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">sh_initial</span><span class="p">[</span><span class="s1">&#39;_agg_shot_in_grp&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">nunique</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="n">by_run</span> <span class="o">=</span> <span class="p">(</span><span class="n">sh_initial</span><span class="p">[</span><span class="s1">&#39;run&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">sh_initial</span><span class="p">[</span><span class="s1">&#39;_agg_shot_in_grp&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">nunique</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Monotonous aggregation:&#39;</span><span class="p">,</span> <span class="n">monotonous</span><span class="p">,</span> <span class="s1">&#39;&#39;</span> <span class="k">if</span> <span class="n">monotonous</span> <span class="k">else</span> <span class="s1">&#39;(PLEASE CHECK IF THIS IS DESIRED)&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;File/subset remixing:&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;file&#39;</span> <span class="ow">in</span> <span class="n">cols_nonid</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="s1">&#39;subset&#39;</span> <span class="ow">in</span> <span class="n">cols_nonid</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Frame aggregation:&#39;</span><span class="p">,</span> <span class="n">by_frame</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Acq. run aggregation:&#39;</span><span class="p">,</span> <span class="n">by_run</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Discarding shot table columns:&#39;</span><span class="p">,</span> <span class="n">cols_nonid</span><span class="p">)</span>

        <span class="c1"># generate mandatory cols (if files/subsets are remixed):</span>
        <span class="k">def</span> <span class="nf">generate_common_name</span><span class="p">(</span><span class="n">name_list</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">reduce</span>
            <span class="kn">from</span> <span class="nn">difflib</span> <span class="kn">import</span> <span class="n">SequenceMatcher</span>
            <span class="k">return</span> <span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">s1</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">a</span><span class="p">:</span><span class="n">m</span><span class="o">.</span><span class="n">a</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="n">size</span><span class="p">]</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span>
                                                <span class="n">SequenceMatcher</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span><span class="o">.</span><span class="n">get_matching_blocks</span><span class="p">()]),</span> <span class="n">name_list</span><span class="p">)</span>
        <span class="n">missing</span> <span class="o">=</span> <span class="p">[</span><span class="n">fn</span> <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="s1">&#39;subset&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">fn</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cols_id</span><span class="p">]</span>
        <span class="n">ssfields</span> <span class="o">=</span> <span class="n">gb</span><span class="p">[</span><span class="n">missing</span><span class="p">]</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">generate_common_name</span><span class="p">)</span> <span class="k">if</span> <span class="n">missing</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="c1"># compute final shot list</span>
        <span class="n">sh_final</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">gb</span><span class="p">[</span><span class="n">cols_id</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;shot_in_subset&#39;</span><span class="p">,</span> <span class="s1">&#39;Event&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">gb</span><span class="o">.</span><span class="n">size</span><span class="p">()</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;agg_len&#39;</span><span class="p">),</span> <span class="n">ssfields</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">newset</span><span class="o">.</span><span class="n">_shots</span> <span class="o">=</span> <span class="n">sh_final</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        
        <span class="c1"># PART 2: DATA STACKS ---</span>
            
        <span class="c1"># aggregating functions</span>
        <span class="n">func_lib</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;sum&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                    <span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                    <span class="s1">&#39;first&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[:</span><span class="mi">1</span><span class="p">,</span><span class="o">...</span><span class="p">],</span>
                    <span class="s1">&#39;last&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:,</span><span class="o">...</span><span class="p">]}</span>
            
        <span class="k">for</span> <span class="n">sn</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stacks</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="k">if</span> <span class="n">sn</span> <span class="ow">in</span> <span class="n">exclude_stacks</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">method</span> <span class="o">=</span> <span class="n">how</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">sn</span><span class="p">,</span> <span class="s1">&#39;first&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">how</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="k">else</span> <span class="n">how</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">method</span> <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">method</span><span class="p">)</span> <span class="k">else</span> <span class="n">func_lib</span><span class="p">[</span><span class="n">method</span><span class="p">]</span>

            <span class="c1"># sliced and re-ordered stack</span>
            <span class="n">stk_sel</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">sh_initial</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">,</span><span class="o">...</span><span class="p">]</span>

            <span class="c1"># aggregated stack</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">stk_agg</span> <span class="o">=</span> <span class="n">_map_sub_blocks</span><span class="p">(</span><span class="n">stk_sel</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">sh_initial</span><span class="p">[</span><span class="s1">&#39;_agg_grp_id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                                      <span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;aggregate_&#39;</span><span class="o">+</span><span class="n">method</span><span class="p">,</span> <span class="n">aggregating</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Unknown aggregation method </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s1">. Allowed ones are </span><span class="si">{</span><span class="nb">tuple</span><span class="p">(</span><span class="n">func_lib</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;Mismatched chunk structure&#39;</span><span class="p">):</span>
                    <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Stack &#39;</span><span class="o">+</span><span class="n">sn</span><span class="o">+</span><span class="s1">&#39; has mismatched chunk structure. Rechunking to minimum chunk sizes. &#39;</span>
                         <span class="s1">&#39;Consider rechunking manually before, to improve performance.&#39;</span><span class="p">)</span>
                    <span class="c1">#TODO this comes with quite a performance penalty, but sth more complex would be comlex.</span>
                    <span class="n">stk_rec</span> <span class="o">=</span> <span class="n">stk_sel</span><span class="o">.</span><span class="n">rechunk</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">sh_final</span><span class="p">[</span><span class="s1">&#39;agg_len&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)})</span>
                    <span class="n">stk_agg</span> <span class="o">=</span> <span class="n">_map_sub_blocks</span><span class="p">(</span><span class="n">stk_rec</span><span class="p">,</span>
                                              <span class="n">labels</span><span class="o">=</span><span class="n">sh_initial</span><span class="p">[</span><span class="s1">&#39;_agg_grp_id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> 
                                              <span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;aggregate_&#39;</span><span class="o">+</span><span class="n">method</span><span class="p">,</span> 
                                              <span class="n">aggregating</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error during aggregation of stack &#39;</span> <span class="o">+</span> <span class="n">sn</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="n">e</span>
            
            <span class="n">newset</span><span class="o">.</span><span class="n">add_stack</span><span class="p">(</span><span class="n">sn</span><span class="p">,</span> <span class="n">stk_agg</span><span class="p">)</span>

        <span class="c1"># PART 3: OTHER STUFF ---</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">newset</span><span class="o">.</span><span class="n">_features</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_features</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">newset</span><span class="o">.</span><span class="n">_shots</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_feature_id_cols</span><span class="p">],</span>
                                                    <span class="n">on</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_feature_id_cols</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;inner&#39;</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="s1">&#39;1:m&#39;</span><span class="p">)</span><span class="o">.</span> \
                <span class="n">drop_duplicates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_feature_id_cols</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Could not aggregate features. Leaving them all in.&#39;</span><span class="p">)</span>

        <span class="n">newset</span><span class="o">.</span><span class="n">_file_handles</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">newset</span><span class="o">.</span><span class="n">change_filenames</span><span class="p">(</span><span class="n">file_suffix</span><span class="p">,</span> <span class="n">file_prefix</span><span class="p">,</span> <span class="n">new_folder</span><span class="p">,</span> <span class="n">keep_raw</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">newset</span><span class="o">.</span><span class="n">reset_id</span><span class="p">(</span><span class="n">keep_raw</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">newset</span><span class="o">.</span><span class="n">persist_stacks</span><span class="p">([</span><span class="n">sn</span> <span class="k">for</span> <span class="n">sn</span><span class="p">,</span> <span class="n">inmem</span> <span class="ow">in</span> <span class="n">newset</span><span class="o">.</span><span class="n">_stack_in_memory</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">inmem</span><span class="p">])</span>        

        <span class="k">return</span> <span class="n">newset</span></div>
    
<div class="viewcode-block" id="Dataset.transform_stack_groups"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.transform_stack_groups">[docs]</a>    <span class="k">def</span> <span class="nf">transform_stack_groups</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stacks</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">],</span> 
                               <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                               <span class="n">by</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;region&#39;</span><span class="p">,</span> <span class="s1">&#39;run&#39;</span><span class="p">,</span> <span class="s1">&#39;crystal_id&#39;</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;For all data stacks listed in stacks, transforms sub-stacks within groups defined by &quot;by&quot;.</span>
<span class="sd">        As a common example, applies some function to all frames of a diffraction movie. The dimensions of</span>
<span class="sd">        each sub-stack must not change in the process. Note that this happens in place, i.e., the stacks</span>
<span class="sd">        will be overwritten by a transformed version.</span>
<span class="sd">        A typical application is to calculate a cumulative sum of patterns wittin each diffraction movie. This</span>
<span class="sd">        is what the default parameter for func is doing. Can do all kinds of other fun things, i.e. calculating</span>
<span class="sd">        directly the difference between frames, the difference of each w.r.t. the first,</span>
<span class="sd">        normalizing them to sth, etc.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            stacks {List or str} -- Name(s) of data stacks to be transformed</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            func {Callable} -- Function applied to each sub-stack. Must act on a numpy</span>
<span class="sd">                array and return one of the same dimensions. </span>
<span class="sd">                Defaults to: lambda x: np.cumsum(x, axis=0)</span>
<span class="sd">            by {List} -- Shot table columns to identify groups. </span>
<span class="sd">                Defaults to [&#39;sample&#39;, &#39;region&#39;, &#39;run&#39;, &#39;crystal_id&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">stacks</span> <span class="o">=</span> <span class="p">[</span><span class="n">stacks</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stacks</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">stacks</span>
        <span class="n">by</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">by</span><span class="p">)</span>
        <span class="n">feature_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">by</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">ngroup</span><span class="p">()</span><span class="o">.</span><span class="n">values</span>
        <span class="k">for</span> <span class="n">sn</span> <span class="ow">in</span> <span class="n">stacks</span><span class="p">:</span>
            <span class="n">transformed</span> <span class="o">=</span> <span class="n">_map_sub_blocks</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stacks</span><span class="p">[</span><span class="n">sn</span><span class="p">],</span> <span class="n">feature_id</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">aggregating</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_stack</span><span class="p">(</span><span class="n">sn</span><span class="p">,</span> <span class="n">transformed</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">persist_stacks</span><span class="p">([</span><span class="n">sn</span> <span class="k">for</span> <span class="n">sn</span> <span class="ow">in</span> <span class="n">stacks</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stack_in_memory</span><span class="p">[</span><span class="n">sn</span><span class="p">]])</span></div>

<div class="viewcode-block" id="Dataset.init_stacks"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.init_stacks">[docs]</a>    <span class="k">def</span> <span class="nf">init_stacks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Opens stacks briefly, to check their sizes etc., and closes them again right away. Helpful to just get their</span>
<span class="sd">        names and sizes...</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;init_stacks is pretty much never required. Double-check if you really need it.&#39;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">open_stacks</span><span class="p">(</span><span class="n">init</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">readonly</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close_stacks</span><span class="p">()</span></div>

<div class="viewcode-block" id="Dataset.close_stacks"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.close_stacks">[docs]</a>    <span class="k">def</span> <span class="nf">close_stacks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Close the stacks by closing the HDF5 data file handles.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_file_handles</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">del</span> <span class="n">f</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_file_handles</span> <span class="o">=</span> <span class="p">{}</span></div>

<div class="viewcode-block" id="Dataset.open_stacks"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.open_stacks">[docs]</a>    <span class="k">def</span> <span class="nf">open_stacks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">checklen</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
        <span class="n">readonly</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">swmr</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">chunking</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;dataset&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Opens data stacks from HDF5 (NeXus) files (found by the &quot;data_pattern&quot; attribute), and assigns dask array</span>
<span class="sd">        objects to them. After opening, the arrays or parts of them can be accessed through the stacks attribute,</span>
<span class="sd">        or directly using a dataset.stack syntax, and loaded using the .compute() method of the arrays.</span>
<span class="sd">        Note that, while the stacks are open, no other python kernel will be able to access the data files, and other</span>
<span class="sd">        codes may not see the modifications made. You will have to call dataset.close_stacks() before.</span>
<span class="sd">        :param labels: list of stacks to open. Default: None -&gt; opens all stacks</span>
<span class="sd">        :param checklen: check if stack heights (first dimension) is equal to shot list length</span>
<span class="sd">        :param init: do not load stacks, just make empty dask arrays. Usually the init_stacks method is more useful.</span>
<span class="sd">        :param readonly: open HDF5 files in read-only mode (Default: True)</span>
<span class="sd">        :param swmr: open HDF5 files in SWMR mode (Default: False)</span>
<span class="sd">        :param chunking: how should the dask arrays be chunked along the 0th (stack) direction. Options are,</span>
<span class="sd">            in decreasing order of recommendation: </span>
<span class="sd">            * None, which tries all good options and fails if none works</span>
<span class="sd">            * &#39;dataset&#39; to use what is set in the current dataset zchunks property (default)</span>
<span class="sd">            * &#39;existing&#39; to use the chunking of an already-existing stack which is about to be overwritten.</span>
<span class="sd">                Should usually be the same as &#39;dataset&#39;</span>
<span class="sd">            * &#39;hdf5&#39; to use the chunksize recommended in the HDF5 file (&#39;recommended_zchunks&#39; attribute) of the</span>
<span class="sd">                data stacks group</span>
<span class="sd">            * an integer number for a defined (approximate) chunk size, which ignores shots with frame number &lt; -1,</span>
<span class="sd">            * an iterable to explicitly set the chunk sizes</span>
<span class="sd">            * &#39;auto&#39; to use the dask automatic mode</span>
<span class="sd">        Generally, a fixed number (integer or iterable) is recommended and gives the least trouble.</span>
<span class="sd">        already been chunked before. For a fixed number, the chunks are done such that after filtering of frame == -1 shots,</span>
<span class="sd">        a constant chunk size is achieved.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">readonly</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_files_open</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_files_writable</span><span class="p">)</span> <span class="ow">or</span> \
            <span class="p">(</span><span class="n">readonly</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_files_writable</span><span class="p">):</span>
                
            <span class="k">if</span> <span class="n">chunking</span> <span class="o">!=</span> <span class="s1">&#39;existing&#39;</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Reopening files in a different mode. Chunking will be set to &quot;existing&quot;.&#39;</span><span class="p">)</span>
                <span class="n">chunking</span> <span class="o">=</span> <span class="s1">&#39;existing&#39;</span>
                
            <span class="c1"># reopen the stacks in a different mode!</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">close_stacks</span><span class="p">()</span>
            
        <span class="k">if</span> <span class="ow">not</span> <span class="n">readonly</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_files_writable</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">swmr</span><span class="p">:</span>
            <span class="c1"># write access already. Nobody else had access anyway</span>
            <span class="k">return</span>
               
        <span class="c1"># TODO offer even more sophisticated chunking which always aligns with frames</span>
        <span class="k">if</span> <span class="s1">&#39;frame&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">sets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="p">[[</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="s1">&#39;subset&#39;</span><span class="p">,</span> <span class="s1">&#39;shot_in_subset&#39;</span><span class="p">,</span> <span class="s1">&#39;frame&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span> <span class="c1"># TODO why is the drop duplicates required?</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="p">[[</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="s1">&#39;subset&#39;</span><span class="p">,</span> <span class="s1">&#39;shot_in_subset&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span>
            <span class="n">sets</span><span class="p">[</span><span class="s1">&#39;frame&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">stacks</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">chunking</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">chunking</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">chunking</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            
        <span class="k">elif</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">chunking</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">chunking</span><span class="o">==</span><span class="s1">&#39;dataset&#39;</span><span class="p">):</span>
            <span class="n">chunking</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zchunks</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                
        <span class="k">for</span> <span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">subset</span><span class="p">),</span> <span class="n">subgrp</span> <span class="ow">in</span> <span class="n">sets</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="s1">&#39;subset&#39;</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_file_handles</span><span class="p">[</span><span class="n">fn</span><span class="p">]</span> <span class="o">=</span> <span class="n">fh</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">swmr</span><span class="o">=</span><span class="n">swmr</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span> <span class="k">if</span> <span class="n">readonly</span> <span class="k">else</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">chunking</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">subgrp</span><span class="o">.</span><span class="n">frame</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="c1"># print(&#39;Found auxiliary frames, adjusting chunking...&#39;)</span>
                <span class="c1"># frames = subgrp[[&#39;frame&#39;]].copy()</span>
                <span class="n">blocks</span> <span class="o">=</span> <span class="p">((</span><span class="n">subgrp</span><span class="p">[</span><span class="s1">&#39;frame&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">chunking</span>
                <span class="n">zchunks</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">subgrp</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">blocks</span><span class="p">)[</span><span class="s1">&#39;frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">())</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">chunking</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">zchunks</span> <span class="o">=</span> <span class="n">chunking</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">chunking</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">chk</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">Nshot</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">subgrp</span><span class="p">)</span>
                <span class="k">while</span> <span class="n">Nshot</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">chk</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chunking</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>
                    <span class="n">Nshot</span> <span class="o">-=</span> <span class="n">chk</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">Nshot</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Requested chunking is incommensurate with file/subset boundaries!&#39;</span><span class="p">)</span>
                <span class="n">zchunks</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">chk</span><span class="p">)</span>      
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">chunking</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">chunking</span> <span class="o">==</span> <span class="s1">&#39;hdf5&#39;</span><span class="p">:</span>
                <span class="n">zchunks</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">fh</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">data_pattern</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;%&#39;</span><span class="p">,</span> <span class="n">subset</span><span class="p">)]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;recommended_zchunks&#39;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">zchunks</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">grp</span> <span class="o">=</span> <span class="n">fh</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">data_pattern</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;%&#39;</span><span class="p">,</span> <span class="n">subset</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grp</span><span class="p">,</span> <span class="n">h5py</span><span class="o">.</span><span class="n">Group</span><span class="p">):</span>
                <span class="n">curr_lbl</span> <span class="o">=</span> <span class="n">grp</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;signal&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">curr_lbl</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">curr_lbl</span> <span class="o">=</span> <span class="n">curr_lbl</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_diff_stack_label</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_diff_stack_label</span> <span class="o">=</span> <span class="n">curr_lbl</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_diff_stack_label</span> <span class="o">!=</span> <span class="n">curr_lbl</span><span class="p">:</span>
                    <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Non-matching primary diffraction stack labels: &#39;</span>
                         <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_diff_stack_label</span><span class="si">}</span><span class="s1"> vs </span><span class="si">{</span><span class="n">grp</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;signal&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                
                <span class="k">for</span> <span class="n">dsname</span><span class="p">,</span> <span class="n">ds</span> <span class="ow">in</span> <span class="n">grp</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">ds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="c1"># can happen for dangling soft links</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="p">((</span><span class="n">labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">dsname</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">))</span> \
                            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">h5py</span><span class="o">.</span><span class="n">Dataset</span><span class="p">)</span> \
                            <span class="ow">and</span> <span class="p">(</span><span class="s1">&#39;pandas_type&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">attrs</span><span class="p">):</span>
                        <span class="c1"># h5 dataset for file/subset found!</span>
                        <span class="k">if</span> <span class="n">checklen</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">subgrp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Stack height mismatch in f</span><span class="si">{</span><span class="n">fn</span><span class="si">}</span><span class="s1">:</span><span class="si">{</span><span class="n">subset</span><span class="si">}</span><span class="s1">. &#39;</span> <span class="o">+</span>
                                             <span class="sa">f</span><span class="s1">&#39;Expected </span><span class="si">{</span><span class="n">subgrp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> shots, found </span><span class="si">{</span><span class="n">ds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
                        
                        <span class="k">if</span> <span class="n">zchunks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">chunks</span> <span class="o">=</span> <span class="p">(</span><span class="n">zchunks</span><span class="p">,)</span> <span class="o">+</span> <span class="n">ds</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                        <span class="k">elif</span> <span class="n">chunking</span> <span class="o">==</span> <span class="s1">&#39;hdf5&#39;</span><span class="p">:</span>
                            <span class="n">chunks</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">chunks</span>
                        <span class="k">elif</span> <span class="n">chunking</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
                            <span class="n">chunks</span> <span class="o">=</span> <span class="s1">&#39;auto&#39;</span>
                        <span class="k">elif</span> <span class="n">chunking</span> <span class="o">==</span> <span class="s1">&#39;existing&#39;</span><span class="p">:</span>
                            <span class="n">chunks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stacks</span><span class="p">[</span><span class="n">dsname</span><span class="p">][</span><span class="n">subgrp</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">,</span><span class="o">...</span><span class="p">]</span><span class="o">.</span><span class="n">chunks</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;chunking must be an integer, list, tuple, &quot;dataset&quot;, or &quot;auto&quot;.&#39;</span><span class="p">)</span>
                        
                        <span class="n">stackname</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
                                                <span class="n">subset</span><span class="p">,</span> <span class="n">dsname</span><span class="p">])</span>

                        <span class="k">if</span> <span class="n">init</span><span class="p">:</span>
                            <span class="n">newstack</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">ds</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ds</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">stackname</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># print(&#39;adding stack: &#39;+ds.name)</span>
                            <span class="n">newstack</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">stackname</span><span class="p">)</span>
                        <span class="n">stacks</span><span class="p">[</span><span class="n">dsname</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newstack</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">sn</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stacks</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_stacks</span><span class="p">[</span><span class="n">sn</span><span class="p">]</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> 
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Could not read stack </span><span class="si">{</span><span class="n">sn</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Dataset.Stacks"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.Stacks">[docs]</a>    <span class="nd">@contextmanager</span>
    <span class="k">def</span> <span class="nf">Stacks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Context manager to handle the opening and closing of stacks.</span>
<span class="sd">        returns the opened data stacks, which are automatically closed</span>
<span class="sd">        once the context is left. Arguments are passed to open_stacks Example:</span>
<span class="sd">            with ds.Stacks(readonly=True, chunking=&#39;dataset&#39;) as stk:</span>
<span class="sd">                center = stk.beam_center.compute()</span>
<span class="sd">            print(&#39;Have&#39;, center.shape[0], &#39;centers.&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Use of the Stacks context manager is deprecated and may cause pain and sorrow.&#39;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">open_stacks</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">stacks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close_stacks</span><span class="p">()</span></div>

<div class="viewcode-block" id="Dataset.add_stack"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.add_stack">[docs]</a>    <span class="k">def</span> <span class="nf">add_stack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">stack</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">h5py</span><span class="o">.</span><span class="n">Dataset</span><span class="p">],</span> 
                  <span class="n">overwrite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">diff_stack</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                  <span class="n">persist</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">rechunk</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a data stack to the data set</span>
<span class="sd">        :param label: label of the new stack</span>
<span class="sd">        :param stack: new stack, can be anything array-like</span>
<span class="sd">        :param overwrite: allows overwriting an existing stack</span>
<span class="sd">        :param diff_stack: marks this stack as the main diffraction data</span>
<span class="sd">        :param persist: persists the dask array to memory, if it is generated</span>
<span class="sd">            from a numpy array</span>
<span class="sd">        :param rechunk: if True, a dask array with chunks along the stack direction that don&#39;t match the datasets</span>
<span class="sd">            other stacks chunks will be rechunked. Otherwise, a warning is shown.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">stack</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Stack height must equal that of the shot list.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stacks</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">overwrite</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Stack with name </span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s1"> already exists. Set overwrite = True.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">):</span>
            <span class="n">ch</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">ndim</span> <span class="o">*</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">ch</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zchunks</span>          
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">persist</span><span class="p">:</span>
                <span class="n">stack</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ch</span><span class="p">))</span><span class="o">.</span><span class="n">persist</span><span class="p">(</span><span class="n">scheduler</span><span class="o">=</span><span class="s1">&#39;threading&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stack</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ch</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zchunks</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zchunks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">rechunk</span><span class="p">:</span>
                    <span class="n">stack</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">rechunk</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">zchunks</span><span class="p">})</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Stack has a different chunking than the dataset!&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">diff_stack</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_diff_stack_label</span> <span class="o">=</span> <span class="n">label</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_stacks</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">stack</span></div>

<div class="viewcode-block" id="Dataset.delete_stack"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.delete_stack">[docs]</a>    <span class="k">def</span> <span class="nf">delete_stack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">from_files</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delete a data stack</span>
<span class="sd">        :param label: stack label</span>
<span class="sd">        :param from_files: if True, the stack is also deleted in the HDF5 files. Default False.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stacks</span><span class="p">[</span><span class="n">label</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Stack </span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s1"> does not exist, not deleting anything.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">label</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_diff_stack_label</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_diff_stack_label</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Deleting diffraction data stack </span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">from_files</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">address</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="p">[[</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="s1">&#39;subset&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_pattern</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;%&#39;</span><span class="p">,</span> <span class="n">address</span><span class="o">.</span><span class="n">subset</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">label</span>
                <span class="c1">#print(f&#39;Deleting dataset {path}&#39;)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_file_handles</span><span class="p">[</span><span class="n">address</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">]][</span><span class="n">path</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">pass</span></div>
                    <span class="c1">#print(address[&#39;file&#39;], path, &#39;not found!&#39;)</span>
                    
<div class="viewcode-block" id="Dataset.persist_stacks"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.persist_stacks">[docs]</a>    <span class="k">def</span> <span class="nf">persist_stacks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">exclude</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="n">include_3d</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">scheduler</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Client</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;threading&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Persist the stacks to memory (locally and/or on the cluster workers), that is, they are computed.</span>
<span class="sd">        but actually not changed to numpy arrays, just immediately available dask arrays without an actual</span>
<span class="sd">        task graph. It is recommended to have as many stacks persisted as possible.</span>
<span class="sd">        The diffraction data stack is automatically excluded.</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            labels {Union[None, str, list]} -- [description] (default: {None})</span>
<span class="sd">            exclude {Union[None, str, list]} -- [description] (default: {None})</span>
<span class="sd">            include_3d {bool} -- [description] (default: {False})</span>
<span class="sd">            scheduler {} -- </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_stacks</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">labels</span><span class="p">]</span>          
              
        <span class="k">if</span> <span class="n">exclude</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exclude</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exclude</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">exclude</span> <span class="o">=</span> <span class="p">[</span><span class="n">exclude</span><span class="p">]</span>
            
        <span class="k">if</span> <span class="ow">not</span> <span class="n">include_3d</span><span class="p">:</span>
            <span class="n">exclude</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">sn</span> <span class="k">for</span> <span class="n">sn</span><span class="p">,</span> <span class="n">stk</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stacks</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">stk</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">])</span>
            
        <span class="n">exclude</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_diff_stack_label</span><span class="p">)</span>
        
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">labels</span> <span class="k">if</span> <span class="n">l</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclude</span><span class="p">]</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Persisting stacks to memory:&#39;</span><span class="p">,</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">labels</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stacks</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dask</span><span class="o">.</span><span class="n">persist</span><span class="p">({</span><span class="n">sn</span><span class="p">:</span> <span class="n">stk</span> <span class="k">for</span> <span class="n">sn</span><span class="p">,</span> <span class="n">stk</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stacks</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">stk</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">},</span> 
                                         <span class="n">scheduler</span><span class="o">=</span><span class="n">scheduler</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span></div>

<div class="viewcode-block" id="Dataset.store_stacks"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.store_stacks">[docs]</a>    <span class="k">def</span> <span class="nf">store_stacks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">exclude</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                    <span class="n">compression</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">32004</span><span class="p">,</span> <span class="n">lazy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">data_pattern</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                    <span class="n">progress_bar</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">scheduler</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;threading&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Stores stacks with given labels to the HDF5 data files. If None (default), stores all stacks. New stacks are</span>
<span class="sd">        typically not yet computed, so at this point the actual data crunching is done. Note that this way of computing</span>
<span class="sd">        and storing data is restricted to threading or single-threaded computation, i.e. it&#39;s not recommended for</span>
<span class="sd">        heavy lifting. In this case, better use store_stack_fast.</span>
<span class="sd">        :param labels: stack(s) to be written</span>
<span class="sd">        :param exclude: stack(s) to be excluded</span>
<span class="sd">        :param overwrite: overwrite stacks already existing in the files?</span>
<span class="sd">        :param compression: compression algorithm to be used. 32004 corresponds to bz4, which we mostly use.</span>
<span class="sd">        :param lazy: if True, instead of writing the shots, returns two lists containing the arrays and dataset objects</span>
<span class="sd">                        which can be used to later pass them to dask.array.store. Default False (store right away)</span>
<span class="sd">        :param data_pattern: store stacks to this data path (% is replaced by subset) instead of standard path.</span>
<span class="sd">                        Note that stacks stored this way will not be retrievable through Dataset objects.</span>
<span class="sd">        :param progress_bar: show a progress bar during calculation/storing. Disable if you&#39;re running store_stacks</span>
<span class="sd">                        in multiple processes simultaneously.</span>
<span class="sd">        :param scheduler: dask scheduler to be used. Can be &#39;threading&#39; or &#39;single-threaded&#39;</span>
<span class="sd">        :param **kwargs: will be forwarded to h5py.create_dataset</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_files_writable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Please open files in write mode before storing.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stacks</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">labels</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">exclude</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exclude</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exclude</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">exclude</span> <span class="o">=</span> <span class="p">[</span><span class="n">exclude</span><span class="p">]</span>
            
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">labels</span> <span class="k">if</span> <span class="n">l</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclude</span><span class="p">]</span>
        
        <span class="n">stacks</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stacks</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">}</span>
        <span class="n">stacks</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;index&#39;</span><span class="p">:</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zchunks</span><span class="p">,))})</span>

        <span class="n">datasets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">arrays</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">shots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>  <span class="c1"># just to be safe</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">ssn</span><span class="p">),</span> <span class="n">sss</span> <span class="ow">in</span> <span class="n">shots</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="s1">&#39;subset&#39;</span><span class="p">]):</span>
            <span class="n">fh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_handles</span><span class="p">[</span><span class="n">fn</span><span class="p">]</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">sss</span><span class="o">.</span><span class="n">shot_in_subset</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Non-continuous shot_in_subset in </span><span class="si">{</span><span class="n">fn</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">ssn</span><span class="si">}</span><span class="s1">. Please sort out this mess.&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">sss</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">stack_idcs</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">sss</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sss</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stack_idcs</span> <span class="o">=</span> <span class="n">sss</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># pathological case: non-continuous region in shot list</span>
                <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Shots for </span><span class="si">{</span><span class="n">fn</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">ssn</span><span class="si">}</span><span class="s1"> are non-contiguous in the shot list. Might hint at trouble.&#39;</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">stack</span> <span class="ow">in</span> <span class="n">stacks</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># print(label)</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="n">stack_idcs</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">data_pattern</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_pattern</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;%&#39;</span><span class="p">,</span> <span class="n">ssn</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">label</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">path</span> <span class="o">=</span> <span class="n">data_pattern</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;%&#39;</span><span class="p">,</span> <span class="n">ssn</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">label</span>

                <span class="c1">#print(&#39;Writing to &#39;, path)</span>
                <span class="k">try</span><span class="p">:</span>

                    <span class="c1"># print(path, cs, arr.shape)</span>
                    <span class="n">ds</span> <span class="o">=</span> <span class="n">fh</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                                           <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>
                                           <span class="n">compression</span><span class="o">=</span><span class="n">compression</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">except</span> <span class="p">(</span><span class="ne">RuntimeError</span><span class="p">,</span> <span class="ne">OSError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;name already exists&#39;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="n">overwrite</span> <span class="ow">or</span> <span class="n">label</span> <span class="o">==</span> <span class="s1">&#39;index&#39;</span><span class="p">):</span>
                        <span class="n">ds</span> <span class="o">=</span> <span class="n">fh</span><span class="o">.</span><span class="n">require_dataset</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                                                <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>
                                                <span class="n">compression</span><span class="o">=</span><span class="n">compression</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Cannot write stack&#39;</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>
                        <span class="k">raise</span> <span class="n">e</span>
                
                <span class="c1"># if label == &#39;index&#39;:</span>
                <span class="c1">#     fh[path.rsplit(&#39;/&#39;, 1)[0]].attrs[&#39;recommended_zchunks&#39;] = np.array(arr.chunks[0])</span>
                <span class="c1">#     fh[path.rsplit(&#39;/&#39;, 1)[0]].attrs[&#39;signal&#39;] = self._diff_stack_label</span>

                <span class="n">arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
                <span class="n">datasets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">lazy</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">arrays</span><span class="p">,</span> <span class="n">datasets</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">catch_warnings</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">progress_bar</span><span class="p">:</span>
                    <span class="k">with</span> <span class="n">ProgressBar</span><span class="p">():</span>
                        <span class="n">da</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">datasets</span><span class="p">,</span> <span class="n">scheduler</span><span class="o">=</span><span class="n">scheduler</span><span class="p">,</span> <span class="n">return_stored</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">da</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">datasets</span><span class="p">,</span> <span class="n">scheduler</span><span class="o">=</span><span class="n">scheduler</span><span class="p">,</span> <span class="n">return_stored</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">fh</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_handles</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">fh</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span></div>
                
<div class="viewcode-block" id="Dataset.store_stack_fast"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.store_stack_fast">[docs]</a>    <span class="k">def</span> <span class="nf">store_stack_fast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">client</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Client</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">sync</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                         <span class="n">compression</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="mi">32004</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Store (and compute) a single stack to HDF5 file(s), using a dask.distributed cluster.</span>
<span class="sd">        This allows for proper parallel computation (even on many machines) and is wa(aaa)y faster</span>
<span class="sd">        than the standard store_stacks, which only works with threads.</span>
<span class="sd">        It also sets the signal attribute in the NeXus-compliant data group to the given label.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            label {str} -- Label of the stack to be computed and stored. If None, use the _diff_stack</span>
<span class="sd">                setting.</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            client {Optional[Client]} -- dask.distributed client object. Mandatorily required </span>
<span class="sd">                if sync=True. (default: {None})</span>
<span class="sd">            sync {bool} -- if True (default), computes and stores immediately, and returns a pandas </span>
<span class="sd">                dataframe containing metadata of everything stored, for validation. If False,</span>
<span class="sd">                returns a list of dask.delayed objects which encapsulate the computation/storage.</span>
<span class="sd">            compression {Union[int, str]} -- Compression of the dataset to be stored. </span>
<span class="sd">                Defaults to 32004, which is LZ4. Viable alternatives are &#39;gzip&#39;, &#39;lzf&#39;, or &#39;none&#39;.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: [description]</span>

<span class="sd">        Returns:</span>
<span class="sd">            pd.DataFrame (if sync=True), list of dask.delayed (if sync=False)</span>
<span class="sd">            </span>
<span class="sd">        Remarks:</span>
<span class="sd">            If the stack to be stored depends on computationally heavy (but memory-fitting) dask</span>
<span class="sd">            arrays which you want to retain outside this computation (e.g. to store them using</span>
<span class="sd">            store_stacks), consider persisting them (using da.persist) before calling sthis function.</span>
<span class="sd">            Otherwise, they will be re-calculated from scratch.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_diff_stack_label</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_files_open</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_files_writable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Please open files in write mode or close them before storing.&#39;</span><span class="p">)</span>
        
        <span class="kn">from</span> <span class="nn">distributed</span> <span class="kn">import</span> <span class="n">Lock</span>

        <span class="n">stack</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stacks</span><span class="p">[</span><span class="n">label</span><span class="p">]</span>
            
        <span class="c1"># initialize datasets in files</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">subset</span><span class="p">),</span> <span class="n">grp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="s1">&#39;subset&#39;</span><span class="p">]):</span>
            <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
                <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_pattern</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;%&#39;</span><span class="p">,</span> <span class="n">subset</span><span class="p">)</span>
                <span class="n">fh</span><span class="o">.</span><span class="n">require_dataset</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> 
                                        <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">grp</span><span class="p">),)</span> <span class="o">+</span> <span class="n">stack</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> 
                                        <span class="n">dtype</span><span class="o">=</span><span class="n">stack</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> 
                                        <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">stack</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> 
                                        <span class="n">compression</span><span class="o">=</span><span class="n">compression</span><span class="p">)</span>
                <span class="n">fh</span><span class="p">[</span><span class="n">path</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;signal&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">label</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">close_stacks</span><span class="p">()</span>
        
        <span class="n">chunk_label</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">cs</span><span class="p">)</span> <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">cs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span>
        <span class="n">stk_del</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">to_delayed</span><span class="p">()</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="n">locks</span> <span class="o">=</span> <span class="p">{</span><span class="n">fn</span><span class="p">:</span> <span class="n">Lock</span><span class="p">()</span> <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">}</span>

        <span class="n">dels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">chk</span><span class="p">,</span> <span class="p">(</span><span class="n">cl</span><span class="p">,</span> <span class="n">sht</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">stk_del</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">chunk_label</span><span class="p">)):</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">sht</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">([</span><span class="s1">&#39;file&#39;</span><span class="p">,</span><span class="s1">&#39;subset&#39;</span><span class="p">]))</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="n">ii_to</span> <span class="o">=</span> <span class="n">sht</span><span class="o">.</span><span class="n">shot_in_subset</span><span class="o">.</span><span class="n">values</span>
            <span class="n">dels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dask</span><span class="o">.</span><span class="n">delayed</span><span class="p">(</span><span class="n">nexus</span><span class="o">.</span><span class="n">_save_single_chunk</span><span class="p">)(</span><span class="n">chk</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sht</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">subset</span><span class="o">=</span><span class="n">sht</span><span class="o">.</span><span class="n">subset</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                                <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span> <span class="n">idcs</span><span class="o">=</span><span class="n">ii_to</span><span class="p">,</span> <span class="n">data_pattern</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_pattern</span><span class="p">,</span> 
                                <span class="n">lock</span><span class="o">=</span><span class="n">locks</span><span class="p">[</span><span class="n">sht</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>
            
        <span class="k">if</span> <span class="ow">not</span> <span class="n">sync</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dels</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># THIS DOES THE ACTUAL COMPUTATION/DATA STORAGE</span>
            <span class="k">if</span> <span class="n">client</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;If immediate computation is desired (sync=True), you have to provide a cluster.&#39;</span><span class="p">)</span>
            <span class="kn">import</span> <span class="nn">random</span>
            <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">dels</span><span class="p">)</span> <span class="c1"># shuffling tasks to minimize concurrent file access</span>
            <span class="n">chunk_info</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">dels</span><span class="p">,</span> <span class="n">sync</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">chunk_info</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="s1">&#39;subset&#39;</span><span class="p">,</span> <span class="s1">&#39;path&#39;</span><span class="p">,</span> <span class="s1">&#39;shot_in_subset&#39;</span><span class="p">])</span></div>
        
<div class="viewcode-block" id="Dataset.compute_and_save"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.compute_and_save">[docs]</a>    <span class="k">def</span> <span class="nf">compute_and_save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">diff_stack_label</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">list_file</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">client</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Client</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                         <span class="n">exclude_stacks</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">persist_diff</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> 
                         <span class="n">persist_all</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">compression</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">32004</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compound method to fully compute a dataset and write it to disk. It is designed for completely writing HDF5 </span>
<span class="sd">        files from scratch, not to append to existing ones. Internally calls init_files, store_tables, store_stacks,</span>
<span class="sd">        store_stack_fast, and write_list. </span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            diff_stack_label {Optional[str]} -- [description] (default: {None})</span>
<span class="sd">            list_file {Optional[str]} -- [description] (default: {None})</span>
<span class="sd">            client {Optional[Client]} -- [description] (default: {None})</span>
<span class="sd">            exclude_stacks {Optional[List[str]]} -- [description] (default: {None})</span>
<span class="sd">            overwrite {bool} -- [description] (default: {False})</span>
<span class="sd">            persist_diff {bool} -- [description] (default: {True})</span>
<span class="sd">            persist_all {bool} -- [description] (default: {False})</span>
<span class="sd">            compression {Union[str, int]} -- [description] (default: {32004})</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: [description]</span>
<span class="sd">            ValueError: [description]</span>
<span class="sd">            ValueError: [description]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#TODO generalize to storing several diffraction stacks using sync=False.</span>
        
        <span class="k">if</span> <span class="n">diff_stack_label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">diff_stack_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diff_stack_label</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">diff_stack_label</span> <span class="k">else</span> <span class="kc">None</span>
         
        <span class="k">if</span> <span class="p">(</span><span class="n">diff_stack_label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">diff_stack_label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stacks</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Stack </span><span class="si">{</span><span class="n">diff_stack_label</span><span class="si">}</span><span class="s1"> not found in dataset.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">diff_stack_label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">client</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;If a diffraction data stack is specified, you must supply a dask.distributed client object.&#39;</span><span class="p">)</span>        
            
        <span class="k">for</span> <span class="n">dn</span> <span class="ow">in</span> <span class="p">{</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">}:</span>
            <span class="k">if</span> <span class="n">dn</span><span class="p">:</span>
                <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">exclude_stacks</span> <span class="o">=</span> <span class="p">[</span><span class="n">exclude_stacks</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exclude_stacks</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">exclude_stacks</span>
        <span class="n">exclude_stacks</span> <span class="o">=</span> <span class="p">[</span><span class="n">diff_stack_label</span><span class="p">]</span> <span class="k">if</span> <span class="n">exclude_stacks</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[</span><span class="n">diff_stack_label</span><span class="p">]</span> <span class="o">+</span> <span class="n">exclude_stacks</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">close_stacks</span><span class="p">()</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Initializing data files...&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_files</span><span class="p">(</span><span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Storing meta tables...&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">store_tables</span><span class="p">()</span>

        <span class="c1"># store all data stacks except for the actual diffraction data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">open_stacks</span><span class="p">(</span><span class="n">readonly</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        
        <span class="n">meta_stacks</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stacks</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclude_stacks</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Storing meta stacks </span><span class="si">{</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">meta_stacks</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">dask</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">scheduler</span><span class="o">=</span><span class="s1">&#39;threading&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">store_stacks</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="n">meta_stacks</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="n">compression</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Storing diffraction data stack </span><span class="si">{</span><span class="n">diff_stack_label</span><span class="si">}</span><span class="s1">... monitor progress at </span><span class="si">{</span><span class="n">client</span><span class="o">.</span><span class="n">dashboard_link</span><span class="si">}</span><span class="s1"> (or forward port if remote)&#39;</span><span class="p">)</span>
        <span class="n">chunk_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">store_stack_fast</span><span class="p">(</span><span class="n">diff_stack_label</span><span class="p">,</span> <span class="n">client</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="n">compression</span><span class="p">)</span>

        <span class="c1"># make sure that the calculation went consistent with the data set</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">sh</span><span class="p">,</span> <span class="n">sh_grp</span><span class="p">),</span> <span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">ch_grp</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="s1">&#39;subset&#39;</span><span class="p">]),</span> <span class="n">chunk_info</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="s1">&#39;subset&#39;</span><span class="p">])):</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">sh_grp</span><span class="o">.</span><span class="n">shot_in_subset</span><span class="o">.</span><span class="n">values</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">ch_grp</span><span class="o">.</span><span class="n">shot_in_subset</span><span class="o">.</span><span class="n">values</span><span class="p">))):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Incosistency between calculated data and shot list in </span><span class="si">{</span><span class="n">sh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">sh</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1"> found. Please investigate.&#39;</span><span class="p">)</span>
                
        <span class="k">if</span> <span class="n">list_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write_list</span><span class="p">(</span><span class="n">list_file</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">persist_all</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">open_stacks</span><span class="p">(</span><span class="n">readonly</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">chunking</span><span class="o">=</span><span class="s1">&#39;existing&#39;</span><span class="p">)</span>
            
        <span class="k">elif</span> <span class="n">persist_diff</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">open_stacks</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="n">diff_stack_label</span><span class="p">],</span> <span class="n">readonly</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">chunking</span><span class="o">=</span><span class="s1">&#39;existing&#39;</span><span class="p">)</span></div>
            
    <span class="c1">#     else:</span>
    <span class="c1">#         ds_compute.open_stacks(labels=[]) # only populate the file handle list</span>

<div class="viewcode-block" id="Dataset.rechunk_stacks"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.rechunk_stacks">[docs]</a>    <span class="k">def</span> <span class="nf">rechunk_stacks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chunk_height</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">chunk_height</span>
        <span class="n">ss_chunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="s1">&#39;subset&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">size</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="p">((</span><span class="n">l</span> <span class="o">//</span> <span class="n">c</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="n">c</span><span class="p">])</span> <span class="o">+</span> <span class="p">[</span><span class="n">l</span> <span class="o">%</span> <span class="n">c</span><span class="p">])</span>
        <span class="n">zchunks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ss_chunk</span><span class="p">])</span>
        <span class="k">assert</span> <span class="n">zchunks</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">sn</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stacks</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_stack</span><span class="p">(</span><span class="n">sn</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">rechunk</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">zchunks</span><span class="p">)}),</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="Dataset.stacks_to_shots"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.stacks_to_shots">[docs]</a>    <span class="k">def</span> <span class="nf">stacks_to_shots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stack_labels</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">],</span> <span class="n">shot_labels</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stack_labels</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">stack_labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">stack_labels</span><span class="p">,]</span>
        <span class="k">if</span> <span class="n">shot_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shot_labels</span> <span class="o">=</span> <span class="n">stack_labels</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shot_labels</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">shot_labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">shot_labels</span><span class="p">,]</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">Stacks</span><span class="p">()</span> <span class="k">as</span> <span class="n">stk</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">lbl_from</span><span class="p">,</span> <span class="n">lbl_to</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">stack_labels</span><span class="p">,</span> <span class="n">shot_labels</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">lbl_from</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">stk</span><span class="p">:</span>
                    <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">lbl_from</span><span class="si">}</span><span class="s1"> not in stacks, skipping.&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="p">[</span><span class="n">lbl_to</span><span class="p">]</span> <span class="o">=</span> <span class="n">stk</span><span class="p">[</span><span class="n">lbl_from</span><span class="p">]</span></div>
            
<div class="viewcode-block" id="Dataset.merge_pattern_info"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.merge_pattern_info">[docs]</a>    <span class="k">def</span> <span class="nf">merge_pattern_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ds_from</span><span class="p">:</span> <span class="s1">&#39;Dataset&#39;</span><span class="p">,</span> <span class="n">merge_cols</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                           <span class="n">by</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;region&#39;</span><span class="p">,</span> <span class="s1">&#39;run&#39;</span><span class="p">,</span> <span class="s1">&#39;crystal_id&#39;</span><span class="p">),</span> 
                           <span class="n">persist</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Merge shot table columns and peak data from another data set into this one, based</span>
<span class="sd">        on matching of the shot table columns specified in &quot;by&quot;.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            ds_from {Dataset} -- Diffractem Dataset to take information from</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            merge_cols {List} -- Shot table columns to take over from other data set. If None (default),</span>
<span class="sd">                all columns are taken over which are not present in the shot table currently</span>
<span class="sd">            by {List} -- Shot table columns to match by. </span>
<span class="sd">                Defaults to [&#39;sample&#39;, &#39;region&#39;, &#39;run&#39;, &#39;crystal_id&#39;]</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: [description] d</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">by</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">by</span><span class="p">)</span>
        
        <span class="n">merge_cols</span> <span class="o">=</span> <span class="n">ds_from</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">+</span> 
                                                    <span class="p">[</span><span class="s1">&#39;_Event&#39;</span><span class="p">,</span> <span class="s1">&#39;_file&#39;</span><span class="p">,</span> <span class="s1">&#39;file_event_hash&#39;</span><span class="p">])</span> \
                                                        <span class="k">if</span> <span class="n">merge_cols</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">merge_cols</span>
        
        <span class="n">sh_from</span> <span class="o">=</span> <span class="n">ds_from</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># avoid side effects on ds_from</span>
        <span class="n">sh_from</span><span class="p">[</span><span class="s1">&#39;ii_from&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sh_from</span><span class="p">))</span>
        <span class="n">sel_shots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">sh_from</span><span class="p">[</span><span class="n">by</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">merge_cols</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;ii_from&#39;</span><span class="p">]],</span> <span class="n">on</span><span class="o">=</span><span class="n">by</span><span class="p">,</span> 
                                        <span class="n">how</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="s1">&#39;m:1&#39;</span><span class="p">,</span> <span class="n">indicator</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">sel_shots</span><span class="o">.</span><span class="n">_merge</span> <span class="o">==</span> <span class="s1">&#39;both&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Not all features present in the dataset are present in ds_from.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shots</span> <span class="o">=</span> <span class="n">sel_shots</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;_merge&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">peakdata</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ds_from</span><span class="o">.</span><span class="n">_stacks</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;peak&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">k</span><span class="o">==</span><span class="s1">&#39;nPeaks&#39;</span><span class="p">))}</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">ii_from</span><span class="o">.</span><span class="n">diff</span><span class="p">()</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">peakdata</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">ii_from</span><span class="o">.</span><span class="n">values</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">peakdata</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">peakdata</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_stack</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">persist</span><span class="p">:</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">persist_stacks</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">peakdata</span><span class="p">))</span></div>

<div class="viewcode-block" id="Dataset.merge_acquisition_data"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.merge_acquisition_data">[docs]</a>    <span class="k">def</span> <span class="nf">merge_acquisition_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fields</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="c1"># mange instrument (acquisition) data like exposure time etc. into shot list</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;merge_acquisition_data not yet implemented&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Dataset.write_list"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.write_list">[docs]</a>    <span class="k">def</span> <span class="nf">write_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">listfile</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes the files in the dataset into a list file, containing each file on a line.</span>
<span class="sd">        :param listfile: list file name</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#TODO allow to export CrystFEL-style single-pattern lists</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">listfile</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
            <span class="n">fh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">))</span></div>

<div class="viewcode-block" id="Dataset.generate_virtual_file"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.generate_virtual_file">[docs]</a>    <span class="k">def</span> <span class="nf">generate_virtual_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">diff_stack_label</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                              <span class="n">kind</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;fake&#39;</span><span class="p">,</span> <span class="n">virtual_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate a virtual HDF5 file containing the meta data of the dataset, but not the actual</span>
<span class="sd">        diffraction. Instead of the diffraction stack, either a dummy stack containing a constant only,</span>
<span class="sd">        or a virtual dataset with external links to the actual data files is created. While the former</span>
<span class="sd">        is useful for indexing using CrystFEL, the latter can serve to generate a file for quick preview.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            filename {str} -- [description]</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            kind {str} -- [description] (default: {&#39;fake&#39;})</span>
<span class="sd">            virtual_size {int} -- [description] (default: {1024})</span>

<span class="sd">        Raises:</span>
<span class="sd">            NotImplementedError: [description]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#TODO maybe rather split the preview file functionality off. It&#39;s too different.</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Fix this&#39;</span><span class="p">)</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Robert Buecker

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>