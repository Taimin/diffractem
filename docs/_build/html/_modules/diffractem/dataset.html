

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>diffractem.dataset &mdash; diffractem  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.18.0/dist/embed-amd.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/jupyter-sphinx.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> diffractem
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks.html">Tutorial notebooks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dataset.html">The Dataset object</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../file_format.html">Diffractem NeXus files</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../pre_processing.html">Preprocessing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../edview.html">EDview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../map_image.html">Crystal-map images</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crystfel.html">CrystFEL integration</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">diffractem</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>diffractem.dataset</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for diffractem.dataset</h1><div class="highlight"><pre>
<span></span><span class="c1"># dedicated to the penguin</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">dask.array.gufunc</span>
<span class="kn">from</span> <span class="nn">dask</span> <span class="kn">import</span> <span class="n">array</span> <span class="k">as</span> <span class="n">da</span>
<span class="kn">from</span> <span class="nn">dask.diagnostics</span> <span class="kn">import</span> <span class="n">ProgressBar</span>
<span class="kn">from</span> <span class="nn">dask.distributed</span> <span class="kn">import</span> <span class="n">Client</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">io</span><span class="p">,</span> <span class="n">nexus</span><span class="p">,</span> <span class="n">tools</span>
<span class="kn">from</span> <span class="nn">.stream_parser</span> <span class="kn">import</span> <span class="n">StreamParser</span>
<span class="c1"># from .map_image import MapImage</span>
<span class="kn">import</span> <span class="nn">h5py</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Callable</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span><span class="p">,</span> <span class="n">catch_warnings</span><span class="p">,</span> <span class="n">simplefilter</span>
<span class="kn">from</span> <span class="nn">tables</span> <span class="kn">import</span> <span class="n">NaturalNameWarning</span>
<span class="kn">from</span> <span class="nn">concurrent.futures</span> <span class="kn">import</span> <span class="n">ProcessPoolExecutor</span><span class="p">,</span> <span class="n">wait</span><span class="p">,</span> <span class="n">FIRST_EXCEPTION</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">jit</span>

<span class="c1"># top-level helper functions for chunking operations</span>
<span class="c1"># ...to be refactored into tools or compute later...</span>
<span class="k">def</span> <span class="nf">_check_commensurate</span><span class="p">(</span><span class="n">init</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">final</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> 
                        <span class="n">equal_size</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;check if blocks with sizes in init are commensurate with (i.e. have boundaries aligned with)</span>
<span class="sd">    blocks in final, and (optionally) if final blocks in final are equally-sized within each block in initial.</span>
<span class="sd">    Useful to check if a dask rechunk operation will act across boundaries of existing chunks,</span>
<span class="sd">    which is often something you&#39;ll want to try to avoid (and might be a sign that something is going wrong).</span>
<span class="sd">    Blocks in final must hence be smaller than those in init, i.e. len(final) &gt;= len(init), </span>
<span class="sd">    and of course: sum(final) == sum(init).</span>
<span class="sd">    Returns whether the blocks are commensurate, and (if so), the number of  </span>
<span class="sd">    final blocks in each of the initial block.&#39;&#39;&#39;</span>
    <span class="c1">#TODO consider using numba jit</span>

    <span class="n">final_inv</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">final</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># invert for faster popping</span>
    <span class="n">init</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">init</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">init</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">final</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Sum of init and final must be identical.&#39;</span><span class="p">)</span>
    <span class="n">blocksize</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">equal_size</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">s0</span> <span class="ow">in</span> <span class="n">init</span><span class="p">:</span>
            <span class="c1"># iterate over initial blocks</span>
            <span class="n">n_final_in_initial</span> <span class="o">=</span> <span class="n">s0</span> <span class="o">//</span> <span class="n">final_inv</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_final_in_initial</span><span class="p">):</span>
                <span class="c1"># iterate over final blocks within initial</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">s0</span> <span class="o">%</span> <span class="n">final_inv</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span>
            <span class="n">blocksize</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n_final_in_initial</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">s0</span> <span class="ow">in</span> <span class="n">init</span><span class="p">:</span>
            <span class="c1"># iterate over initial blocks</span>
            <span class="c1"># n_rem = copy.copy(s0)</span>
            <span class="n">n_rem</span> <span class="o">=</span> <span class="n">s0</span>
            <span class="n">b_num</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">n_rem</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">n_rem</span> <span class="o">-=</span> <span class="n">final_inv</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">b_num</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">n_rem</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># incommensurate block found!</span>
                    <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span>
            <span class="n">blocksize</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b_num</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">final_inv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">blocksize</span>

<span class="k">def</span> <span class="nf">_agg_groups</span><span class="p">(</span><span class="n">stack</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">],</span> <span class="n">agg_function</span><span class="p">:</span> <span class="n">callable</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Apply aggregating function to a numpy stack group-by-group, with groups defined by unique labels,</span>
<span class="sd">    and return the concatenated results; i.e., the length of the result along the aggregation</span>
<span class="sd">    axis equals the number of unique labels.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">res_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">lbl</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
        <span class="n">res_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">agg_function</span><span class="p">(</span><span class="n">stack</span><span class="p">[</span><span class="n">labels</span> <span class="o">==</span> <span class="n">lbl</span><span class="p">,</span><span class="o">...</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">res_list</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_map_sub_blocks</span><span class="p">(</span><span class="n">stack</span><span class="p">:</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">],</span> <span class="n">func</span><span class="p">:</span> <span class="n">callable</span><span class="p">,</span> <span class="n">aggregating</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                     <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Wrapper for da.map_blocks, which instead of applying the function chunk-by-chunk can apply it also to sub-groups</span>
<span class="sd">    within each chunk, as identified by unique labels (e.g. integers). Useful if you want to use large chunks to have fast computation, but</span>
<span class="sd">    want to apply the function to smaller blocks. Obvious example: you want to sum frames from a diffraction</span>
<span class="sd">    movie, but have many diffraction movies stored in each single chunk, as otherwise the chunk number would be too large.</span>
<span class="sd">    The input stack must be chunked along its 0th axis only, and len(labels) must equal the height of the stack. </span>
<span class="sd">    If aggregating=True, func is assumed to reduce the sub-block height to 1 (like summing all stack frames), whereas</span>
<span class="sd">    aggregating=False assumes func to leave the sub-block sizes as is (e.g. for cumulative summing).&#39;&#39;&#39;</span>

    <span class="n">chunked_labels</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">labels</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)),</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;sub_block_label&#39;</span><span class="p">)</span>
    <span class="n">cc_out</span> <span class="o">=</span> <span class="n">_check_commensurate</span><span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span> <span class="n">equal_size</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">cc_out</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Mismatched chunk structure: mapping groups are not within single chunk each&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="s1">&#39;chunks&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">final_chunks</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;chunks&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">final_chunks</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">cc_out</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">)</span> <span class="o">+</span> <span class="n">stack</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">if</span> <span class="n">aggregating</span> <span class="k">else</span> <span class="n">stack</span><span class="o">.</span><span class="n">chunks</span>
    <span class="k">return</span> <span class="n">da</span><span class="o">.</span><span class="n">map_blocks</span><span class="p">(</span><span class="n">_agg_groups</span><span class="p">,</span> <span class="n">stack</span><span class="p">,</span> <span class="n">chunked_labels</span><span class="p">,</span> 
        <span class="n">agg_function</span><span class="o">=</span><span class="n">func</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="n">final_chunks</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="Dataset"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset">[docs]</a><span class="k">class</span> <span class="nc">Dataset</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_shots_changed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_peaks_changed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_predict_changed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_features_changed</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># HDF5 file addresses</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_pattern</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;/%/data&#39;</span> 
        <span class="sd">&#39;&#39;&#39;Path to data stacks in HDF5 files. % can be used as placeholder (as in CrystFEL). Default /%/data&#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shots_pattern</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;/%/shots&#39;</span>
        <span class="sd">&#39;&#39;&#39;Path to shot table data in HDF5 files. % can be used as placeholder (as in CrystFEL). Default /%/shots&#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fallback_shots_pattern</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;/%/data/shots&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result_pattern</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;/%/results&#39;</span>
        <span class="sd">&#39;&#39;&#39;Path to result data (peaks, predictions) in HDF5 files. % can be used as placeholder (as in CrystFEL). </span>
<span class="sd">        Default /%/results. **Note that storing results in this way is discouraged and deprecated.**&#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map_pattern</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;/%/map&#39;</span>
        <span class="sd">&#39;&#39;&#39;Path to map and feature data in HDF5 files. % can be used as placeholder (as in CrystFEL). Default /%/map&#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">instrument_pattern</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;/%/instrument&#39;</span>
        <span class="sd">&#39;&#39;&#39;Path to instrument metadat in HDF5 files. % can be used as placeholder (as in CrystFEL). Default /%/instrument&#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parallel_io</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="sd">&#39;&#39;&#39;Toggles if parallel I/O is attempted for datasets spanning many files. Note that this is independent</span>
<span class="sd">        from `dask.distributed`-based parallelization as in `store_stack_fast`. Default True, which is overriden</span>
<span class="sd">        if the Dataset comprises a single file only.&#39;&#39;&#39;</span>

        <span class="c1"># internal stuff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_file_handles</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stacks</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shot_id_cols</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="s1">&#39;Event&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_feature_id_cols</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;crystal_id&#39;</span><span class="p">,</span> <span class="s1">&#39;region&#39;</span><span class="p">,</span> <span class="s1">&#39;sample&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_diff_stack_label</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

        <span class="c1"># tables: accessed via properties!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_shot_id_cols</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_feature_id_cols</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;selected&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_peaks</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_shot_id_cols</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_predict</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_shot_id_cols</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_features</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_feature_id_cols</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s1">&#39;diffractem Dataset object spanning </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span><span class="si">}</span><span class="s1"> NeXus/HDF5 files</span><span class="se">\n</span><span class="s1">-----</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> shots (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">selected</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="si">}</span><span class="s1"> selected)</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_peaks</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> peaks, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_predict</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> predictions, &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_features</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> features</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_stacks</span><span class="p">)</span><span class="si">}</span><span class="s1"> data stacks: </span><span class="si">{</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_stacks</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="sa">f</span><span class="s1">&#39;Diffraction data stack: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_diff_stack_label</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="sa">f</span><span class="s1">&#39;Data files open: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_files_open</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="sa">f</span><span class="s1">&#39;Data files writable: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_files_writable</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="c1"># allows to access stacks with dot notation</span>
        <span class="k">if</span> <span class="n">attr</span> <span class="o">==</span> <span class="s1">&#39;_stacks&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">()</span>  <span class="c1"># needed for copying the object to avoid infinite recursion</span>
        <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stacks</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stacks</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s1"> is neither a dataset attribute, nor a stack name.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_files_open</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;True if HDF5 files are open&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_handles</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_files_writable</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;True if HDF5 files are open in write mode&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_files_open</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">([</span><span class="n">f</span><span class="o">.</span><span class="n">mode</span> <span class="o">!=</span> <span class="s1">&#39;r&#39;</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_handles</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_stack_in_memory</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;For each stack, indicates whether the dask array is persisted in memory. This is done</span>
<span class="sd">        by comparing the task number to the chunk number, which might be inaccurate in </span>
<span class="sd">        pathological cases&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">sn</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">stk</span><span class="o">.</span><span class="n">dask</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">stk</span><span class="o">.</span><span class="n">numblocks</span><span class="p">)</span> <span class="k">for</span> <span class="n">sn</span><span class="p">,</span> <span class="n">stk</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stacks</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">file_handles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Handles to the HDF5 files as a dict with keys matching the file name, if files are open.</span>
<span class="sd">        Otherwise returns None (for each file).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">fn</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_file_handles</span><span class="p">[</span><span class="n">fn</span><span class="p">]</span> <span class="k">if</span> <span class="n">fn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_file_handles</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">stacks</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Dictionary of data stacks of the Dataset.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stacks</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">files</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;List of HDF5 files which the Dataset is based on. Note that these files do not have</span>
<span class="sd">        to actually exist; but they will be written if any of the writing functions is called.</span>
<span class="sd">        Change the file names and directories using `change_filenames`, or direct editing of the</span>
<span class="sd">        shot table (*discouraged*)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shots</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Shot list. Can be overwritten only if index and ID columns of the shots</span>
<span class="sd">        are identical to the existing one.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span>

    <span class="nd">@shots</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">shots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">index</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Shot index is different from existing one.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_shot_id_cols</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_shot_id_cols</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Shot ID columns are different from existing ones.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shots_changed</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;List of predictions. Deprecated. Please store predictions in StreamParser objects.&quot;&quot;&quot;</span>
        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;The prediction table functionality will likely be removed.&#39;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_predict</span>

    <span class="nd">@predict</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;The prediction table functionality will likely be removed.&#39;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_predict</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_predict_changed</span> <span class="o">=</span> <span class="kc">True</span>
        
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">features</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;List of features (that is e.g. crystals). Each feature can have one or many shots</span>
<span class="sd">        associated with it.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_features</span>

    <span class="nd">@features</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">features</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_features</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_features_changed</span> <span class="o">=</span> <span class="kc">True</span>
        
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">peaks</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;List of found diffraction peaks. Deprecated. Please store peaks in CXI-format</span>
<span class="sd">        stacks. Note that peak positions in this table must follow *CrystFEL* convention, that</span>
<span class="sd">        is, integer numbers specify the pixel *edges*, not centers. This is in contrast to</span>
<span class="sd">        CXI convention, where integer numbers correspond to pixel *centers*&quot;&quot;&quot;</span>
        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;The peak table functionality will likely be removed.&#39;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_peaks</span>
            
    <span class="nd">@peaks</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">peaks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;The peak table functionality will likely be removed.&#39;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_peaks</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_peaks_changed</span> <span class="o">=</span> <span class="kc">True</span>
            
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">peak_data</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Stored Bragg reflection data in CXI format, if present. Otherwise raises error.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">sn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stacks</span> <span class="k">for</span> <span class="n">sn</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;nPeaks&#39;</span><span class="p">,</span> <span class="s1">&#39;peakXPosRaw&#39;</span><span class="p">,</span> <span class="s1">&#39;peakYPosRaw&#39;</span><span class="p">]]):</span>
            <span class="n">pkdat</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stacks</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;nPeaks&#39;</span><span class="p">,</span> <span class="s1">&#39;peakXPosRaw&#39;</span><span class="p">,</span> <span class="s1">&#39;peakYPosRaw&#39;</span><span class="p">]}</span>
            <span class="k">if</span> <span class="s1">&#39;peakTotalIntensity&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stacks</span><span class="p">:</span>
                <span class="n">pkdat</span><span class="p">[</span><span class="s1">&#39;peakTotalIntensity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stacks</span><span class="p">[</span><span class="s1">&#39;peakTotalIntensity&#39;</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">pkdat</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No peak data found in dataset.&#39;</span><span class="p">)</span>
        
    <span class="nd">@peak_data</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">peak_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]):</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">sn</span> <span class="ow">in</span> <span class="n">v</span> <span class="k">for</span> <span class="n">sn</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;nPeaks&#39;</span><span class="p">,</span> <span class="s1">&#39;peakXPosRaw&#39;</span><span class="p">,</span> <span class="s1">&#39;peakYPosRaw&#39;</span><span class="p">]]):</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_stack</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Supplied peak data is incomplete.&#39;</span><span class="p">)</span>
            
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">zchunks</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Chunks of dask arrays holding the stacks along their first (that is, stacked) axis.&quot;&quot;&quot;</span>
        <span class="c1"># z chunks of dataset stacks</span>
        <span class="n">allchk</span> <span class="o">=</span> <span class="p">[</span><span class="n">stk</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">stk</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stacks</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
        <span class="k">if</span> <span class="n">allchk</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">([</span><span class="n">chk</span> <span class="o">==</span> <span class="n">allchk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">chk</span> <span class="ow">in</span> <span class="n">allchk</span><span class="p">]):</span>
            <span class="k">return</span> <span class="n">allchk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">allchk</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Stacks have unequal chunking along first axis. This is undesirable.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>            
            <span class="k">return</span> <span class="kc">None</span>        
        
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">diff_stack_label</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Label of stack which holds the diffraction data.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_diff_stack_label</span>
    
    <span class="nd">@diff_stack_label</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">diff_stack_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stacks</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_diff_stack_label</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s1"> is not a stack.&#39;</span><span class="p">)</span>
        
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">diff_data</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns diffraction data stack (as identified by the diff_stack_label property&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stacks</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">diff_stack_label</span><span class="p">]</span>
    
<div class="viewcode-block" id="Dataset.from_files"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.from_files">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_files</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">files</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">],</span> <span class="n">open_stacks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">chunking</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;hdf5&#39;</span><span class="p">,</span> 
                   <span class="n">persist_meta</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">init_stacks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">load_tables</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> 
                   <span class="n">diff_stack_label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;raw_counts&#39;</span><span class="p">,</span> <span class="n">validate_files</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a `Dataset` object from HDF5 file(s) stored on disk.</span>
<span class="sd">        </span>
<span class="sd">        There is some flexibility with regards to how to define the input files. You can specify them by</span>
<span class="sd">        </span>
<span class="sd">        * a .lst file name, which contains a simple list of H5 files (on separate lines). If the .lst file has CrystFEL-style</span>
<span class="sd">          event indicators in it, it will be loaded, and the events present in the list will be selected, the others not.</span>
<span class="sd">        * a glob pattern (like: &#39;data/*.h5&#39;)</span>
<span class="sd">        * a python iterable of files. </span>
<span class="sd">        * a simple HDF5 file path</span>
<span class="sd">            </span>
<span class="sd">        In any case, the shot list and feature list are loaded to memory. Using the arguments you can specify what should</span>
<span class="sd">        happen to the stacks.</span>
<span class="sd">            </span>
<span class="sd">        Args:</span>
<span class="sd">            files (Union[list, str, tuple]): File specification as decsribed above.</span>
<span class="sd">            open_stacks (bool, optional): Open the data stacks. This means that open handles to the HDF5 (in readonly mode). </span>
<span class="sd">                are kept within the `Dataset` object. Defaults to True.</span>
<span class="sd">            chunking (Union[int, str], optional):  See documentation of `open_stacks`. Defaults to &#39;hdf5&#39;, that is, look</span>
<span class="sd">                up in the HDF5 file for a recommendation value.</span>
<span class="sd">            persist_meta (bool, optional): Right away persists the data stacks, that is, loads the actual data into memory</span>
<span class="sd">                instead of just holding references to the HDF5 files. Diffraction data (identified by 3D stacks) is automatically</span>
<span class="sd">                excluded. Defaults to True.</span>
<span class="sd">            init_stacks (bool, optional): Initialize stacks, that is, briefly open the data stacks, check their lengths, and close</span>
<span class="sd">                the files again. Viable option if you need/want to set open_stacks=False for some reason. Defaults to False.</span>
<span class="sd">            load_tables (bool, optional): Also load peaks and prediction tables from the HDF5 files. Defaults to True (will likely</span>
<span class="sd">                be changed to False).</span>
<span class="sd">            diff_stack_label (str, optional): Label of the diffraction data stack. Defaults to &#39;raw_counts&#39;.</span>
<span class="sd">            validate_files (bool, optional): Validate the HDF5 files (that is, check for required groups and datasets)</span>
<span class="sd">                before attempting to open them. Defaults to False.</span>
<span class="sd">            **kwargs: Dataset attributes to be set right away.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dataset: new Dataset object read from files</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">file_list</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">expand_files</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="n">scan_shots</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="n">validate_files</span><span class="p">)</span>
        <span class="c1"># print(list(file_list))</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">file_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Single-file dataset, disabling parallel I/O.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parallel_io</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">load_tables</span><span class="p">(</span><span class="n">shots</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">files</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">file_list</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">unique</span><span class="p">()))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">init_shot_table</span><span class="p">(</span><span class="n">file_list</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">],</span> <span class="n">stack_label</span><span class="o">=</span><span class="n">diff_stack_label</span><span class="p">)</span>

        <span class="c1"># now set selected property...</span>
        <span class="k">if</span> <span class="s1">&#39;Event&#39;</span> <span class="ow">in</span> <span class="n">file_list</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="p">[</span><span class="s1">&#39;selected&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_shot_id_cols</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">file_list</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_shot_id_cols</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># and initialize stacks and tables</span>
        <span class="k">if</span> <span class="n">init_stacks</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">open_stacks</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">init_stacks</span><span class="p">(</span><span class="n">chunking</span><span class="o">=</span><span class="n">chunking</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">load_tables</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_tables</span><span class="p">(</span><span class="n">features</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">peaks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">predict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>          
        <span class="k">if</span> <span class="n">open_stacks</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">open_stacks</span><span class="p">(</span><span class="n">chunking</span><span class="o">=</span><span class="n">chunking</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">open_stacks</span> <span class="ow">and</span> <span class="n">persist_meta</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">persist_stacks</span><span class="p">(</span><span class="n">exclude</span><span class="o">=</span><span class="n">diff_stack_label</span><span class="p">,</span> <span class="n">include_3d</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>
    
    <span class="n">from_list</span> <span class="o">=</span> <span class="n">from_files</span> <span class="c1"># for compatibility</span>

    <span class="c1">#TODO What is this method doing here? Shouldn&#39;t it go into some tool module?</span>
<div class="viewcode-block" id="Dataset.init_shot_table"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.init_shot_table">[docs]</a>    <span class="k">def</span> <span class="nf">init_shot_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">files</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">stack_label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;raw_counts&#39;</span><span class="p">):</span>
        <span class="n">identifiers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_pattern</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;%&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">shots</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">identifiers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">subsets</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">subsets</span> <span class="o">=</span> <span class="n">fh</span><span class="p">[</span><span class="n">identifiers</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

                <span class="n">file_shots</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">subset</span> <span class="ow">in</span> <span class="n">subsets</span><span class="p">:</span>
                    <span class="n">tbl_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shots_pattern</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;%&#39;</span><span class="p">,</span> <span class="n">subset</span><span class="p">)</span>
                    <span class="n">stk_path</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_pattern</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">stack_label</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;%&#39;</span><span class="p">,</span> <span class="n">subset</span><span class="p">)</span>
                    
                    <span class="n">stk_height</span> <span class="o">=</span> <span class="n">fh</span><span class="p">[</span><span class="n">stk_path</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">sss</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">stk_height</span><span class="p">),</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;shot_in_subset&#39;</span><span class="p">])</span>
                    <span class="n">sss</span><span class="p">[</span><span class="s1">&#39;subset&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">subset</span>
                    <span class="n">sss</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fn</span>
                    <span class="n">sss</span><span class="p">[</span><span class="s1">&#39;Event&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">subset</span> <span class="o">+</span> <span class="s1">&#39;//&#39;</span> <span class="o">+</span> <span class="n">sss</span><span class="p">[</span><span class="s1">&#39;shot_in_subset&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
                    <span class="n">sss</span><span class="p">[</span><span class="s1">&#39;frame&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">sss</span><span class="p">[</span><span class="s1">&#39;selected&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">file_shots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sss</span><span class="p">)</span>
                    
            <span class="n">shots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">file_shots</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">shots</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Found </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> shots, initialized shot table.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Dataset.load_tables"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.load_tables">[docs]</a>    <span class="k">def</span> <span class="nf">load_tables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shots</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">features</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                    <span class="n">peaks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">predict</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">files</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load pandas metadata tables from the HDF5 files. Set the argument for the table you want to load to True.</span>

<span class="sd">        Args:</span>
<span class="sd">            shots (bool, optional): Get shot table. Defaults to False.</span>
<span class="sd">            features (bool, optional): Get feature table. Defaults to False.</span>
<span class="sd">            peaks (bool, optional): Get peaks table. Defaults to False.</span>
<span class="sd">            predict (bool, optional): Get prediction table. Defaults to False.</span>
<span class="sd">            files (bool, optional): Only include sub selection of files - usually not a good idea.</span>
<span class="sd">                Uses all files of dataset if None. Defaults to None.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">files</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">files</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">files</span>

        <span class="k">if</span> <span class="n">shots</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;You are reloading the shot table. This can be dangerous. If you want to ensure a consistent&#39;</span>
                     <span class="s1">&#39; data set, use the from_list class method instead, or start from an empty dataset.&#39;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span> <span class="o">=</span> <span class="n">nexus</span><span class="o">.</span><span class="n">get_table</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shots_pattern</span><span class="p">,</span>
                                                  <span class="n">parallel</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parallel_io</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span> <span class="o">=</span> <span class="n">nexus</span><span class="o">.</span><span class="n">get_table</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fallback_shots_pattern</span><span class="p">,</span>
                                                  <span class="n">parallel</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parallel_io</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_shots_changed</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="k">if</span> <span class="s1">&#39;shot_in_subset&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                    <span class="k">if</span> <span class="s1">&#39;shot&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                        <span class="c1"># seems to be a raw file from acquisition...</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;shot&#39;</span><span class="p">:</span> <span class="s1">&#39;shot_in_subset&#39;</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="p">[</span><span class="s1">&#39;shot_in_subset&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="s1">&#39;subset&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">cumcount</span><span class="p">()</span>

                <span class="k">if</span> <span class="s1">&#39;Event&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="p">[</span><span class="s1">&#39;Event&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">subset</span> <span class="o">+</span> <span class="s1">&#39;//&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">shot_in_subset</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>

                <span class="k">if</span> <span class="s1">&#39;selected&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="p">[</span><span class="s1">&#39;selected&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="k">if</span> <span class="s1">&#39;stem&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                    <span class="c1"># deprecated....</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;stem&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;No shots found at &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">shots_pattern</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">features</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_features</span> <span class="o">=</span> <span class="n">nexus</span><span class="o">.</span><span class="n">get_table</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_pattern</span> <span class="o">+</span> <span class="s1">&#39;/features&#39;</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parallel_io</span><span class="p">)</span>
                <span class="c1"># print(len(self._features))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_features_changed</span> <span class="o">=</span> <span class="kc">False</span>
                
            <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
                <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;No features found at &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_pattern</span> <span class="o">+</span> <span class="s1">&#39;/features&#39;</span><span class="p">)</span>
                <span class="c1"># raise err</span>

            <span class="k">try</span><span class="p">:</span>
                
                <span class="k">if</span> <span class="s1">&#39;sample&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_features</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                    <span class="n">sdat</span> <span class="o">=</span> <span class="n">nexus</span><span class="o">.</span><span class="n">get_meta_fields</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_features</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">unique</span><span class="p">()),</span>
                                                 <span class="p">[</span><span class="s1">&#39;/%/sample/name&#39;</span><span class="p">,</span> <span class="s1">&#39;/%/sample/region_id&#39;</span><span class="p">,</span> <span class="s1">&#39;/%/sample/run_id&#39;</span><span class="p">])</span><span class="o">.</span> \
                        <span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;region_id&#39;</span><span class="p">:</span> <span class="s1">&#39;region&#39;</span><span class="p">,</span> <span class="s1">&#39;run_id&#39;</span><span class="p">:</span> <span class="s1">&#39;run&#39;</span><span class="p">})</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_features</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_features</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">sdat</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="s1">&#39;subset&#39;</span><span class="p">])</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_features</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_feature_id_cols</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># for multi files with identical features</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_features</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="s1">&#39;subset&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_features</span><span class="o">.</span><span class="n">columns</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error processing &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_pattern</span> <span class="o">+</span> <span class="s1">&#39;/features&#39;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">err</span>

        <span class="k">if</span> <span class="n">peaks</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_peaks</span> <span class="o">=</span> <span class="n">nexus</span><span class="o">.</span><span class="n">get_table</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">result_pattern</span> <span class="o">+</span> <span class="s1">&#39;/peaks&#39;</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parallel_io</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_peaks_changed</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>
                <span class="c1">#print(&#39;No peaks found at &#39; + self.result_pattern + &#39;/peaks&#39;)</span>

        <span class="k">if</span> <span class="n">predict</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_predict</span> <span class="o">=</span> <span class="n">nexus</span><span class="o">.</span><span class="n">get_table</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">result_pattern</span> <span class="o">+</span> <span class="s1">&#39;/predict&#39;</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parallel_io</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_predict_changed</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span></div>
                <span class="c1">#print(&#39;No predictions found at &#39; + self.result_pattern + &#39;/predict&#39;)</span>

<div class="viewcode-block" id="Dataset.store_tables"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.store_tables">[docs]</a>    <span class="k">def</span> <span class="nf">store_tables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shots</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">features</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">peaks</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">predict</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;nexus&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Stores the metadata tables (shots, features, peaks, predictions) into HDF5 files. </span>
<span class="sd">        </span>
<span class="sd">        The location into which the tables will be stored is defined in the Dataset object&#39;s attributes. The format</span>
<span class="sd">        in which they are stored is, on the other hand, determined by the *format* argument. If set to &#39;tables&#39;,</span>
<span class="sd">        PyTables will be used to store the table in a native HDF5 table format, which however is somewhat uncommon</span>
<span class="sd">        and not recognized by CrystFEL. If set to &#39;nexus&#39; (Default), each column of the table will be stored as</span>
<span class="sd">        a one-dimensional dataset.</span>
<span class="sd">        </span>
<span class="sd">        As a general recommendation, **always** use nexus format to store the shots and features. For peaks and </span>
<span class="sd">        predictions, &#39;tables&#39; is rather preferred, as it allows faster read/write and is more flexible with</span>
<span class="sd">        regards to column labels.</span>
<span class="sd">        </span>
<span class="sd">        For each of the tables,</span>
<span class="sd">        it can be automatically determined if they have changed and should be stored (however, this only works if </span>
<span class="sd">        no inplace changes have been made. So don&#39;t rely on it too much.). If you want this, leave the</span>
<span class="sd">        argument at None. Otherwise explicitly specify True or False (strongly recommended).</span>

<span class="sd">        Args:</span>
<span class="sd">            shots (Union[None, bool], optional): Store shot table. Defaults to None.</span>
<span class="sd">            features (Union[None, bool], optional): Store feature table. Defaults to None.</span>
<span class="sd">            peaks (Union[None, bool], optional): Store peak table. Defaults to None.</span>
<span class="sd">            predict (Union[None, bool], optional): Store prediction table. Defaults to None.</span>
<span class="sd">            format (str, optional): Table storage format in HDF5 file, can be &#39;nexus&#39; or &#39;tables&#39;. Defaults to &#39;nexus&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">fs</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_files_open</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_files_writable</span><span class="p">:</span>
            <span class="c1"># files are open in read-only, they need to be closed</span>
            <span class="n">stacks_were_open</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">close_files</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stacks_were_open</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">simplefilter</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">NaturalNameWarning</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">shots</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots_changed</span><span class="p">)</span> <span class="ow">or</span> <span class="n">shots</span><span class="p">:</span>
            <span class="c1"># sh = self.shots.drop([&#39;Event&#39;, &#39;shot_in_subset&#39;], axis=1)</span>
            <span class="c1"># sh[&#39;id&#39;] = sh[[&#39;sample&#39;, &#39;region&#39;, &#39;run&#39;, &#39;crystal_id&#39;]].apply(lambda x: &#39;//&#39;.join(x.astype(str)), axis=1)</span>
            <span class="n">fs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">nexus</span><span class="o">.</span><span class="n">store_table</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shots_pattern</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parallel_io</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_shots_changed</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">features</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_features_changed</span><span class="p">)</span> <span class="ow">or</span> <span class="n">features</span><span class="p">:</span>
            <span class="n">fs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">nexus</span><span class="o">.</span><span class="n">store_table</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_feature_id_cols</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="s1">&#39;subset&#39;</span><span class="p">]],</span> 
                                                            <span class="n">on</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_feature_id_cols</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="s1">&#39;1:m&#39;</span><span class="p">),</span> 
                                        <span class="bp">self</span><span class="o">.</span><span class="n">map_pattern</span> <span class="o">+</span> <span class="s1">&#39;/features&#39;</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parallel_io</span><span class="p">,</span>
                                        <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_features_changed</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">peaks</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_peaks_changed</span><span class="p">)</span> <span class="ow">or</span> <span class="n">peaks</span><span class="p">:</span>
            <span class="n">fs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="n">nexus</span><span class="o">.</span><span class="n">store_table</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">peaks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">result_pattern</span> <span class="o">+</span> <span class="s1">&#39;/peaks&#39;</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parallel_io</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_peaks_changed</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">predict</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_predict_changed</span><span class="p">)</span> <span class="ow">or</span> <span class="n">predict</span><span class="p">:</span>
            <span class="n">fs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">nexus</span><span class="o">.</span><span class="n">store_table</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">result_pattern</span> <span class="o">+</span> <span class="s1">&#39;/predict&#39;</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parallel_io</span><span class="p">,</span>
                                        <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_predict_changed</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">stacks_were_open</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">open_stacks</span><span class="p">()</span></div>

<div class="viewcode-block" id="Dataset.merge_stream"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.merge_stream">[docs]</a>    <span class="k">def</span> <span class="nf">merge_stream</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">streamfile</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">StreamParser</span><span class="p">,</span> <span class="nb">str</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Loads a `CrystFEL` stream file and merges it contents into the dataset.</span>

<span class="sd">        Args:</span>
<span class="sd">            streamfile (Union[StreamParser, str]): stream file name, or StreamParser object.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># ...it would be way more elegant, to just associate a StreamParser object, and merge the list in</span>
        <span class="c1"># accessors. But the merges can become pretty slow for large files, so we do it only here.</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">streamfile</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="n">StreamParser</span><span class="p">(</span><span class="n">streamfile</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="n">streamfile</span>

        <span class="n">cols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">columns</span><span class="p">))</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shot_id_cols</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;subset&#39;</span><span class="p">,</span>
                                                                                                 <span class="s1">&#39;shot_in_subset&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="p">[</span><span class="n">cols</span><span class="p">]</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">shots</span><span class="p">,</span>
                                            <span class="n">on</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_shot_id_cols</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;subset&#39;</span><span class="p">,</span> <span class="s1">&#39;shot_in_subset&#39;</span><span class="p">],</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span>
                                            <span class="n">validate</span><span class="o">=</span><span class="s1">&#39;1:1&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="p">[</span><span class="s1">&#39;selected&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="p">[</span><span class="s1">&#39;serial&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">notna</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">peaks</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">peaks</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_shot_id_cols</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;subset&#39;</span><span class="p">,</span> <span class="s1">&#39;shot_in_subset&#39;</span><span class="p">]],</span>
                                        <span class="n">on</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_shot_id_cols</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;inner&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">predict</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">indexed</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_shot_id_cols</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;subset&#39;</span><span class="p">,</span> <span class="s1">&#39;shot_in_subset&#39;</span><span class="p">]],</span>
                                            <span class="n">on</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_shot_id_cols</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;inner&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Dataset.get_map"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.get_map">[docs]</a>    <span class="k">def</span> <span class="nf">get_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">subset</span><span class="o">=</span><span class="s1">&#39;entry&#39;</span><span class="p">):</span>
        <span class="c1"># TODO: get a MapImage from stored data, with tables filled in from dataset</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;does not work yet, sorry.&#39;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_sel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">h5py</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        General internal method to pick items that belong to shots with selected==True from many kinds of data types.</span>
<span class="sd">        </span>
<span class="sd">        * For DataFrames, it matches the selected items by the datasets ID columns (usually &#39;file&#39; and &#39;Event&#39;,</span>
<span class="sd">          or &#39;crystal_id&#39; and &#39;region&#39;)</span>
<span class="sd">        * For anything slicable (dask or numpy array), it picks elements along the first array dimension,</span>
<span class="sd">          assuming that the stack is ordered the same way as the shot list.</span>
<span class="sd">        * Also accepts lists or dicts of all such objects and returns a corresponding list or dict.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            obj: DataFrame, numpy Array, dask Array, h5py Dataset, list, dict</span>
<span class="sd">        </span>
<span class="sd">        Returns: </span>
<span class="sd">            subset of input object (typically as non-copied view!)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">selected</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">c</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">columns</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shot_id_cols</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">selected</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shot_id_cols</span><span class="p">],</span>
                             <span class="n">on</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_shot_id_cols</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;inner&#39;</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="s1">&#39;m:1&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">c</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">columns</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_feature_id_cols</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_feature_id_cols</span><span class="p">],</span>
                             <span class="n">on</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_feature_id_cols</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;inner&#39;</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="s1">&#39;1:m&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;DataFrame must contain the columns </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_shot_id_cols</span><span class="si">}</span><span class="s1"> or </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_feature_id_cols</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_sel</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sel</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">obj</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">selected</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>

<div class="viewcode-block" id="Dataset.select"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.select">[docs]</a>    <span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;True&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the &#39;selected&#39; column of the shot list by a string query (eg. &#39;num_peaks &gt; 30 and frame == 1&#39;).</span>
<span class="sd">        See pandas documentation for &#39;query&#39; and &#39;eval&#39;. If you want to add another criterion to the existing</span>
<span class="sd">        selection you can also do sth. like &#39;selected and hit == 1&#39;.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            query (str): if left empty, defaults to &#39;True&#39; -&gt; selects all shots.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">selection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">selection</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;query must return a boolean!&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">selected</span> <span class="o">=</span> <span class="n">selection</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">selected</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="si">}</span><span class="s1"> shots out of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> selected.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Dataset.change_filenames"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.change_filenames">[docs]</a>    <span class="k">def</span> <span class="nf">change_filenames</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_suffix</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;.h5&#39;</span><span class="p">,</span> <span class="n">file_prefix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
                         <span class="n">new_folder</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">fn_map</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">keep_raw</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Change file names in all lists using some handy modifications. </span>
<span class="sd">        </span>
<span class="sd">        The old file names are copied to a &quot;file_raw&quot; column, if not already present </span>
<span class="sd">        (can be overriden with keep_raw).</span>

<span class="sd">        Args:</span>
<span class="sd">            file_suffix (Optional[str], optional): add suffix to file, INCLUDING file extension, e.g. &#39;_modified.h5&#39;. </span>
<span class="sd">                Defaults to &#39;.h5&#39;, i.e., no change is made except for the file extension being fixed to h5.</span>
<span class="sd">            file_prefix (str, optional): add prefix to actual filenames (not folder/full path!), e.g. &#39;aggregated_&#39;. </span>
<span class="sd">                Defaults to &#39;&#39;, i.e., no prefix..</span>
<span class="sd">            new_folder (Union[str, None], optional): If not None, changes the file folders to this path. Defaults to None.</span>
<span class="sd">            fn_map (Union[pd.DataFrame, None], optional): if not None, expects an explicit table (pd.DataFrame) with columns </span>
<span class="sd">                &#39;file&#39; and &#39;file_new&#39;</span>
<span class="sd">                that manually maps old to new filenames. *All other parameters are ignored, if provided.* Defaults to None.</span>
<span class="sd">            keep_raw (bool, optional): If True (default), does not change the file_raw column in the shot list,</span>
<span class="sd">                unless there is none yet (in which case the old file names are *always* copied to keep_raw). Defaults to True.</span>
<span class="sd">        &quot;&quot;&quot;</span>        

        <span class="k">if</span> <span class="n">fn_map</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># name mangling pt. 1: make map of old names to new names</span>
            <span class="n">fn_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="p">[[</span><span class="s1">&#39;file&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span>
            <span class="n">folder_file</span> <span class="o">=</span> <span class="n">fn_map</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">file_suffix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_fn</span> <span class="o">=</span> <span class="n">file_prefix</span> <span class="o">+</span> <span class="n">folder_file</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">file_suffix</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_fn</span> <span class="o">=</span> <span class="n">file_prefix</span> <span class="o">+</span> <span class="n">folder_file</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">new_folder</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_fn</span> <span class="o">=</span> <span class="n">new_folder</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">new_fn</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_fn</span> <span class="o">=</span> <span class="n">folder_file</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">new_fn</span>
            <span class="n">fn_map</span><span class="p">[</span><span class="s1">&#39;file_new&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_fn</span>
            <span class="c1"># print(fn_map)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">fn_map</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">fn_map</span><span class="p">[</span><span class="s1">&#39;file_new&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;New and old file names are the same! Nothing will happen.&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">fn_map</span>

        <span class="c1"># name mangling pt. 2: change names in all tables</span>
        <span class="k">for</span> <span class="n">lbl</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;_shots&#39;</span><span class="p">,</span> <span class="s1">&#39;_peaks&#39;</span><span class="p">,</span> <span class="s1">&#39;_predict&#39;</span><span class="p">,</span> <span class="s1">&#39;_features&#39;</span><span class="p">]:</span>
            <span class="n">table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">lbl</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">table</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="s1">&#39;file&#39;</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">newtable</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">fn_map</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span> \
                    <span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;file_new&#39;</span><span class="p">:</span> <span class="s1">&#39;file&#39;</span><span class="p">})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">newtable</span> <span class="o">=</span> <span class="n">table</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">lbl</span> <span class="o">==</span> <span class="s1">&#39;_shots&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">keep_raw</span> <span class="ow">or</span> <span class="s1">&#39;file_raw&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
                <span class="n">newtable</span><span class="p">[</span><span class="s1">&#39;file_raw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">file</span>

            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">lbl</span><span class="p">]</span> <span class="o">=</span> <span class="n">newtable</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">lbl</span> <span class="o">+</span> <span class="s1">&#39;_changed&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># invalidate all the hdf file references (note that references into old files might still exist)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_file_handles</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="n">fn_map</span></div>

<div class="viewcode-block" id="Dataset.reset_id"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.reset_id">[docs]</a>    <span class="k">def</span> <span class="nf">reset_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keep_raw</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resets shot_in_subset and Event columns to continuous numbering. Useful after dataset reduction. The old</span>
<span class="sd">        Event strings are copied to a &quot;Event_raw&quot; column, if not already present (can be overriden with keep_raw).</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            keep_raw (bool, optional): if True (default), does not change the Event_raw column in the shot list,</span>
<span class="sd">                unless there is none yet (in which case the old Event IDs are *always* copied to keep_raw)</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">id_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_shot_id_cols</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">id_map</span><span class="p">[</span><span class="s1">&#39;new_sis&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="s1">&#39;subset&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">cumcount</span><span class="p">()</span>
        <span class="n">id_map</span><span class="p">[</span><span class="s1">&#39;new_Event&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">subset</span> <span class="o">+</span> <span class="s1">&#39;//&#39;</span> <span class="o">+</span> <span class="n">id_map</span><span class="p">[</span><span class="s1">&#39;new_sis&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">lbl</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;_shots&#39;</span><span class="p">,</span> <span class="s1">&#39;_peaks&#39;</span><span class="p">,</span> <span class="s1">&#39;_predict&#39;</span><span class="p">]:</span>
            <span class="n">table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">lbl</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">table</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;new_Event&#39;</span><span class="p">:</span> <span class="s1">&#39;Event&#39;</span><span class="p">,</span> <span class="s1">&#39;new_sis&#39;</span><span class="p">:</span> <span class="s1">&#39;shot_in_subset&#39;</span><span class="p">}</span> <span class="k">if</span> <span class="s1">&#39;shot_in_subset&#39;</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">columns</span> \
                <span class="k">else</span> <span class="p">{</span><span class="s1">&#39;new_Event&#39;</span><span class="p">:</span> <span class="s1">&#39;Event&#39;</span><span class="p">}</span>
            <span class="n">newtable</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">id_map</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_shot_id_cols</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">cols</span><span class="o">.</span><span class="n">keys</span><span class="p">())],</span> <span class="n">on</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_shot_id_cols</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span><span class="o">.</span> \
                <span class="n">drop</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">cols</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">cols</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">lbl</span> <span class="o">==</span> <span class="s1">&#39;_shots&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">keep_raw</span> <span class="ow">or</span> <span class="s1">&#39;Event_raw&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
                <span class="n">newtable</span><span class="p">[</span><span class="s1">&#39;Event_raw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">Event</span>

            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">lbl</span><span class="p">]</span> <span class="o">=</span> <span class="n">newtable</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">lbl</span> <span class="o">+</span> <span class="s1">&#39;_changed&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Dataset.init_files"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.init_files">[docs]</a>    <span class="k">def</span> <span class="nf">init_files</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">keep_features</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">exclude_list</span><span class="o">=</span><span class="p">()):</span>
        <span class="sd">&quot;&quot;&quot;Initialize set of HDF5 files to store the Dataset.</span>
<span class="sd">        </span>
<span class="sd">        Makes new files corresponding to the shot list, by creating the files with the basic structure, and</span>
<span class="sd">        copying over instrument metadata and maps (but not shot list, data arrays,...) </span>
<span class="sd">        from the raw files (as stored in file_raw).</span>

<span class="sd">        Args:</span>
<span class="sd">            overwrite (bool, optional): Overwrite files if existing already. Defaults to False.</span>
<span class="sd">            keep_features (bool, optional): Copy over the (full) feature list. Usually not required,</span>
<span class="sd">                as it will be later stored using store_stacks. Defaults to False.</span>
<span class="sd">            exclude_list (tuple, optional): Custom list of HDF5 groups or datasets to exclude</span>
<span class="sd">                from copying. Please consult documentation of `nexus.copy_h5` for help. Defaults to ().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">fn_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="p">[[</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="s1">&#39;file_raw&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span>

        <span class="n">exc</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;%/detector/data&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_pattern</span> <span class="o">+</span> <span class="s1">&#39;/%&#39;</span><span class="p">,</span>
               <span class="bp">self</span><span class="o">.</span><span class="n">result_pattern</span> <span class="o">+</span> <span class="s1">&#39;/%&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shots_pattern</span> <span class="o">+</span> <span class="s1">&#39;/%&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">keep_features</span><span class="p">:</span>
            <span class="n">exc</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_pattern</span> <span class="o">+</span> <span class="s1">&#39;/features&#39;</span><span class="p">,</span> <span class="s1">&#39;%/ref/features&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">exclude_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">exc</span> <span class="o">+=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">exclude_list</span><span class="p">)</span>

        <span class="c1"># print(fn_map)P</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parallel_io</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">ProcessPoolExecutor</span><span class="p">()</span> <span class="k">as</span> <span class="n">p</span><span class="p">:</span>
                <span class="n">futures</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">filepair</span> <span class="ow">in</span> <span class="n">fn_map</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                    <span class="n">futures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">nexus</span><span class="o">.</span><span class="n">copy_h5</span><span class="p">,</span>
                                            <span class="n">filepair</span><span class="p">[</span><span class="s1">&#39;file_raw&#39;</span><span class="p">],</span> <span class="n">filepair</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">],</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span> <span class="k">if</span> <span class="n">overwrite</span> <span class="k">else</span> <span class="s1">&#39;w-&#39;</span><span class="p">,</span>
                                            <span class="n">exclude</span><span class="o">=</span><span class="n">exc</span><span class="p">,</span>
                                            <span class="n">print_skipped</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>

                <span class="n">wait</span><span class="p">(</span><span class="n">futures</span><span class="p">,</span> <span class="n">return_when</span><span class="o">=</span><span class="n">FIRST_EXCEPTION</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">futures</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">exception</span><span class="p">():</span>
                        <span class="k">raise</span> <span class="n">f</span><span class="o">.</span><span class="n">exception</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">filepair</span> <span class="ow">in</span> <span class="n">fn_map</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                <span class="n">nexus</span><span class="o">.</span><span class="n">copy_h5</span><span class="p">(</span><span class="n">filepair</span><span class="p">[</span><span class="s1">&#39;file_raw&#39;</span><span class="p">],</span> <span class="n">filepair</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">],</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span> <span class="k">if</span> <span class="n">overwrite</span> <span class="k">else</span> <span class="s1">&#39;w-&#39;</span><span class="p">,</span>
                              <span class="n">exclude</span><span class="o">=</span><span class="n">exc</span><span class="p">,</span>
                              <span class="n">print_skipped</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dataset.get_meta"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.get_meta">[docs]</a>    <span class="k">def</span> <span class="nf">get_meta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;/%/instrument/detector/collection/shutter_time&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Gets an instrument metadata field in NeXus format from the HDF5 files. </span>
<span class="sd">        </span>
<span class="sd">        As those metadata are per-file and not per-shot, a series is returned which then can be joined into</span>
<span class="sd">        the dataset manually. If you want to have this done automatically, use `merge_meta` instead.</span>

<span class="sd">        Args:</span>
<span class="sd">            path (str, optional): Path to metadata to be grabbed. Can include CrystFEL-stype % placeholder. </span>
<span class="sd">                Defaults to &#39;/%/instrument/detector/collection/shutter_time&#39;.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pd.Series: pandas Series holding the metadata for each file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">meta</span> <span class="o">=</span> <span class="p">{}</span>    
        <span class="k">for</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="s1">&#39;subset&#39;</span><span class="p">]):</span>
            <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">lbl</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
                <span class="n">meta</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">lbl</span><span class="p">)]</span> <span class="o">=</span> <span class="n">fh</span><span class="p">[</span><span class="n">path</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;%&#39;</span><span class="p">,</span> <span class="n">lbl</span><span class="p">[</span><span class="mi">1</span><span class="p">])][</span><span class="o">...</span><span class="p">]</span>
                <span class="c1">#print(type(meta[tuple(lbl)]))</span>
                <span class="c1">#print(meta[tuple(lbl)].shape)</span>
                <span class="k">if</span> <span class="n">meta</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">lbl</span><span class="p">)]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">meta</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">lbl</span><span class="p">)]</span> <span class="o">=</span> <span class="n">meta</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">lbl</span><span class="p">)][()]</span>
                <span class="k">elif</span> <span class="n">meta</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">lbl</span><span class="p">)]</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">meta</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">lbl</span><span class="p">)]</span> <span class="o">=</span> <span class="n">meta</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">lbl</span><span class="p">)][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">path</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="Dataset.merge_meta"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.merge_meta">[docs]</a>    <span class="k">def</span> <span class="nf">merge_meta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="s1">&#39;%/instrument/detector/collection/shutter_time&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gets an instrument metadata field in NeXus format from the HDF5 files, and merges it into</span>
<span class="sd">        the shot table of the data set.</span>
<span class="sd">        </span>
<span class="sd">        Note, that the name of the new column in the shot table will correspond to the HDF5 dataset name,</span>
<span class="sd">        ignoring the group (as included in the full path). E.g., for the default value, it will be</span>
<span class="sd">        just &#39;shutter_time&#39;.</span>

<span class="sd">        Args:</span>
<span class="sd">            path (str, optional): Path to metadata to be grabbed. Can include CrystFEL-style % placeholder. </span>
<span class="sd">                Defaults to &#39;%/instrument/detector/collection/shutter_time&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_meta</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="s1">&#39;subset&#39;</span><span class="p">])</span></div>

<div class="viewcode-block" id="Dataset.get_selection"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.get_selection">[docs]</a>    <span class="k">def</span> <span class="nf">get_selection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                      <span class="n">file_suffix</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;_sel.h5&#39;</span><span class="p">,</span> <span class="n">file_prefix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
                      <span class="n">new_folder</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                      <span class="n">reset_id</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Dataset&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns a new dataset object by applying a selection. </span>
<span class="sd">        </span>
<span class="sd">        By default, returns a new Dataset object, including all shots with selected == True in the current shot list.</span>
<span class="sd">        Optionally, a different query string can be supplied (which leaves the selection unaffected).</span>
<span class="sd">        The file names of the new data set will be changed, to avoid collisions. This can be controlled with the file_suffix and</span>
<span class="sd">        file_prefix parameters. Otherwise, the returned dataset will include everything from the existing one.</span>
<span class="sd">        </span>
<span class="sd">        Hint: </span>

<span class="sd">        Args:</span>
<span class="sd">            query (Union[str, None], optional): Optional query string, as in the `select` method. Defaults to None, that is,</span>
<span class="sd">                use the `selected` column in the shot list.</span>
<span class="sd">            file_suffix (Optional[str], optional): as in `change_filenames`. Defaults to &#39;_sel.h5&#39;.</span>
<span class="sd">            file_prefix (str, optional): as in `change_filenames`. Defaults to &#39;&#39;.</span>
<span class="sd">            new_folder (Union[str, None], optional): as in `change_filenames`. Defaults to None.</span>
<span class="sd">            reset_id (bool, optional): reset the shot in subset. Defaults to True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dataset: New dataset with all the same attributes, but containing only the desired sub-selection of shots.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">query</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cur_sel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">selected</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">newset</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">newset</span><span class="o">.</span><span class="n">_shots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sel</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">newset</span><span class="o">.</span><span class="n">_peaks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_peaks</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">newset</span><span class="o">.</span><span class="n">_predict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_predict</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">newset</span><span class="o">.</span><span class="n">_features</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_features</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">newset</span><span class="o">.</span><span class="n">_shots</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_feature_id_cols</span><span class="p">],</span>
                                                    <span class="n">on</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_feature_id_cols</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;inner&#39;</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="s1">&#39;1:m&#39;</span><span class="p">)</span><span class="o">.</span>\
                <span class="n">drop_duplicates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_feature_id_cols</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">newset</span><span class="o">.</span><span class="n">_stacks</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="n">newset</span><span class="o">.</span><span class="n">change_filenames</span><span class="p">(</span><span class="n">file_suffix</span><span class="p">,</span> <span class="n">file_prefix</span><span class="p">,</span> <span class="n">new_folder</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">reset_id</span><span class="p">:</span>
                <span class="n">newset</span><span class="o">.</span><span class="n">reset_id</span><span class="p">()</span>
            <span class="n">newset</span><span class="o">.</span><span class="n">_file_handles</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stacks</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">newset</span><span class="o">.</span><span class="n">add_stack</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sel</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
                
            <span class="n">newset</span><span class="o">.</span><span class="n">persist_stacks</span><span class="p">([</span><span class="n">sn</span> <span class="k">for</span> <span class="n">sn</span><span class="p">,</span> <span class="n">inmem</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stack_in_memory</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">inmem</span><span class="p">])</span>

        <span class="k">finally</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">query</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">selected</span> <span class="o">=</span> <span class="n">cur_sel</span>

        <span class="k">return</span> <span class="n">newset</span></div>

<div class="viewcode-block" id="Dataset.copy"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_suffix</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;_copy.h5&#39;</span><span class="p">,</span> 
                    <span class="n">file_prefix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> 
                    <span class="n">new_folder</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Makes a (deep) copy of a dataset, changing the file names.</span>
<span class="sd">        </span>
<span class="sd">        Internally, this just calls `get_selection` with `query=&#39;True&#39;`.</span>

<span class="sd">        Args:</span>
<span class="sd">            file_suffix (Optional[str], optional): as in `change_filenames`. Defaults to &#39;_copy.h5&#39;.</span>
<span class="sd">            file_prefix (str, optional): as in `change_filenames`. Defaults to &#39;&#39;.</span>
<span class="sd">            new_folder (Union[str, None], optional): as in `change_filenames`. Defaults to None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            [type]: [description]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_selection</span><span class="p">(</span><span class="s1">&#39;True&#39;</span><span class="p">,</span> <span class="n">file_suffix</span><span class="p">,</span> <span class="n">file_prefix</span><span class="p">,</span> <span class="n">new_folder</span><span class="p">)</span></div>

<div class="viewcode-block" id="Dataset.aggregate"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.aggregate">[docs]</a>    <span class="k">def</span> <span class="nf">aggregate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">by</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;region&#39;</span><span class="p">,</span> <span class="s1">&#39;run&#39;</span><span class="p">,</span> <span class="s1">&#39;crystal_id&#39;</span><span class="p">),</span>
                  <span class="n">how</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;sum&#39;</span><span class="p">,</span>
                  <span class="n">file_suffix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;_agg.h5&#39;</span><span class="p">,</span> <span class="n">file_prefix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">new_folder</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                  <span class="n">query</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                  <span class="n">exclude_stacks</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Dataset&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Aggregate sub-sets of stacks (like individual diffraction movies) using different aggregation functions.</span>
<span class="sd">        </span>
<span class="sd">        Each set of shots with identical values of the columns specified in `by` will be squashed into a single</span>
<span class="sd">        one, using aggregation functions applied to the stacks as described in `how`. These can be different for each of</span>
<span class="sd">        the stacks. Unlike for the stacks, inconsistent fields in the shot list within each group are simply killed.</span>
<span class="sd">        The function finally returns a new dataset containing the aggregated data, it leaves the existing set untouched.</span>
<span class="sd">        </span>
<span class="sd">        The typical application is to sum sub-stacks of dose fractionation movies, or shots with different tilt angles </span>
<span class="sd">        (quasi-precession). If you&#39;re familiar with pandas a bit, it&#39;s sort of like a `DataSet.GroupBy(by).agg&#39; operation.</span>
<span class="sd">        </span>
<span class="sd">        In most cases (well-ordered data sets), this function should just work. More pathological ones are not</span>
<span class="sd">        sufficiently tested, though some sanity checks and precautions are taken.</span>
<span class="sd">        </span>
<span class="sd">        As an example: setting how=[&#39;sample&#39;, &#39;region&#39;, &#39;run&#39;, &#39;crystal_id&#39;] (which is the default) will aggregate over</span>
<span class="sd">        all shots taken in a single run, and if you set how=&#39;sum&#39;, the stacks will be added.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            by (Union[list, tuple], optional): shot table columns to group by for aggregation. </span>
<span class="sd">                Defaults to (&#39;sample&#39;, &#39;region&#39;, &#39;run&#39;, &#39;crystal_id&#39;).</span>
<span class="sd">            how (Union[dict, str], optional): string specifying the aggregation method for stacks. Allowed</span>
<span class="sd">                values are &#39;mean&#39;, &#39;sum&#39;, &#39;first&#39;, &#39;last&#39;. You can also specify a dict with different values</span>
<span class="sd">                for each stack, like {&#39;raw_counts&#39;: &#39;sum&#39;, &#39;nPeaks&#39;: &#39;first&#39;}. Defaults to &#39;sum&#39;.</span>
<span class="sd">            file_suffix (str, optional): as in `change_filenames`. Defaults to &#39;_agg.h5&#39;.</span>
<span class="sd">            file_prefix (str, optional): as in `change_filenames`. Defaults to &#39;&#39;.</span>
<span class="sd">            new_folder (Union[str, None], optional): as in `change_filenames`. Defaults to None.</span>
<span class="sd">            query (Union[str, None], optional): additional query to sub-select data before aggregation (as in </span>
<span class="sd">                `select` or `get_selection). E.g. query=&#39;frame &gt;= 1 and frame &lt; 5&quot; would only aggregate frames</span>
<span class="sd">                1 to 4. Defaults to None.</span>
<span class="sd">            exclude_stacks (Optional[list], optional): Exclude stacks from the aggregated dataset. Defaults to None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dataset: Dataset containing the aggregated data</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#TODO: fast agg only works on 3D arrays currently!</span>
        <span class="c1"># from time import time</span>
        <span class="c1"># T0 = time()</span>
        <span class="n">by</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">by</span><span class="p">)</span>
        <span class="n">newset</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">newset</span><span class="o">.</span><span class="n">_stacks</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">exclude_stacks</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">exclude_stacks</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">exclude_stacks</span>
        
        <span class="c1"># PART 1: MAKE A NEW SHOT TABLE ---</span>
        
        <span class="c1"># get shot selection and aggregation groups</span>
        <span class="n">shsel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">query</span><span class="p">)</span> <span class="k">if</span> <span class="n">query</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">gb</span> <span class="o">=</span> <span class="n">shsel</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">by</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        
        <span class="c1"># get shot list columns that are (non-)identical within each aggregation group</span>
        <span class="n">nonid</span> <span class="o">=</span> <span class="p">(</span><span class="n">gb</span><span class="o">.</span><span class="n">nunique</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
        <span class="n">cols_nonid</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nonid</span><span class="p">[</span><span class="n">nonid</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="n">cols_id</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nonid</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">nonid</span><span class="p">)]</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

        <span class="c1"># add some information to shot list</span>
        <span class="n">sh_initial</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">shsel</span><span class="p">,</span> <span class="n">gb</span><span class="o">.</span><span class="n">ngroup</span><span class="p">()</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;_agg_grp_id&#39;</span><span class="p">),</span> <span class="n">gb</span><span class="o">.</span><span class="n">cumcount</span><span class="p">()</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;_agg_shot_in_grp&#39;</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># re-sort initial table if required</span>
        <span class="n">monotonous</span> <span class="o">=</span> <span class="p">(</span><span class="n">sh_initial</span><span class="p">[</span><span class="s1">&#39;_agg_grp_id&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">values</span> <span class="o">-</span> <span class="n">sh_initial</span><span class="p">[</span><span class="s1">&#39;_agg_grp_id&#39;</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">monotonous</span><span class="p">:</span>
            <span class="n">sh_initial</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_agg_grp_id&#39;</span><span class="p">,</span><span class="s1">&#39;_agg_shot_in_grp&#39;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            
        <span class="c1"># some sanity checks and status report</span>
        <span class="n">by_frame</span> <span class="o">=</span> <span class="p">(</span><span class="n">sh_initial</span><span class="p">[</span><span class="s1">&#39;frame&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">sh_initial</span><span class="p">[</span><span class="s1">&#39;_agg_shot_in_grp&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">nunique</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="n">by_run</span> <span class="o">=</span> <span class="p">(</span><span class="n">sh_initial</span><span class="p">[</span><span class="s1">&#39;run&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">sh_initial</span><span class="p">[</span><span class="s1">&#39;_agg_shot_in_grp&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">nunique</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Monotonous aggregation:&#39;</span><span class="p">,</span> <span class="n">monotonous</span><span class="p">,</span> <span class="s1">&#39;&#39;</span> <span class="k">if</span> <span class="n">monotonous</span> <span class="k">else</span> <span class="s1">&#39;(PLEASE CHECK IF THIS IS DESIRED)&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;File/subset remixing:&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;file&#39;</span> <span class="ow">in</span> <span class="n">cols_nonid</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="s1">&#39;subset&#39;</span> <span class="ow">in</span> <span class="n">cols_nonid</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Frame aggregation:&#39;</span><span class="p">,</span> <span class="n">by_frame</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Acq. run aggregation:&#39;</span><span class="p">,</span> <span class="n">by_run</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Discarding shot table columns:&#39;</span><span class="p">,</span> <span class="n">cols_nonid</span><span class="p">)</span>

        <span class="c1"># generate mandatory cols (if files/subsets are remixed):</span>
        <span class="k">def</span> <span class="nf">generate_common_name</span><span class="p">(</span><span class="n">name_list</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">reduce</span>
            <span class="kn">from</span> <span class="nn">difflib</span> <span class="kn">import</span> <span class="n">SequenceMatcher</span>
            <span class="k">return</span> <span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">s1</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">a</span><span class="p">:</span><span class="n">m</span><span class="o">.</span><span class="n">a</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="n">size</span><span class="p">]</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span>
                                                <span class="n">SequenceMatcher</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span><span class="o">.</span><span class="n">get_matching_blocks</span><span class="p">()]),</span> <span class="n">name_list</span><span class="p">)</span>
        <span class="n">missing</span> <span class="o">=</span> <span class="p">[</span><span class="n">fn</span> <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="s1">&#39;subset&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">fn</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cols_id</span><span class="p">]</span>
        <span class="n">ssfields</span> <span class="o">=</span> <span class="n">gb</span><span class="p">[</span><span class="n">missing</span><span class="p">]</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">generate_common_name</span><span class="p">)</span> <span class="k">if</span> <span class="n">missing</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="c1"># compute final shot list</span>
        <span class="n">sh_final</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">gb</span><span class="p">[</span><span class="n">cols_id</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;shot_in_subset&#39;</span><span class="p">,</span> <span class="s1">&#39;Event&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">gb</span><span class="o">.</span><span class="n">size</span><span class="p">()</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;agg_len&#39;</span><span class="p">),</span> <span class="n">ssfields</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">newset</span><span class="o">.</span><span class="n">_shots</span> <span class="o">=</span> <span class="n">sh_final</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        
        <span class="c1"># PART 2: DATA STACKS ---</span>
            
        <span class="c1"># aggregating functions</span>
        <span class="n">func_lib</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;sum&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                    <span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                    <span class="s1">&#39;first&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[:</span><span class="mi">1</span><span class="p">,</span><span class="o">...</span><span class="p">],</span>
                    <span class="s1">&#39;last&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:,</span><span class="o">...</span><span class="p">]}</span>
            
        <span class="k">for</span> <span class="n">sn</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stacks</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="k">if</span> <span class="n">sn</span> <span class="ow">in</span> <span class="n">exclude_stacks</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">method</span> <span class="o">=</span> <span class="n">how</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">sn</span><span class="p">,</span> <span class="s1">&#39;first&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">how</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="k">else</span> <span class="n">how</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">method</span> <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">method</span><span class="p">)</span> <span class="k">else</span> <span class="n">func_lib</span><span class="p">[</span><span class="n">method</span><span class="p">]</span>

            <span class="c1"># sliced and re-ordered stack</span>
            <span class="n">stk_sel</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">sh_initial</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">,</span><span class="o">...</span><span class="p">]</span>

            <span class="c1"># aggregated stack</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">stk_agg</span> <span class="o">=</span> <span class="n">_map_sub_blocks</span><span class="p">(</span><span class="n">stk_sel</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">sh_initial</span><span class="p">[</span><span class="s1">&#39;_agg_grp_id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                                      <span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;aggregate_&#39;</span><span class="o">+</span><span class="n">method</span><span class="p">,</span> <span class="n">aggregating</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Unknown aggregation method </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s1">. Allowed ones are </span><span class="si">{</span><span class="nb">tuple</span><span class="p">(</span><span class="n">func_lib</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;Mismatched chunk structure&#39;</span><span class="p">):</span>
                    <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Stack </span><span class="si">{</span><span class="n">sn</span><span class="si">}</span><span class="s1"> has mismatched chunk structure. Rechunking to minimum chunk sizes. &#39;</span>
                         <span class="s1">&#39;Consider rechunking manually before, to improve performance.&#39;</span><span class="p">)</span>
                    <span class="c1">#TODO this comes with quite a performance penalty, but sth more complex would be comlex.</span>
                    <span class="n">stk_rec</span> <span class="o">=</span> <span class="n">stk_sel</span><span class="o">.</span><span class="n">rechunk</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">sh_final</span><span class="p">[</span><span class="s1">&#39;agg_len&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)})</span>
                    <span class="n">stk_agg</span> <span class="o">=</span> <span class="n">_map_sub_blocks</span><span class="p">(</span><span class="n">stk_rec</span><span class="p">,</span>
                                              <span class="n">labels</span><span class="o">=</span><span class="n">sh_initial</span><span class="p">[</span><span class="s1">&#39;_agg_grp_id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> 
                                              <span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;aggregate_&#39;</span><span class="o">+</span><span class="n">method</span><span class="p">,</span> 
                                              <span class="n">aggregating</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error during aggregation of stack &#39;</span> <span class="o">+</span> <span class="n">sn</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="n">e</span>
            
            <span class="n">newset</span><span class="o">.</span><span class="n">add_stack</span><span class="p">(</span><span class="n">sn</span><span class="p">,</span> <span class="n">stk_agg</span><span class="p">)</span>

        <span class="c1"># PART 3: OTHER STUFF ---</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">newset</span><span class="o">.</span><span class="n">_features</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_features</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">newset</span><span class="o">.</span><span class="n">_shots</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_feature_id_cols</span><span class="p">],</span>
                                                    <span class="n">on</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_feature_id_cols</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;inner&#39;</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="s1">&#39;1:m&#39;</span><span class="p">)</span><span class="o">.</span> \
                <span class="n">drop_duplicates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_feature_id_cols</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Could not aggregate features. Leaving them all in.&#39;</span><span class="p">)</span>

        <span class="n">newset</span><span class="o">.</span><span class="n">_file_handles</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">newset</span><span class="o">.</span><span class="n">change_filenames</span><span class="p">(</span><span class="n">file_suffix</span><span class="p">,</span> <span class="n">file_prefix</span><span class="p">,</span> <span class="n">new_folder</span><span class="p">,</span> <span class="n">keep_raw</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">newset</span><span class="o">.</span><span class="n">reset_id</span><span class="p">(</span><span class="n">keep_raw</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">newset</span><span class="o">.</span><span class="n">persist_stacks</span><span class="p">([</span><span class="n">sn</span> <span class="k">for</span> <span class="n">sn</span><span class="p">,</span> <span class="n">inmem</span> <span class="ow">in</span> <span class="n">newset</span><span class="o">.</span><span class="n">_stack_in_memory</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">inmem</span><span class="p">])</span>        

        <span class="k">return</span> <span class="n">newset</span></div>
    
<div class="viewcode-block" id="Dataset.transform_stack_groups"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.transform_stack_groups">[docs]</a>    <span class="k">def</span> <span class="nf">transform_stack_groups</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stacks</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">],</span> 
                               <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                               <span class="n">by</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;region&#39;</span><span class="p">,</span> <span class="s1">&#39;run&#39;</span><span class="p">,</span> <span class="s1">&#39;crystal_id&#39;</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For all data stacks listed in stacks, transforms sub-stacks within groups defined by `by` using the</span>
<span class="sd">        function in `func`.</span>
<span class="sd">        </span>
<span class="sd">        The dimensions of each sub-stack must not change in the process. </span>
<span class="sd">        Note that, unlike for `get_selection` or `aggregate`,</span>
<span class="sd">        this happens *in place*, i.e., the stacks will be **overwritten** by a transformed version! If this</span>
<span class="sd">        is not what you want, first make a copy of your data set, using `copy`.</span>
<span class="sd">        </span>
<span class="sd">        A typical application is to calculate a cumulative sum of patterns wittin each diffraction movie. This</span>
<span class="sd">        is what the default parameters for `by` and `func` is doing. Can do all kinds of other fun things, i.e. </span>
<span class="sd">        calculating directly the difference between frames, the difference of each w.r.t. the first,</span>
<span class="sd">        normalizing them to sth, etc.</span>

<span class="sd">        Args:</span>
<span class="sd">            stacks: Name(s) of data stacks to be transformed</span>
<span class="sd">            func: Function applied to each sub-stack. Must act on a numpy</span>
<span class="sd">                array and return one of the same dimensions. Defaults to `lambda x: np.cumsum(x, axis=0)`.</span>
<span class="sd">            by: Shot table columns to identify groups - similar to how it&#39;s done in `aggregate`.</span>
<span class="sd">                Defaults to `(&#39;sample&#39;, &#39;region&#39;, &#39;run&#39;, &#39;crystal_id&#39;)`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">stacks</span> <span class="o">=</span> <span class="p">[</span><span class="n">stacks</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stacks</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">stacks</span>
        <span class="n">by</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">by</span><span class="p">)</span>
        <span class="n">feature_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">by</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">ngroup</span><span class="p">()</span><span class="o">.</span><span class="n">values</span>
        <span class="k">for</span> <span class="n">sn</span> <span class="ow">in</span> <span class="n">stacks</span><span class="p">:</span>
            <span class="n">transformed</span> <span class="o">=</span> <span class="n">_map_sub_blocks</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stacks</span><span class="p">[</span><span class="n">sn</span><span class="p">],</span> <span class="n">feature_id</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">aggregating</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_stack</span><span class="p">(</span><span class="n">sn</span><span class="p">,</span> <span class="n">transformed</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">persist_stacks</span><span class="p">([</span><span class="n">sn</span> <span class="k">for</span> <span class="n">sn</span> <span class="ow">in</span> <span class="n">stacks</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stack_in_memory</span><span class="p">[</span><span class="n">sn</span><span class="p">]])</span></div>

<div class="viewcode-block" id="Dataset.init_stacks"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.init_stacks">[docs]</a>    <span class="k">def</span> <span class="nf">init_stacks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Opens files briefly in readonly mode, to check stack names shapes etc., and closes them again right away. </span>

<span class="sd">        Args:</span>
<span class="sd">            **kwargs: any arguments are passed to `open_stacks`</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># warn(&#39;init_stacks is often not required. Double-check if you really need it.&#39;, DeprecationWarning)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">open_stacks</span><span class="p">(</span><span class="n">init</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">readonly</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close_files</span><span class="p">()</span></div>

<div class="viewcode-block" id="Dataset.close_files"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.close_files">[docs]</a>    <span class="k">def</span> <span class="nf">close_files</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Closes all HDF5 files.</span>
<span class="sd">        </span>
<span class="sd">        Note that this might have side effects: if stacks are accessible that depend on non-persisted HDF5 datasets</span>
<span class="sd">        in the files, they will not be usable anymore after issuing this command and cause trouble especially</span>
<span class="sd">        for the distributed scheduler. So don&#39;t close the files unless you really have to.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_file_handles</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">del</span> <span class="n">f</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_file_handles</span> <span class="o">=</span> <span class="p">{}</span></div>

    <span class="n">close_stacks</span> <span class="o">=</span> <span class="n">close_files</span>

<div class="viewcode-block" id="Dataset.open_stacks"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.open_stacks">[docs]</a>    <span class="k">def</span> <span class="nf">open_stacks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">checklen</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
        <span class="n">readonly</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">swmr</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">chunking</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;dataset&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Opens data stacks from HDF5 (NeXus) files (found by the &quot;data_pattern&quot; attribute), and assigns dask array</span>
<span class="sd">        objects to them. After opening, the arrays or parts of them can be accessed through the stacks attribute,</span>
<span class="sd">        or directly using a dataset.stack syntax, and loaded using the .compute() or .persist() method of the arrays.</span>
<span class="sd">        </span>
<span class="sd">        A critical point here is how the chunking of the dask arrays is done. Especially for the initial opening</span>
<span class="sd">        of raw data this is crucial for (as in: orders of magnitude) the performance of downstream tasks. You have</span>
<span class="sd">        several options, those are, in decreasing order of recommendation:</span>
<span class="sd">        </span>
<span class="sd">        * &#39;dataset&#39; to use what is set in the current dataset zchunks property (default). This will not work for a fresh</span>
<span class="sd">          dataset, in which case you have to specify it from scratch.</span>
<span class="sd">        * &#39;hdf5&#39; to use the chunksize recommended in the HDF5 file (&#39;recommended_zchunks&#39; attribute) of the</span>
<span class="sd">          data stacks group.</span>
<span class="sd">        * an integer number for a defined (approximate) chunk size, which ignores shots with frame number &lt; -1. This means,</span>
<span class="sd">          that after a get_selection command or anything that filters out dummy shots, equal chunk sizes are achieved.</span>
<span class="sd">          This is the recommended way of chunking for totally from-scratch datasets which don&#39;t yet have the</span>
<span class="sd">          recommended_zchunks attribute set. Something of the order of 10 is often a good choice if you want to work</span>
<span class="sd">          with the set as is, if you want to aggregate early on, choose something bigger (rather 100).</span>
<span class="sd">          **If your dataset comprises diffraction movies, this should be an integer</span>
<span class="sd">          multiple of the number of frames within each.**</span>
<span class="sd">        * an iterable to explicitly set the chunk sizes</span>
<span class="sd">        * &#39;existing&#39; to use the chunking of an already-existing stack which is about to be overwritten.</span>
<span class="sd">          Should usually be the same as &#39;dataset&#39;, but still works if your stacks have inconsistent chunking.</span>
<span class="sd">        * &#39;auto&#39; to use the dask automatic mode, with inevitably sub-optimal results.</span>

<span class="sd">        Args:</span>
<span class="sd">            labels (Union[None, list], optional): lLst of stacks to open. To open all stacks, set to None. Defaults to None.</span>
<span class="sd">            checklen (bool, optional): check if stack heights (first dimension) is equal to shot list length. Defaults to True.</span>
<span class="sd">            init (bool, optional): do not load stacks, just make empty dask arrays.  Defaults to False.</span>
<span class="sd">            readonly (bool, optional): open HDF5 files in read-only mode. Defaults to True.</span>
<span class="sd">            swmr (bool, optional): open HDF5 files in SWMR mode. Defaults to False.</span>
<span class="sd">            chunking (Union[int, str, list, tuple], optional): [description]. Defaults to &#39;dataset&#39;.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#TODO DO NOT OVERWRITE PERSISTED STACKS!</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">readonly</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_files_open</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_files_writable</span><span class="p">)</span> <span class="ow">or</span> \
            <span class="p">(</span><span class="n">readonly</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_files_writable</span><span class="p">):</span>
                
            <span class="k">if</span> <span class="n">chunking</span> <span class="o">!=</span> <span class="s1">&#39;existing&#39;</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Reopening files in a different mode. Chunking will be set to &quot;existing&quot;.&#39;</span><span class="p">)</span>
                <span class="n">chunking</span> <span class="o">=</span> <span class="s1">&#39;existing&#39;</span>
                
            <span class="c1"># reopen the stacks in a different mode!</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">close_files</span><span class="p">()</span>
            
        <span class="k">if</span> <span class="ow">not</span> <span class="n">readonly</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_files_writable</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">swmr</span><span class="p">:</span>
            <span class="c1"># write access already. Nobody else had access anyway</span>
            <span class="k">return</span>
               
        <span class="c1"># TODO offer even more sophisticated chunking which always aligns with frames</span>
        <span class="k">if</span> <span class="s1">&#39;frame&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">sets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="p">[[</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="s1">&#39;subset&#39;</span><span class="p">,</span> <span class="s1">&#39;shot_in_subset&#39;</span><span class="p">,</span> <span class="s1">&#39;frame&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span> <span class="c1"># TODO why is the drop duplicates required?</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="p">[[</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="s1">&#39;subset&#39;</span><span class="p">,</span> <span class="s1">&#39;shot_in_subset&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span>
            <span class="n">sets</span><span class="p">[</span><span class="s1">&#39;frame&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">stacks</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">chunking</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">chunking</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">chunking</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            
        <span class="k">elif</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">chunking</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">chunking</span><span class="o">==</span><span class="s1">&#39;dataset&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">zchunks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">chunking</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zchunks</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Dataset chunking is undefined (yet). You have to pick an explicit chunking option.&#39;</span><span class="p">)</span>
            
        <span class="k">for</span> <span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">subset</span><span class="p">),</span> <span class="n">subgrp</span> <span class="ow">in</span> <span class="n">sets</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="s1">&#39;subset&#39;</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_file_handles</span><span class="p">[</span><span class="n">fn</span><span class="p">]</span> <span class="o">=</span> <span class="n">fh</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">swmr</span><span class="o">=</span><span class="n">swmr</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span> <span class="k">if</span> <span class="n">readonly</span> <span class="k">else</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">chunking</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">subgrp</span><span class="o">.</span><span class="n">frame</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="c1"># print(&#39;Found auxiliary frames, adjusting chunking...&#39;)</span>
                <span class="c1"># frames = subgrp[[&#39;frame&#39;]].copy()</span>
                <span class="n">blocks</span> <span class="o">=</span> <span class="p">((</span><span class="n">subgrp</span><span class="p">[</span><span class="s1">&#39;frame&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">chunking</span>
                <span class="n">zchunks</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">subgrp</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">blocks</span><span class="p">)[</span><span class="s1">&#39;frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">())</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">chunking</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">zchunks</span> <span class="o">=</span> <span class="n">chunking</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">chunking</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">chk</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">Nshot</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">subgrp</span><span class="p">)</span>
                <span class="k">while</span> <span class="n">Nshot</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">chk</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chunking</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>
                    <span class="n">Nshot</span> <span class="o">-=</span> <span class="n">chk</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">Nshot</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Requested chunking is incommensurate with file/subset boundaries!&#39;</span><span class="p">)</span>
                <span class="n">zchunks</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">chk</span><span class="p">)</span>      
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">chunking</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">chunking</span> <span class="o">==</span> <span class="s1">&#39;hdf5&#39;</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">zchunks</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">fh</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">data_pattern</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;%&#39;</span><span class="p">,</span> <span class="n">subset</span><span class="p">)]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;recommended_zchunks&#39;</span><span class="p">])</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The HDF5 files do</span><span class="se">\&#39;</span><span class="s1">nt have a chunking preset. Please specify chunking explicitly.&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">zchunks</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">grp</span> <span class="o">=</span> <span class="n">fh</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">data_pattern</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;%&#39;</span><span class="p">,</span> <span class="n">subset</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grp</span><span class="p">,</span> <span class="n">h5py</span><span class="o">.</span><span class="n">Group</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">curr_lbl</span> <span class="o">=</span> <span class="n">grp</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;signal&#39;</span><span class="p">]</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">curr_lbl</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                        <span class="n">curr_lbl</span> <span class="o">=</span> <span class="n">curr_lbl</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_diff_stack_label</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_diff_stack_label</span> <span class="o">=</span> <span class="n">curr_lbl</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_diff_stack_label</span> <span class="o">!=</span> <span class="n">curr_lbl</span><span class="p">:</span>
                        <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Non-matching primary diffraction stack labels: &#39;</span>
                            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_diff_stack_label</span><span class="si">}</span><span class="s1"> vs </span><span class="si">{</span><span class="n">grp</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;signal&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                        
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="c1"># no diff stack label stored</span>
                    <span class="n">curr_lbl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_diff_stack_label</span>
                
                <span class="k">for</span> <span class="n">dsname</span><span class="p">,</span> <span class="n">ds</span> <span class="ow">in</span> <span class="n">grp</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">ds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="c1"># can happen for dangling soft links</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="p">((</span><span class="n">labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">dsname</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">))</span> \
                            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">h5py</span><span class="o">.</span><span class="n">Dataset</span><span class="p">)</span> \
                            <span class="ow">and</span> <span class="p">(</span><span class="s1">&#39;pandas_type&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">attrs</span><span class="p">):</span>
                        <span class="c1"># h5 dataset for file/subset found!</span>
                        <span class="k">if</span> <span class="n">checklen</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">subgrp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Stack height mismatch in f</span><span class="si">{</span><span class="n">fn</span><span class="si">}</span><span class="s1">:</span><span class="si">{</span><span class="n">subset</span><span class="si">}</span><span class="s1">. &#39;</span> <span class="o">+</span>
                                             <span class="sa">f</span><span class="s1">&#39;Expected </span><span class="si">{</span><span class="n">subgrp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> shots, found </span><span class="si">{</span><span class="n">ds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
                        
                        <span class="k">if</span> <span class="n">zchunks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">chunks</span> <span class="o">=</span> <span class="p">(</span><span class="n">zchunks</span><span class="p">,)</span> <span class="o">+</span> <span class="n">ds</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                        <span class="k">elif</span> <span class="n">chunking</span> <span class="o">==</span> <span class="s1">&#39;hdf5&#39;</span><span class="p">:</span>
                            <span class="n">chunks</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">chunks</span>
                        <span class="k">elif</span> <span class="n">chunking</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
                            <span class="n">chunks</span> <span class="o">=</span> <span class="s1">&#39;auto&#39;</span>
                        <span class="k">elif</span> <span class="n">chunking</span> <span class="o">==</span> <span class="s1">&#39;existing&#39;</span><span class="p">:</span>
                            <span class="n">chunks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stacks</span><span class="p">[</span><span class="n">dsname</span><span class="p">][</span><span class="n">subgrp</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">,</span><span class="o">...</span><span class="p">]</span><span class="o">.</span><span class="n">chunks</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;chunking must be an integer, list, tuple, &quot;dataset&quot;, or &quot;auto&quot;.&#39;</span><span class="p">)</span>
                        
                        <span class="n">stackname</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
                                                <span class="n">subset</span><span class="p">,</span> <span class="n">dsname</span><span class="p">])</span>

                        <span class="k">if</span> <span class="n">init</span><span class="p">:</span>
                            <span class="n">newstack</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">ds</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ds</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">stackname</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># print(&#39;adding stack: &#39;+ds.name)</span>
                            <span class="n">newstack</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">stackname</span><span class="p">)</span>
                        <span class="n">stacks</span><span class="p">[</span><span class="n">dsname</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newstack</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">sn</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stacks</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_stacks</span><span class="p">[</span><span class="n">sn</span><span class="p">]</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> 
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Could not read stack </span><span class="si">{</span><span class="n">sn</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Dataset.Stacks"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.Stacks">[docs]</a>    <span class="nd">@contextmanager</span>
    <span class="k">def</span> <span class="nf">Stacks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Context manager to handle the opening and closing of stacks.</span>
<span class="sd">        returns the opened data stacks, which are automatically closed</span>
<span class="sd">        once the context is left. Arguments are passed to open_stacks Example:</span>
<span class="sd">            with ds.Stacks(readonly=True, chunking=&#39;dataset&#39;) as stk:</span>
<span class="sd">                center = stk.beam_center.compute()</span>
<span class="sd">            print(&#39;Have&#39;, center.shape[0], &#39;centers.&#39;)</span>
<span class="sd">        **This is deprecated, and using it is horribly discouraged**</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Use of the Stacks context manager is deprecated and may cause pain and sorrow.&#39;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">open_stacks</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">stacks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close_files</span><span class="p">()</span></div>

<div class="viewcode-block" id="Dataset.add_stack"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.add_stack">[docs]</a>    <span class="k">def</span> <span class="nf">add_stack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">stack</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">h5py</span><span class="o">.</span><span class="n">Dataset</span><span class="p">],</span> 
                  <span class="n">overwrite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">set_diff_stack</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                  <span class="n">persist</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">rechunk</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds a data stack to the data set.</span>
<span class="sd">        </span>
<span class="sd">        The new data stack can be either a dask array or a numpy array. The only restriction is that its</span>
<span class="sd">        first dimension&#39;s length (i.e. total number of shots) has to equal the rest of the dataset. The</span>
<span class="sd">        stack is *not* stored to disk yet, but it&#39;s placed under the control of the dataset object.</span>
<span class="sd">        </span>
<span class="sd">        If the new data is a numpy array, it will be turned into a dask array with appropriate properties. By</span>
<span class="sd">        default (persist=True), it will be eagerly persisted, that is, a copy will be made and the dask graph will</span>
<span class="sd">        be simplified.</span>

<span class="sd">        Args:</span>
<span class="sd">            label (str): Label for the new stack</span>
<span class="sd">            stack (Union[da.Array, np.ndarray, h5py.Dataset]): New data stack</span>
<span class="sd">            overwrite (bool, optional): Overwrite, if an identically named stack exists already. Defaults to False.</span>
<span class="sd">            set_diff_stack (bool, optional): Set the new stack as the &#39;diffraction data&#39; stack, which will</span>
<span class="sd">                recieve some special treatment (e.g. it is never loaded into memory). Defaults to False.</span>
<span class="sd">            persist (bool, optional): If the stack is a numpy array, make the dask array persited right away. </span>
<span class="sd">                There is little speaking against it except for some edge cases. Defaults to True.</span>
<span class="sd">            rechunk (bool, optional): If the stack is a dask array with a chunk along the first dimension that</span>
<span class="sd">                does not match the dataset&#39;s overall chunking, rechunk it. This is highly recommended. Defaults to True.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">stack</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Stack height must equal that of the shot list.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stacks</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">overwrite</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Stack with name </span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s1"> already exists. Set overwrite = True.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">):</span>
            <span class="n">ch</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">ndim</span> <span class="o">*</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">ch</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zchunks</span>          
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">persist</span><span class="p">:</span>
                <span class="n">stack</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ch</span><span class="p">))</span><span class="o">.</span><span class="n">persist</span><span class="p">(</span><span class="n">scheduler</span><span class="o">=</span><span class="s1">&#39;threading&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stack</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ch</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zchunks</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zchunks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">rechunk</span><span class="p">:</span>
                    <span class="n">stack</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">rechunk</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">zchunks</span><span class="p">})</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Stack has a different chunking than the dataset!&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">set_diff_stack</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_diff_stack_label</span> <span class="o">=</span> <span class="n">label</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_stacks</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">stack</span></div>

<div class="viewcode-block" id="Dataset.delete_stack"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.delete_stack">[docs]</a>    <span class="k">def</span> <span class="nf">delete_stack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">from_files</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete a data stack from the dataset</span>

<span class="sd">        Args:</span>
<span class="sd">            label (str): label of the stack to delete</span>
<span class="sd">            from_files (bool, optional): Also delete stack from the data files. Note that this will</span>
<span class="sd">            actually not free up disk space (you need to make a copy of the files for this), and only</span>
<span class="sd">            works if the files are open in writable mode. Defaults to False.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stacks</span><span class="p">[</span><span class="n">label</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Stack </span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s1"> does not exist, not deleting anything.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">label</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_diff_stack_label</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_diff_stack_label</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Deleting diffraction data stack </span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">from_files</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">address</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="p">[[</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="s1">&#39;subset&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_pattern</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;%&#39;</span><span class="p">,</span> <span class="n">address</span><span class="o">.</span><span class="n">subset</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">label</span>
                <span class="c1">#print(f&#39;Deleting dataset {path}&#39;)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_file_handles</span><span class="p">[</span><span class="n">address</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">]][</span><span class="n">path</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">pass</span></div>
                    <span class="c1">#print(address[&#39;file&#39;], path, &#39;not found!&#39;)</span>
                    
<div class="viewcode-block" id="Dataset.persist_stacks"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.persist_stacks">[docs]</a>    <span class="k">def</span> <span class="nf">persist_stacks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">exclude</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="n">include_3d</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">scheduler</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Client</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;threading&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Persist the stacks to memory (locally and/or on the cluster workers), that is, they are computed.</span>
<span class="sd">        but actually not changed to numpy arrays, just immediately available dask arrays without an actual</span>
<span class="sd">        task graph. It is recommended to have as many stacks persisted as possible.</span>
<span class="sd">        The diffraction data stack is automatically excluded, as are any 3D arrays (be default).</span>
<span class="sd">        </span>
<span class="sd">        Note:</span>
<span class="sd">            There are important subtleties about which dask scheduler to use here. If you have a </span>
<span class="sd">            dask.distributed cluster running (and you often will), the underlying dask.persist() function if </span>
<span class="sd">            called without parameters will</span>
<span class="sd">            compute and persist the data on the *workers* of the cluster, not the local machine. For our typical</span>
<span class="sd">            applications (making access to small meta stacks faster and less error-prone), that&#39;s the wrong</span>
<span class="sd">            choice. Hence, scheduler=&#39;threading&#39; by default (you might as well use &#39;single-threaded&#39;). However,</span>
<span class="sd">            there might be cases where persisting on the workers make sense - in that case just set the scheduler</span>
<span class="sd">            argument to your client object.</span>

<span class="sd">        Args:</span>
<span class="sd">            labels (Union[None, str, list], optional): Labels of stacks to persist (None: all except for the one </span>
<span class="sd">                set in diff_stack_label). Defaults to None.</span>
<span class="sd">            exclude (Union[None, str, list], optional): Stacks to exclude. Defaults to None.</span>
<span class="sd">            include_3d (bool, optional): Include 3D stacks. Defaults to False.</span>
<span class="sd">            scheduler (Union[str, Client], optional): What scheduler to use. Defaults to &#39;threading&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_stacks</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">labels</span><span class="p">]</span>          
              
        <span class="k">if</span> <span class="n">exclude</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exclude</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exclude</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">exclude</span> <span class="o">=</span> <span class="p">[</span><span class="n">exclude</span><span class="p">]</span>
            
        <span class="k">if</span> <span class="ow">not</span> <span class="n">include_3d</span><span class="p">:</span>
            <span class="n">exclude</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">sn</span> <span class="k">for</span> <span class="n">sn</span><span class="p">,</span> <span class="n">stk</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stacks</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">stk</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">])</span>
            
        <span class="n">exclude</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_diff_stack_label</span><span class="p">)</span>
        
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">labels</span> <span class="k">if</span> <span class="n">l</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclude</span><span class="p">]</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Persisting stacks to memory:&#39;</span><span class="p">,</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">labels</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stacks</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dask</span><span class="o">.</span><span class="n">persist</span><span class="p">({</span><span class="n">sn</span><span class="p">:</span> <span class="n">stk</span> <span class="k">for</span> <span class="n">sn</span><span class="p">,</span> <span class="n">stk</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stacks</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">stk</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">},</span> 
                                         <span class="n">scheduler</span><span class="o">=</span><span class="n">scheduler</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span></div>

<div class="viewcode-block" id="Dataset.store_stacks"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.store_stacks">[docs]</a>    <span class="k">def</span> <span class="nf">store_stacks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">exclude</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                    <span class="n">compression</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">32004</span><span class="p">,</span> <span class="n">lazy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">data_pattern</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                    <span class="n">progress_bar</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">scheduler</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;threading&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Stores stacks with given labels to the HDF5 data files. For stacks which are not</span>
<span class="sd">        persisted, at this point the actual calculation is done here. </span>
<span class="sd">        </span>
<span class="sd">        Note:</span>
<span class="sd">            This way of computing</span>
<span class="sd">            and storing data is restricted to threading (which does not help much) or single-threaded computation, i.e. </span>
<span class="sd">            it&#39;s **not** recommended for heavy lifting, like computing corrected/aggregated/modified diffraction patterns. </span>
<span class="sd">            In this case, better use true parallelism provided by `store_stack_fast`, which uses `dask.distributed` for</span>
<span class="sd">            scheduling.</span>

<span class="sd">        Args:</span>
<span class="sd">            labels (Union[None, str, list], optional): Stacks to be written. If None, write all stacks, *including* </span>
<span class="sd">                the diffraction data stack. Defaults to None.</span>
<span class="sd">            exclude (Union[None, str, list], optional): Stacks to exclude. It might be wise to set the diffraction</span>
<span class="sd">                data stack here. Defaults to None.</span>
<span class="sd">            overwrite (bool, optional): Overwrite existing stacks (HDF5 datasets) in the files. Defaults to False.</span>
<span class="sd">            compression (Union[str, int], optional): HDF5 compression filter to use. Common choices are &#39;gzip&#39;, &#39;none&#39;,</span>
<span class="sd">                or 32004, which is the lz4 filter often used for diffraction data. Defaults to 32004.</span>
<span class="sd">            lazy (bool, optional): Instead of computing and storing the arrays, return a list of dask arrays and HDF5</span>
<span class="sd">                data sets, which can be inserted into dask.array.store. Defaults to False.</span>
<span class="sd">            data_pattern (Union[None,str], optional): store stacks to this data path (% is replaced by subset) instead </span>
<span class="sd">                of standard data path if not None.</span>
<span class="sd">                Note that stacks stored this way will not be retrievable through Dataset objects. Defaults to None.</span>
<span class="sd">            progress_bar (bool, optional): show a progress bar during calculation/storing. To prevent a mess,</span>
<span class="sd">                disable if you&#39;re running store_stacks in multiple processes simultaneously. Defaults to True.</span>
<span class="sd">            scheduler (str, optional): dask scheduler to be used. Can be &#39;threading&#39; or &#39;single-threaded&#39;. It is not</span>
<span class="sd">                possible to use &#39;multiprocessing&#39; due to conflicting access to HDF5 files. (If you want true parallel</span>
<span class="sd">                computation, you have to use `store_stack_fast` instead.) Defaults to &#39;threading&#39;.</span>
<span class="sd">            **kwargs: Will be forwarded to h5py.create_dataset</span>

<span class="sd">        Returns:</span>
<span class="sd">            None (if lazy=False)</span>
<span class="sd">            da.Array, h5py.Dataset: dask arrays and HDF5 dataset to pass to dask.array.store (if lazy=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_files_writable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Please open files in write mode before storing.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stacks</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">labels</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">exclude</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exclude</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exclude</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">exclude</span> <span class="o">=</span> <span class="p">[</span><span class="n">exclude</span><span class="p">]</span>
            
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">labels</span> <span class="k">if</span> <span class="n">l</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclude</span><span class="p">]</span>
        
        <span class="n">stacks</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stacks</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">}</span>
        <span class="n">stacks</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;index&#39;</span><span class="p">:</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zchunks</span><span class="p">,))})</span>

        <span class="n">datasets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">arrays</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">shots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shots</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>  <span class="c1"># just to be safe</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">ssn</span><span class="p">),</span> <span class="n">sss</span> <span class="ow">in</span> <span class="n">shots</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="s1">&#39;subset&#39;</span><span class="p">]):</span>
            <span class="n">fh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_handles</span><span class="p">[</span><span class="n">fn</span><span class="p">]</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">sss</span><span class="o">.</span><span class="n">shot_in_subset</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Non-continuous shot_in_subset in </span><span class="si">{</span><span class="n">fn</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">ssn</span><span class="si">}</span><span class="s1">. Please sort out this mess.&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">sss</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">stack_idcs</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">sss</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sss</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stack_idcs</span> <span class="o">=</span> <span class="n">sss</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># pathological case: non-continuous region in shot list</span>
                <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Shots for </span><span class="si">{</span><span class="n">fn</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">ssn</span><span class="si">}</span><span class="s1"> are non-contiguous in the shot list. Might hint at trouble.&#39;</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">stack</span> <span class="ow">in</span> <span class="n">stacks</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># print(label)</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="n">stack_idcs</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">data_pattern</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_pattern</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;%&#39;</span><span class="p">,</span> <span class="n">ssn</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">label</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">path</span> <span class="o">=</span> <span class="n">data_pattern</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;%&#39;</span><span class="p">,</span> <span class="n">ssn</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">label</span>

                <span class="c1">#print(&#39;Writing to &#39;, path)</span>
                <span class="k">try</span><span class="p">:</span>

                    <span class="c1"># print(path, cs, arr.shape)</span>
                    <span class="n">ds</span> <span class="o">=</span> <span class="n">fh</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                                           <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>
                                           <span class="n">compression</span><span class="o">=</span><span class="n">compression</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">except</span> <span class="p">(</span><span class="ne">RuntimeError</span><span class="p">,</span> <span class="ne">OSError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;name already exists&#39;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="n">overwrite</span> <span class="ow">or</span> <span class="n">label</span> <span class="o">==</span> <span class="s1">&#39;index&#39;</span><span class="p">):</span>
                        <span class="n">ds</span> <span class="o">=</span> <span class="n">fh</span><span class="o">.</span><span class="n">require_dataset</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                                                <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>
                                                <span class="n">compression</span><span class="o">=</span><span class="n">compression</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Cannot write stack&#39;</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>
                        <span class="k">raise</span> <span class="n">e</span>
                
                <span class="k">if</span> <span class="n">label</span> <span class="o">==</span> <span class="s1">&#39;index&#39;</span><span class="p">:</span>
                    <span class="n">fh</span><span class="p">[</span><span class="n">path</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;recommended_zchunks&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="c1">#     fh[path.rsplit(&#39;/&#39;, 1)[0]].attrs[&#39;signal&#39;] = self._diff_stack_label</span>

                <span class="n">arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
                <span class="n">datasets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_diff_stack_label</span> <span class="o">==</span> <span class="n">label</span><span class="p">:</span>
                    <span class="n">fh</span><span class="p">[</span><span class="n">path</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;signal&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">label</span>

        <span class="k">if</span> <span class="n">lazy</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">arrays</span><span class="p">,</span> <span class="n">datasets</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">catch_warnings</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">progress_bar</span><span class="p">:</span>
                    <span class="k">with</span> <span class="n">ProgressBar</span><span class="p">():</span>
                        <span class="n">da</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">datasets</span><span class="p">,</span> <span class="n">scheduler</span><span class="o">=</span><span class="n">scheduler</span><span class="p">,</span> <span class="n">return_stored</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">da</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">datasets</span><span class="p">,</span> <span class="n">scheduler</span><span class="o">=</span><span class="n">scheduler</span><span class="p">,</span> <span class="n">return_stored</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">fh</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_handles</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">fh</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span></div>
                
<div class="viewcode-block" id="Dataset.store_stack_fast"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.store_stack_fast">[docs]</a>    <span class="k">def</span> <span class="nf">store_stack_fast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">client</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Client</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">sync</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                         <span class="n">compression</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="mi">32004</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Store (and compute) a single stack to HDF5 file(s), using a dask.distributed cluster.</span>
<span class="sd">        </span>
<span class="sd">        This allows for proper parallel computation (on single or many machines) and is wa(aaa)y faster</span>
<span class="sd">        than the standard `store_stacks`, which only works with threads.</span>
<span class="sd">        Typically, you&#39;ll want to use this method to store a processed diffraction data stack.</span>
<span class="sd">            </span>
<span class="sd">        Note:</span>
<span class="sd">            If the stack to be stored depends on computationally heavy (but memory-fitting) dask</span>
<span class="sd">            arrays which you want to retain outside this computation (e.g. to store them using</span>
<span class="sd">            store_stacks), make sure they are persisted before calling this function.</span>
<span class="sd">            Otherwise, they will be re-calculated from scratch.</span>

<span class="sd">        Args:</span>
<span class="sd">            label (Optional[str]): Label of the stack to be computed and stored. If None, use the value</span>
<span class="sd">                stored in diff_stack_label. Defaults to None</span>
<span class="sd">            client (Optional[Client], optional): dask.distributed client connected to a cluster to perform</span>
<span class="sd">                the computation on. Defaults to None.</span>
<span class="sd">            sync (bool, optional): if True (default), computes and stores immediately, and returns a pandas </span>
<span class="sd">                dataframe containing metadata of everything stored, for validation. If False,</span>
<span class="sd">                returns a list of dask.delayed objects which encapsulate the computation/storage. Defaults to True.</span>
<span class="sd">            compression (Union[int, str], optional): HDF5 compression filter to use. Common choices are &#39;gzip&#39;, &#39;none&#39;,</span>
<span class="sd">                or 32004, which is the lz4 filter often used for diffraction data. Defaults to 32004.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pd.DataFrame: pandas DataFrame holding ID columns of the computed shots. They can be merged</span>
<span class="sd">                with the shot list to cross-check if everything went ok. If sync=False, a list of futures to tuples</span>
<span class="sd">                (file, subset, path, idcs) for each dask array chunk is returned instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_diff_stack_label</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_files_open</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_files_writable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Please open files in write mode or close them before storing.&#39;</span><span class="p">)</span>
        
        <span class="kn">from</span> <span class="nn">distributed</span> <span class="kn">import</span> <span class="n">Lock</span>

        <span class="n">stack</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stacks</span><span class="p">[</span><span class="n">label</span><span class="p">]</span>
            
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Initializing data sets for diffraction stack </span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s1">...&#39;</span><span class="p">)</span>
            
        <span class="c1"># initialize datasets in files</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">subset</span><span class="p">),</span> <span class="n">grp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="s1">&#39;subset&#39;</span><span class="p">]):</span>
            <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
                <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_pattern</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;%&#39;</span><span class="p">,</span> <span class="n">subset</span><span class="p">)</span>
                <span class="n">fh</span><span class="o">.</span><span class="n">require_dataset</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> 
                                        <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">grp</span><span class="p">),)</span> <span class="o">+</span> <span class="n">stack</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> 
                                        <span class="n">dtype</span><span class="o">=</span><span class="n">stack</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> 
                                        <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">stack</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> 
                                        <span class="n">compression</span><span class="o">=</span><span class="n">compression</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">label</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_diff_stack_label</span><span class="p">:</span>
                    <span class="n">fh</span><span class="p">[</span><span class="n">path</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;signal&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">label</span>
                    
        
        <span class="bp">self</span><span class="o">.</span><span class="n">close_files</span><span class="p">()</span>
        
        <span class="n">chunk_label</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">cs</span><span class="p">)</span> <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">cs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span>
        <span class="n">stk_del</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">to_delayed</span><span class="p">()</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="n">locks</span> <span class="o">=</span> <span class="p">{</span><span class="n">fn</span><span class="p">:</span> <span class="n">Lock</span><span class="p">()</span> <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">}</span>

        <span class="n">dels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Submitting tasks to dask.distributed scheduler...&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">chk</span><span class="p">,</span> <span class="p">(</span><span class="n">cl</span><span class="p">,</span> <span class="n">sht</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">stk_del</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">chunk_label</span><span class="p">)):</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">sht</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">([</span><span class="s1">&#39;file&#39;</span><span class="p">,</span><span class="s1">&#39;subset&#39;</span><span class="p">]))</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="n">ii_to</span> <span class="o">=</span> <span class="n">sht</span><span class="o">.</span><span class="n">shot_in_subset</span><span class="o">.</span><span class="n">values</span>
            <span class="n">dels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dask</span><span class="o">.</span><span class="n">delayed</span><span class="p">(</span><span class="n">nexus</span><span class="o">.</span><span class="n">_save_single_chunk</span><span class="p">)(</span><span class="n">chk</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sht</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">subset</span><span class="o">=</span><span class="n">sht</span><span class="o">.</span><span class="n">subset</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                                <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span> <span class="n">idcs</span><span class="o">=</span><span class="n">ii_to</span><span class="p">,</span> <span class="n">data_pattern</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_pattern</span><span class="p">,</span> 
                                <span class="n">lock</span><span class="o">=</span><span class="n">locks</span><span class="p">[</span><span class="n">sht</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>
            
        <span class="k">if</span> <span class="ow">not</span> <span class="n">sync</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dels</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># THIS DOES THE ACTUAL COMPUTATION/DATA STORAGE</span>
            <span class="k">if</span> <span class="n">client</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;If immediate computation is desired (sync=True), you have to provide a cluster.&#39;</span><span class="p">)</span>
            <span class="kn">import</span> <span class="nn">random</span>
            <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">dels</span><span class="p">)</span> <span class="c1"># shuffling tasks to minimize concurrent file access</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Starting computation...&#39;</span><span class="p">)</span>
            <span class="n">chunk_info</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">dels</span><span class="p">,</span> <span class="n">sync</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">chunk_info</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="s1">&#39;subset&#39;</span><span class="p">,</span> <span class="s1">&#39;path&#39;</span><span class="p">,</span> <span class="s1">&#39;shot_in_subset&#39;</span><span class="p">])</span></div>
        
<div class="viewcode-block" id="Dataset.compute_and_save"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.compute_and_save">[docs]</a>    <span class="k">def</span> <span class="nf">compute_and_save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">diff_stack_label</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">list_file</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">client</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Client</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                         <span class="n">exclude_stacks</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">persist_diff</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> 
                         <span class="n">persist_all</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">compression</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">32004</span><span class="p">,</span>
                         <span class="n">store_features</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compound method to fully compute a dataset and write it to disk. </span>
<span class="sd">        </span>
<span class="sd">        It is designed for completely writing HDF5 files from scratch, not to append to or modify existing ones,</span>
<span class="sd">        in which case you have to use the more fine-grained methods for data storage.</span>
<span class="sd">        The foolowing steps are taken:</span>
<span class="sd">        </span>
<span class="sd">        * Initialize the HDF5 files (using `init_files`)</span>
<span class="sd">        * Store the metadata tables (shots, features, peaks, predictions)</span>
<span class="sd">        * Compute/store all non-diffraction-data stacks (using `store_stacks`). If this step takes too long, make</span>
<span class="sd">          sure that computation-heavy but small stacks are already persisted in memory.</span>
<span class="sd">        * Compute/store the diffraction data set (identified by `diff_stack_label`) using `store_stack_fast`.</span>
<span class="sd">        * Write a list file which can be used to reload the dataset or to feed into CrystFEL.</span>

<span class="sd">        Args:</span>
<span class="sd">            diff_stack_label (Optional[str], optional): Label of the diffraction data stack. If None, use</span>
<span class="sd">                the one stored in `diff_stack_label`. Defaults to None.</span>
<span class="sd">            list_file (Optional[str], optional): Name of the list file to be written. Defaults to None.</span>
<span class="sd">            client (Optional[Client], optional): dask.distributed client for computation of the diffraction</span>
<span class="sd">                data. Defaults to None.</span>
<span class="sd">            exclude_stacks (Union[str,List[str]], optional): Labels of data stacks to exclude. Defaults to None.</span>
<span class="sd">            overwrite (bool, optional): Overwrite existing files. Defaults to False.</span>
<span class="sd">            persist_diff (bool, optional): Changes the dask array underlying diffraction data stack from the </span>
<span class="sd">                computed one to the one stored in the HDF5 file. This is different from persisting to memory (as is</span>
<span class="sd">                done otherwise), as it persists the data *from disk*: if you access it using e.g. .compute(), it will be loaded</span>
<span class="sd">                from disk instead of being recomputed. Defaults to True.</span>
<span class="sd">            persist_all (bool, optional): Changes dask arrays underlying *all* stacks from the </span>
<span class="sd">                computed one to the one stored in the HDF5 file. Defaults to False.</span>
<span class="sd">            compression (Union[str, int], optional): HDF5 compression filter to use. Common choices are &#39;gzip&#39;, &#39;none&#39;,</span>
<span class="sd">                or 32004, which is the lz4 filter often used for diffraction data. Defaults to 32004.</span>
<span class="sd">            store_features (bool, optional): store/overwrite the feature table into the files. Defaults to True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#TODO generalize to storing several diffraction stacks using sync=False.</span>
        
        <span class="k">if</span> <span class="n">diff_stack_label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">diff_stack_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diff_stack_label</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">diff_stack_label</span> <span class="k">else</span> <span class="kc">None</span>
         
        <span class="k">if</span> <span class="p">(</span><span class="n">diff_stack_label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">diff_stack_label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stacks</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Stack </span><span class="si">{</span><span class="n">diff_stack_label</span><span class="si">}</span><span class="s1"> not found in dataset.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">diff_stack_label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">client</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;If a diffraction data stack is specified, you must supply a dask.distributed client object.&#39;</span><span class="p">)</span>        
            
        <span class="k">for</span> <span class="n">dn</span> <span class="ow">in</span> <span class="p">{</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">}:</span>
            <span class="k">if</span> <span class="n">dn</span><span class="p">:</span>
                <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">exclude_stacks</span> <span class="o">=</span> <span class="p">[</span><span class="n">exclude_stacks</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exclude_stacks</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">exclude_stacks</span>
        <span class="n">exclude_stacks</span> <span class="o">=</span> <span class="p">[</span><span class="n">diff_stack_label</span><span class="p">]</span> <span class="k">if</span> <span class="n">exclude_stacks</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[</span><span class="n">diff_stack_label</span><span class="p">]</span> <span class="o">+</span> <span class="n">exclude_stacks</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Initializing data files...&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_files</span><span class="p">(</span><span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Storing meta tables...&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">store_tables</span><span class="p">(</span><span class="n">shots</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="n">store_features</span><span class="p">)</span>
                
        <span class="c1"># store all data stacks except for the actual diffraction data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">open_stacks</span><span class="p">(</span><span class="n">readonly</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        
        <span class="n">meta_stacks</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stacks</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclude_stacks</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Storing meta stacks </span><span class="si">{</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">meta_stacks</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">store_stacks</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="n">meta_stacks</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="n">compression</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Storing diffraction data stack </span><span class="si">{</span><span class="n">diff_stack_label</span><span class="si">}</span><span class="s1">... monitor progress at </span><span class="si">{</span><span class="n">client</span><span class="o">.</span><span class="n">dashboard_link</span><span class="si">}</span><span class="s1"> (or forward port if remote)&#39;</span><span class="p">)</span>
        <span class="n">chunk_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">store_stack_fast</span><span class="p">(</span><span class="n">diff_stack_label</span><span class="p">,</span> <span class="n">client</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="n">compression</span><span class="p">)</span>

        <span class="c1"># make sure that the calculation went consistent with the data set</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">sh</span><span class="p">,</span> <span class="n">sh_grp</span><span class="p">),</span> <span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">ch_grp</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="s1">&#39;subset&#39;</span><span class="p">]),</span> <span class="n">chunk_info</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="s1">&#39;subset&#39;</span><span class="p">])):</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">sh_grp</span><span class="o">.</span><span class="n">shot_in_subset</span><span class="o">.</span><span class="n">values</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">ch_grp</span><span class="o">.</span><span class="n">shot_in_subset</span><span class="o">.</span><span class="n">values</span><span class="p">))):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Incosistency between calculated data and shot list in </span><span class="si">{</span><span class="n">sh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">sh</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1"> found. Please investigate.&#39;</span><span class="p">)</span>
                
        <span class="k">if</span> <span class="n">list_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write_list</span><span class="p">(</span><span class="n">list_file</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">persist_all</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">open_stacks</span><span class="p">(</span><span class="n">readonly</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">chunking</span><span class="o">=</span><span class="s1">&#39;existing&#39;</span><span class="p">)</span>
            
        <span class="k">elif</span> <span class="n">persist_diff</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">open_stacks</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="n">diff_stack_label</span><span class="p">],</span> <span class="n">readonly</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">chunking</span><span class="o">=</span><span class="s1">&#39;existing&#39;</span><span class="p">)</span>        </div>
            
    <span class="c1">#     else:</span>
    <span class="c1">#         ds_compute.open_stacks(labels=[]) # only populate the file handle list</span>

<div class="viewcode-block" id="Dataset.rechunk_stacks"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.rechunk_stacks">[docs]</a>    <span class="k">def</span> <span class="nf">rechunk_stacks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chunk_height</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">chunk_height</span>
        <span class="n">ss_chunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="s1">&#39;subset&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">size</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="p">((</span><span class="n">l</span> <span class="o">//</span> <span class="n">c</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="n">c</span><span class="p">])</span> <span class="o">+</span> <span class="p">([</span><span class="n">l</span> <span class="o">%</span> <span class="n">c</span><span class="p">]</span> <span class="k">if</span> <span class="n">l</span> <span class="o">%</span> <span class="n">c</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">[]))</span>
        <span class="n">zchunks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ss_chunk</span><span class="p">])</span>
        <span class="c1"># print(zchunks)</span>
        <span class="k">assert</span> <span class="n">zchunks</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">sn</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stacks</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># print(sn)</span>
            <span class="c1"># print(tuple(zchunks))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_stacks</span><span class="p">[</span><span class="n">sn</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">rechunk</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">zchunks</span><span class="p">)})</span></div>
            <span class="c1"># self.add_stack(sn, s.rechunk({0: tuple(zchunks)}), overwrite=True)</span>

<div class="viewcode-block" id="Dataset.stacks_to_shots"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.stacks_to_shots">[docs]</a>    <span class="k">def</span> <span class="nf">stacks_to_shots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stack_labels</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">],</span> <span class="n">shot_labels</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stack_labels</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">stack_labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">stack_labels</span><span class="p">,]</span>
        <span class="k">if</span> <span class="n">shot_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shot_labels</span> <span class="o">=</span> <span class="n">stack_labels</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shot_labels</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">shot_labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">shot_labels</span><span class="p">,]</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">Stacks</span><span class="p">()</span> <span class="k">as</span> <span class="n">stk</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">lbl_from</span><span class="p">,</span> <span class="n">lbl_to</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">stack_labels</span><span class="p">,</span> <span class="n">shot_labels</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">lbl_from</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">stk</span><span class="p">:</span>
                    <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">lbl_from</span><span class="si">}</span><span class="s1"> not in stacks, skipping.&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="p">[</span><span class="n">lbl_to</span><span class="p">]</span> <span class="o">=</span> <span class="n">stk</span><span class="p">[</span><span class="n">lbl_from</span><span class="p">]</span></div>
            
<div class="viewcode-block" id="Dataset.merge_pattern_info"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.merge_pattern_info">[docs]</a>    <span class="k">def</span> <span class="nf">merge_pattern_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ds_from</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s1">&#39;Dataset&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">merge_cols</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                           <span class="n">by</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;region&#39;</span><span class="p">,</span> <span class="s1">&#39;run&#39;</span><span class="p">,</span> <span class="s1">&#39;crystal_id&#39;</span><span class="p">),</span> 
                           <span class="n">persist</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Merge shot-table and CXI peak data from another data set into this one, based</span>
<span class="sd">        on matching of the shot table columns specified in &quot;by&quot;. Default is (&#39;sample&#39;, &#39;region&#39;, &#39;run&#39;, &#39;crystal_id&#39;),</span>
<span class="sd">        which matches the shot information based on individual crystals.</span>
<span class="sd">        </span>
<span class="sd">        The typical application of this function is to take over diffraction pattern information such as pattern center</span>
<span class="sd">        and peak positions from an aggregated data set (where each pattern corresponds to exactly one shot) to a</span>
<span class="sd">        full data set (where each pattern often corresponds to many shots, such as frames of a diffraction movie).</span>
<span class="sd">        </span>
<span class="sd">        In this case you&#39;d call the method like: `ds_all.merge_pattern_info(ds_agg)`, where ds_agg is the</span>
<span class="sd">        aggregated data set to get the information from.</span>

<span class="sd">        Args:</span>
<span class="sd">            ds_from (Uniton[Dataset, str]): Diffractem Dataset to take information from, or filename of h5 or list file.</span>
<span class="sd">                Esepcially friendly for h5 files written by get_image_info.</span>
<span class="sd">            merge_cols (Optional[List[str]], optional): Shot table columns to take over from other data set. If None,</span>
<span class="sd">                all columns are taken over which are not present in the shot table currently. Defaults to None.</span>
<span class="sd">            by (Union[List[str], Tuple[str]], optional): Shot table columns to match by. </span>
<span class="sd">                Defaults to (&#39;sample&#39;, &#39;region&#39;, &#39;run&#39;, &#39;crystal_id&#39;).</span>
<span class="sd">            persist (bool, optional): Persist the merged CXI peak data to memory. Defaults to True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#TODO Figure out a good way to handle predictions</span>
        
        <span class="n">by</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">by</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ds_from</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">ds_from</span> <span class="o">=</span> <span class="n">Dataset</span><span class="o">.</span><span class="n">from_files</span><span class="p">(</span><span class="n">ds_from</span><span class="p">,</span> <span class="n">chunking</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">persist_meta</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="n">merge_cols</span> <span class="o">=</span> <span class="n">ds_from</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">+</span> 
                                                    <span class="p">[</span><span class="s1">&#39;_Event&#39;</span><span class="p">,</span> <span class="s1">&#39;_file&#39;</span><span class="p">,</span> <span class="s1">&#39;file_event_hash&#39;</span><span class="p">])</span> \
                                                        <span class="k">if</span> <span class="n">merge_cols</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">merge_cols</span>
        
        <span class="n">sh_from</span> <span class="o">=</span> <span class="n">ds_from</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># avoid side effects on ds_from</span>
        <span class="n">sh_from</span><span class="p">[</span><span class="s1">&#39;ii_from&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sh_from</span><span class="p">))</span>
        <span class="n">sel_shots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">sh_from</span><span class="p">[</span><span class="n">by</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">merge_cols</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;ii_from&#39;</span><span class="p">]],</span> <span class="n">on</span><span class="o">=</span><span class="n">by</span><span class="p">,</span> 
                                        <span class="n">how</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="s1">&#39;m:1&#39;</span><span class="p">,</span> <span class="n">indicator</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">sel_shots</span><span class="o">.</span><span class="n">_merge</span> <span class="o">==</span> <span class="s1">&#39;both&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Not all features present in the dataset are present in ds_from.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shots</span> <span class="o">=</span> <span class="n">sel_shots</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;_merge&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">peakdata</span> <span class="o">=</span> <span class="n">ds_from</span><span class="o">.</span><span class="n">peak_data</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">ii_from</span><span class="o">.</span><span class="n">diff</span><span class="p">()</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">peakdata</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">ii_from</span><span class="o">.</span><span class="n">values</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">peakdata</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">peak_data</span> <span class="o">=</span> <span class="n">peakdata</span>
        <span class="c1"># for k, v in peakdata.items():</span>
        <span class="c1">#     self.add_stack(k, v, overwrite=True)</span>
        
        <span class="k">if</span> <span class="n">persist</span><span class="p">:</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">persist_stacks</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">peakdata</span><span class="p">))</span></div>

<div class="viewcode-block" id="Dataset.merge_acquisition_data"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.merge_acquisition_data">[docs]</a>    <span class="k">def</span> <span class="nf">merge_acquisition_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fields</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="c1"># mange instrument (acquisition) data like exposure time etc. into shot list</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;merge_acquisition_data not yet implemented&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Dataset.write_list"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.write_list">[docs]</a>    <span class="k">def</span> <span class="nf">write_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">listfile</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">append</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes the files in the dataset into a list file, containing each file on a line.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            listfile (str): list file name</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#TODO allow to export CrystFEL-style single-pattern lists</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">listfile</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span> <span class="k">if</span> <span class="n">append</span> <span class="k">else</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
            <span class="n">fh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Dataset.write_virtual_file"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.write_virtual_file">[docs]</a>    <span class="k">def</span> <span class="nf">write_virtual_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;virtual&#39;</span><span class="p">,</span> <span class="n">diff_stack_label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;zero_image&#39;</span><span class="p">,</span>
                              <span class="n">virtual_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a virtual HDF5 file containing the meta data of the dataset, but not the actual</span>
<span class="sd">        diffraction. Instead of the diffraction stack, a dummy stack containing only ones is written</span>
<span class="sd">        into the file, which due to its compression becomes very small.</span>
<span class="sd">        </span>
<span class="sd">        The peak positions in the virtual file are changed, such that they refer to a &quot;virtual&quot; geometry,</span>
<span class="sd">        corresponding to a square detector with a size given by `virtual_size`. On this detector, the pattern</span>
<span class="sd">        is centered.</span>
<span class="sd">        </span>
<span class="sd">        This file can then be used as input to CrystFEL&#39;s *indexamajig*, with a simple centered geometry.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename (str): [description]</span>
<span class="sd">            diff_stack_label (str): [description]</span>
<span class="sd">            virtual_size (int, optional): [description]. Defaults to 1024.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shot_id_cols</span>
        <span class="n">ds_ctr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_selection</span><span class="p">(</span><span class="s1">&#39;True&#39;</span><span class="p">,</span> <span class="n">file_suffix</span><span class="o">=</span><span class="s1">&#39;_virtual.h5&#39;</span><span class="p">,</span> <span class="n">new_folder</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="c1"># ds_ctr.shots[&#39;file_event_hash&#39;] = tools.dataframe_hash(self.shots[[&#39;file&#39;, &#39;Event&#39;]])</span>
        <span class="c1"># ds_ctr.shots[&#39;feature_hash&#39;] = tools.dataframe_hash(self.shots[[&#39;sample&#39;, &#39;region&#39;, &#39;run&#39;, &#39;crystal_id&#39;]])</span>
        <span class="n">ds_ctr</span><span class="o">.</span><span class="n">shots</span><span class="p">[[</span><span class="s1">&#39;_file&#39;</span><span class="p">,</span> <span class="s1">&#39;_Event&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="p">[[</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="s1">&#39;Event&#39;</span><span class="p">]]</span>
        <span class="n">ds_ctr</span><span class="o">.</span><span class="n">shots</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s1">.h5&#39;</span>
        <span class="n">ds_ctr</span><span class="o">.</span><span class="n">shots</span><span class="p">[</span><span class="s1">&#39;subset&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;entry&#39;</span>
        <span class="n">ds_ctr</span><span class="o">.</span><span class="n">shots</span><span class="p">[</span><span class="s1">&#39;shot_in_subset&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ds_ctr</span><span class="o">.</span><span class="n">shots</span><span class="p">))</span>
        <span class="n">ds_ctr</span><span class="o">.</span><span class="n">shots</span><span class="p">[</span><span class="s1">&#39;Event&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ds_ctr</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">subset</span> <span class="o">+</span> <span class="s1">&#39;//&#39;</span> <span class="o">+</span> <span class="n">ds_ctr</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">shot_in_subset</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>

        <span class="n">fake_img</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">ds_ctr</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">virtual_size</span><span class="p">,</span> <span class="n">virtual_size</span><span class="p">),</span> 
                            <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>

        <span class="n">ds_ctr</span><span class="o">.</span><span class="n">add_stack</span><span class="p">(</span><span class="s1">&#39;zero_image&#39;</span><span class="p">,</span> <span class="n">fake_img</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">set_diff_stack</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">ds_ctr</span><span class="o">.</span><span class="n">add_stack</span><span class="p">(</span><span class="s1">&#39;peakXPosRaw&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">ds_ctr</span><span class="o">.</span><span class="n">peakXPosRaw</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">center_x</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> 
                                        <span class="o">+</span> <span class="n">virtual_size</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> 
                        <span class="o">*</span> <span class="p">(</span><span class="n">ds_ctr</span><span class="o">.</span><span class="n">peakXPosRaw</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">),</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">ds_ctr</span><span class="o">.</span><span class="n">add_stack</span><span class="p">(</span><span class="s1">&#39;peakYPosRaw&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">ds_ctr</span><span class="o">.</span><span class="n">peakYPosRaw</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="o">.</span><span class="n">center_y</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> 
                                        <span class="o">+</span> <span class="n">virtual_size</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> 
                        <span class="o">*</span> <span class="p">(</span><span class="n">ds_ctr</span><span class="o">.</span><span class="n">peakYPosRaw</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">),</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Writing fake all-ones data (yes, it takes that long).&#39;</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">ds_ctr</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
            <span class="n">fh</span><span class="o">.</span><span class="n">require_group</span><span class="p">(</span><span class="s1">&#39;/entry/data&#39;</span><span class="p">)</span>
        <span class="n">ds_ctr</span><span class="o">.</span><span class="n">open_stacks</span><span class="p">(</span><span class="n">readonly</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ds_ctr</span><span class="o">.</span><span class="n">store_stacks</span><span class="p">([</span><span class="s1">&#39;zero_image&#39;</span><span class="p">,</span> <span class="s1">&#39;nPeaks&#39;</span><span class="p">,</span> <span class="s1">&#39;peakXPosRaw&#39;</span><span class="p">,</span> <span class="s1">&#39;peakYPosRaw&#39;</span><span class="p">,</span> 
                            <span class="s1">&#39;peakTotalIntensity&#39;</span><span class="p">],</span>
                            <span class="n">compression</span><span class="o">=</span><span class="s1">&#39;gzip&#39;</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">ds_ctr</span><span class="o">.</span><span class="n">close_stacks</span><span class="p">()</span>
        <span class="n">ds_ctr</span><span class="o">.</span><span class="n">store_tables</span><span class="p">(</span><span class="n">shots</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">peaks</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">predict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ds_ctr</span><span class="o">.</span><span class="n">write_list</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s1">.lst&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Virtual file </span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s1">.h5 and list file </span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s1">.lst successfully exported.&#39;</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="Dataset.view"><a class="viewcode-back" href="../../diffractem.dataset.html#diffractem.dataset.Dataset.view">[docs]</a>    <span class="k">def</span> <span class="nf">view</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calls `tools.viewing_widget` on the dataset. Keyword arguments are passed through.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tools</span><span class="o">.</span><span class="n">viewing_widget</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Robert Bücker

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>